{
  "api/Stride.CommunityToolkit.Bepu.Body2DComponent.html": {
    "href": "api/Stride.CommunityToolkit.Bepu.Body2DComponent.html",
    "title": "Class Body2DComponent | Stride Community Toolkit",
    "summary": "Class Body2DComponent Namespace Stride.CommunityToolkit.Bepu Assembly Stride.CommunityToolkit.Bepu.dll [ComponentCategory(\"Bepu\")] public class Body2DComponent : BodyComponent, IIdentifiable Inheritance object EntityComponent CollidableComponent BodyComponent Body2DComponent Implements IIdentifiable Inherited Members BodyComponent.ApplyImpulse(Vector3, Vector3) BodyComponent.ApplyAngularImpulse(Vector3) BodyComponent.ApplyLinearImpulse(Vector3) BodyComponent.SetPose(Vector3, Quaternion) BodyComponent.DetachInner() BodyComponent.GetHandleValue() BodyComponent.Kinematic BodyComponent.Gravity BodyComponent.InterpolationMode BodyComponent.ContinuousDetectionMode BodyComponent.SleepThreshold BodyComponent.MinimumTimestepCountUnderThreshold BodyComponent.Awake BodyComponent.LinearVelocity BodyComponent.AngularVelocity BodyComponent.Position BodyComponent.Orientation BodyComponent.BodyInertia BodyComponent.SpeculativeMargin BodyComponent.ContinuousDetection BodyComponent.Constraints BodyComponent.CollidableReference BodyComponent.MaterialProperties BodyComponent.Pose CollidableComponent.TryUpdateMaterialProperties() CollidableComponent.RegisterContactHandler() CollidableComponent.UnregisterContactHandler() CollidableComponent.IsContactHandlerRegistered() CollidableComponent.ShapeIndex CollidableComponent.Simulation CollidableComponent.Collider CollidableComponent.SpringFrequency CollidableComponent.SpringDampingRatio CollidableComponent.FrictionCoefficient CollidableComponent.MaximumRecoveryVelocity CollidableComponent.CollisionLayer CollidableComponent.CollisionGroup CollidableComponent.SimulationSelector CollidableComponent.ContactEventHandler CollidableComponent.CenterOfMass EntityComponent.Entity EntityComponent.Id EntityComponent.EnsureEntity Methods AccessBodyReference(Vector3) public void AccessBodyReference(Vector3 value) Parameters value Vector3 AttachInner(RigidPose, BodyInertia, TypedIndex) Called every time this is added to a simulation protected override void AttachInner(RigidPose containerPose, BodyInertia shapeInertia, TypedIndex shapeIndex) Parameters containerPose RigidPose shapeInertia BodyInertia shapeIndex TypedIndex Remarks May occur when certain larger changes are made to the object, Simulation is the one this object is being added to"
  },
  "api/Stride.CommunityToolkit.Bepu.CameraComponentExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Bepu.CameraComponentExtensions.html",
    "title": "Class CameraComponentExtensions | Stride Community Toolkit",
    "summary": "Class CameraComponentExtensions Namespace Stride.CommunityToolkit.Bepu Assembly Stride.CommunityToolkit.Bepu.dll Provides extension methods for CameraComponent to facilitate raycasting functionality. public static class CameraComponentExtensions Inheritance object CameraComponentExtensions Methods Raycast(CameraComponent, Vector2, float, out HitInfo, CollisionMask) Performs a raycast using a screen position. public static bool Raycast(this CameraComponent camera, Vector2 screenPosition, float maxDistance, out HitInfo hit, CollisionMask collisionMask = CollisionMask.Everything) Parameters camera CameraComponent The CameraComponent used to calculate the ray. screenPosition Vector2 The screen position in normalized device coordinates (NDC). maxDistance float The maximum distance for the raycast. hit HitInfo When this method returns, contains the HitInfo if the raycast hits a collider, otherwise null. collisionMask CollisionMask Specifies the collision mask to filter which objects the raycast can hit. Defaults to Everything. Returns bool true if the raycast hit a collider; otherwise, false. Exceptions ArgumentNullException Thrown if camera is null. RaycastMouse(CameraComponent, ScriptComponent, float, out HitInfo, CollisionMask) Performs a raycast using the mouse's screen position. public static bool RaycastMouse(this CameraComponent camera, ScriptComponent component, float maxDistance, out HitInfo hit, CollisionMask collisionMask = CollisionMask.Everything) Parameters camera CameraComponent The CameraComponent used to calculate the ray. component ScriptComponent The ScriptComponent providing access to the mouse position. maxDistance float The maximum distance for the raycast. hit HitInfo When this method returns, contains the HitInfo if the raycast hits a collider, otherwise null. collisionMask CollisionMask Specifies the collision mask to filter which objects the raycast can hit. Defaults to Everything. Returns bool true if the raycast hit a collider; otherwise, false. Exceptions ArgumentNullException Thrown if camera or component is null."
  },
  "api/Stride.CommunityToolkit.Bepu.GameExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Bepu.GameExtensions.html",
    "title": "Class GameExtensions | Stride Community Toolkit",
    "summary": "Class GameExtensions Namespace Stride.CommunityToolkit.Bepu Assembly Stride.CommunityToolkit.Bepu.dll public static class GameExtensions Inheritance object GameExtensions Methods Add3DGround(Game, string?, Vector2?, bool) public static Entity Add3DGround(this Game game, string? entityName = \"Ground\", Vector2? size = null, bool includeCollider = true) Parameters game Game entityName string size Vector2? includeCollider bool Returns Entity Create2DPrimitive(IGame, Primitive2DModelType, Primitive2DCreationOptions?) public static Entity Create2DPrimitive(this IGame game, Primitive2DModelType type, Primitive2DCreationOptions? options = null) Parameters game IGame type Primitive2DModelType options Primitive2DCreationOptions Returns Entity Create3DPrimitive(IGame, PrimitiveModelType, Primitive3DCreationOptions?) public static Entity Create3DPrimitive(this IGame game, PrimitiveModelType type, Primitive3DCreationOptions? options = null) Parameters game IGame type PrimitiveModelType options Primitive3DCreationOptions Returns Entity SetupBase2DScene(Game) public static void SetupBase2DScene(this Game game) Parameters game Game SetupBase3DScene(Game) public static void SetupBase3DScene(this Game game) Parameters game Game"
  },
  "api/Stride.CommunityToolkit.Bepu.Primitive2DCreationOptions.html": {
    "href": "api/Stride.CommunityToolkit.Bepu.Primitive2DCreationOptions.html",
    "title": "Class Primitive2DCreationOptions | Stride Community Toolkit",
    "summary": "Class Primitive2DCreationOptions Namespace Stride.CommunityToolkit.Bepu Assembly Stride.CommunityToolkit.Bepu.dll Provides options for creating a 2D primitive entity, such as a square or rectangle. Inherits common entity creation options from PrimitiveCreationOptions and adds specific settings for 2D primitive models. public class Primitive2DCreationOptions : PrimitiveCreationOptions Inheritance object PrimitiveCreationOptions Primitive2DCreationOptions Inherited Members PrimitiveCreationOptions.EntityName PrimitiveCreationOptions.Material PrimitiveCreationOptions.IncludeCollider PrimitiveCreationOptions.RenderGroup Properties Component Gets or sets the physics component to be added to the entity. public CollidableComponent Component { get; set; } Property Value CollidableComponent Depth Gets or sets the depth of the 2D primitive. Defaults to 1. The depth adds a third dimension (Z-axis) to the 2D object, making it slightly thicker than a flat object. This is useful for the physics engine, which may be optimized for 3D physics calculations. Even when handling 2D objects, the physics system often operates in 3D space with constraints applied to specific axes. public float Depth { get; set; } Property Value float Size Gets or sets the size of the primitive model. If null, default dimensions are used. public Vector2? Size { get; set; } Property Value Vector2?"
  },
  "api/Stride.CommunityToolkit.Bepu.Primitive3DCreationOptions.html": {
    "href": "api/Stride.CommunityToolkit.Bepu.Primitive3DCreationOptions.html",
    "title": "Class Primitive3DCreationOptions | Stride Community Toolkit",
    "summary": "Class Primitive3DCreationOptions Namespace Stride.CommunityToolkit.Bepu Assembly Stride.CommunityToolkit.Bepu.dll Provides options for creating a primitive entity in a 3D scene. public class Primitive3DCreationOptions : PrimitiveCreationOptions Inheritance object PrimitiveCreationOptions Primitive3DCreationOptions Inherited Members PrimitiveCreationOptions.EntityName PrimitiveCreationOptions.Material PrimitiveCreationOptions.IncludeCollider PrimitiveCreationOptions.RenderGroup Remarks This class inherits from PrimitiveCreationOptions and extends it with properties specific to 3D models, such as size and physics components. Properties Component Gets or sets the physics component to be added to the entity. Defaults to a new instance of BodyComponent. public CollidableComponent Component { get; set; } Property Value CollidableComponent Remarks By default, a BodyComponent is assigned to the entity to handle physics simulations, but you can override this with a custom physics component if needed. Size Gets or sets the size of the 3D primitive model. If null, default dimensions are used. public Vector3? Size { get; set; } Property Value Vector3? Remarks The Size property allows you to specify custom dimensions for the 3D model. If no size is specified, default dimensions will be applied, based on the type of primitive."
  },
  "api/Stride.CommunityToolkit.Bepu.Simulation2DComponent.html": {
    "href": "api/Stride.CommunityToolkit.Bepu.Simulation2DComponent.html",
    "title": "Class Simulation2DComponent | Stride Community Toolkit",
    "summary": "Class Simulation2DComponent Namespace Stride.CommunityToolkit.Bepu Assembly Stride.CommunityToolkit.Bepu.dll [ComponentCategory(\"Bepu\")] public class Simulation2DComponent : SyncScript, IIdentifiable, ICollectorHolder, ISimulationUpdate, IComponent<ISimulationUpdate.SimUpdateProcessor, ISimulationUpdate>, IMarkedComponent Inheritance object EntityComponent ScriptComponent StartupScript SyncScript Simulation2DComponent Implements IIdentifiable ICollectorHolder ISimulationUpdate IComponent<ISimulationUpdate.SimUpdateProcessor, ISimulationUpdate> IMarkedComponent Inherited Members StartupScript.Start() ScriptComponent.LiveScriptingMask ScriptComponent.ScriptGlobalProfilingKey ScriptComponent.PriorityUpdated() ScriptComponent.Cancel() ScriptComponent.ProfilingKey ScriptComponent.Audio ScriptComponent.SpriteAnimation ScriptComponent.Services ScriptComponent.Game ScriptComponent.Content ScriptComponent.GameProfiler ScriptComponent.GraphicsDevice ScriptComponent.Input ScriptComponent.Script ScriptComponent.SceneSystem ScriptComponent.EffectSystem ScriptComponent.DebugText ScriptComponent.Streaming ScriptComponent.Log ScriptComponent.Priority ScriptComponent.IsLiveReloading ScriptComponent.Collector EntityComponent.Entity EntityComponent.Id EntityComponent.EnsureEntity Extension Methods ScriptComponentExtensions.DeltaTime(ScriptComponent) ScriptComponentExtensions.GetFirstGCCamera(ScriptComponent) ScriptComponentExtensions.GetGCCamera(ScriptComponent) ScriptComponentExtensions.GetGCCamera(ScriptComponent, string) Methods AfterSimulationUpdate(BepuSimulation, float) Called after the simulation updates public void AfterSimulationUpdate(BepuSimulation sim, float simTimeStep) Parameters sim BepuSimulation simTimeStep float The amount of time in seconds this simulation lasts for SimulationUpdate(BepuSimulation, float) Called before the simulation updates public void SimulationUpdate(BepuSimulation sim, float simTimeStep) Parameters sim BepuSimulation simTimeStep float The amount of time in seconds this simulation lasts for Update() Called every frame. public override void Update()"
  },
  "api/Stride.CommunityToolkit.Bepu.html": {
    "href": "api/Stride.CommunityToolkit.Bepu.html",
    "title": "Namespace Stride.CommunityToolkit.Bepu | Stride Community Toolkit",
    "summary": "Namespace Stride.CommunityToolkit.Bepu Classes Body2DComponent CameraComponentExtensions Provides extension methods for CameraComponent to facilitate raycasting functionality. GameExtensions Primitive2DCreationOptions Provides options for creating a 2D primitive entity, such as a square or rectangle. Inherits common entity creation options from PrimitiveCreationOptions and adds specific settings for 2D primitive models. Primitive3DCreationOptions Provides options for creating a primitive entity in a 3D scene. Simulation2DComponent"
  },
  "api/Stride.CommunityToolkit.Bullet.CameraComponentExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Bullet.CameraComponentExtensions.html",
    "title": "Class CameraComponentExtensions | Stride Community Toolkit",
    "summary": "Class CameraComponentExtensions Namespace Stride.CommunityToolkit.Bullet Assembly Stride.CommunityToolkit.Bullet.dll Provides a set of static methods for working with CameraComponent instances. public static class CameraComponentExtensions Inheritance object CameraComponentExtensions Remarks This class includes extension methods for performing various operations with CameraComponent instances, such as raycasting, converting screen positions to world positions, and more. These methods are useful for implementing features like object picking, camera control, and coordinate transformations in a 3D environment. Methods Raycast(CameraComponent, ScriptComponent, Vector2, CollisionFilterGroups, CollisionFilterGroupFlags) Performs a raycasting operation from the specified CameraComponent's position through the specified screen position in world coordinates, using the Simulation from the specified ScriptComponent, and returns information about the hit result. public static HitResult Raycast(this CameraComponent camera, ScriptComponent component, Vector2 screenPosition, CollisionFilterGroups collisionGroups = CollisionFilterGroups.DefaultFilter, CollisionFilterGroupFlags collisionFilterGroupFlags = CollisionFilterGroupFlags.DefaultFilter) Parameters camera CameraComponent The CameraComponent from which the ray should be cast. component ScriptComponent The ScriptComponent that contains the Simulation used for raycasting. screenPosition Vector2 The screen position in world coordinates through which the ray should be cast. collisionGroups CollisionFilterGroups Optional. The collision filter group to consider during the raycasting. Default is DefaultFilter. collisionFilterGroupFlags CollisionFilterGroupFlags Optional. The collision filter group flags to consider during the raycasting. Default is DefaultFilter. Returns HitResult A HitResult containing information about the hit result, including the hit location and other collision data. Raycast(CameraComponent, Simulation, Vector2, CollisionFilterGroups, CollisionFilterGroupFlags) Performs a raycasting operation from the specified CameraComponent's position through a specified screen position, using the provided Simulation, and returns information about the hit result. public static HitResult Raycast(this CameraComponent camera, Simulation simulation, Vector2 screenPosition, CollisionFilterGroups collisionGroups = CollisionFilterGroups.DefaultFilter, CollisionFilterGroupFlags collisionFilterGroupFlags = CollisionFilterGroupFlags.DefaultFilter) Parameters camera CameraComponent The CameraComponent from which the ray should be cast. simulation Simulation The Simulation used to perform the raycasting operation. screenPosition Vector2 The screen position in normalized screen coordinates (e.g., mouse position) where the ray should be cast. collisionGroups CollisionFilterGroups Optional. The collision filter group to consider during the raycasting. Default is DefaultFilter. collisionFilterGroupFlags CollisionFilterGroupFlags Optional. The collision filter group flags to consider during the raycasting. Default is DefaultFilter. Returns HitResult A HitResult containing information about the raycasting hit, including the hit location and other collision data. Remarks This method is useful for implementing features like object picking, where you want to select or interact with objects in the 3D world based on screen coordinates. RaycastMouse(CameraComponent, ScriptComponent, CollisionFilterGroups, CollisionFilterGroupFlags) Performs a raycasting operation from the specified CameraComponent's position through the mouse cursor position in screen coordinates, using input from the specified ScriptComponent, and returns information about the hit result. public static HitResult RaycastMouse(this CameraComponent camera, ScriptComponent component, CollisionFilterGroups collisionGroups = CollisionFilterGroups.DefaultFilter, CollisionFilterGroupFlags collisionFilterGroupFlags = CollisionFilterGroupFlags.DefaultFilter) Parameters camera CameraComponent The CameraComponent from which the ray should be cast. component ScriptComponent The ScriptComponent from which the mouse position should be taken. collisionGroups CollisionFilterGroups Optional. The collision filter group to consider during the raycasting. Default is DefaultFilter. collisionFilterGroupFlags CollisionFilterGroupFlags Optional. The collision filter group flags to consider during the raycasting. Default is DefaultFilter. Returns HitResult A HitResult containing information about the hit result, including the hit location and other collision data. RaycastMouse(CameraComponent, Simulation, Vector2, CollisionFilterGroups, CollisionFilterGroupFlags) Performs a raycasting operation from the specified CameraComponent's position through a specified screen position, using the provided Simulation, and returns information about the hit result. public static HitResult RaycastMouse(this CameraComponent camera, Simulation simulation, Vector2 screenPosition, CollisionFilterGroups collisionGroups = CollisionFilterGroups.DefaultFilter, CollisionFilterGroupFlags collisionFilterGroupFlags = CollisionFilterGroupFlags.DefaultFilter) Parameters camera CameraComponent The CameraComponent from which the ray should be cast. simulation Simulation The Simulation used to perform the raycasting operation. screenPosition Vector2 The screen position in screen coordinates (e.g., mouse position) from which the ray should be cast. collisionGroups CollisionFilterGroups Optional. The collision filter group to consider during the raycasting. Default is DefaultFilter. collisionFilterGroupFlags CollisionFilterGroupFlags Optional. The collision filter group flags to consider during the raycasting. Default is DefaultFilter. Returns HitResult A HitResult containing information about the hit result, including the hit location and other collision data."
  },
  "api/Stride.CommunityToolkit.Bullet.GameExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Bullet.GameExtensions.html",
    "title": "Class GameExtensions | Stride Community Toolkit",
    "summary": "Class GameExtensions Namespace Stride.CommunityToolkit.Bullet Assembly Stride.CommunityToolkit.Bullet.dll Provides extension methods for the Game class to simplify common game setup tasks for the Bullet Physics engine. public static class GameExtensions Inheritance object GameExtensions Methods Add2DGround(Game, string?, Vector2?) public static Entity Add2DGround(this Game game, string? entityName = \"Ground\", Vector2? size = null) Parameters game Game entityName string size Vector2? Returns Entity Add3DGround(Game, string?, Vector2?, bool) Adds a 3D ground entity to the game with a default size of 10x10 units. The ground is created as a plane, and a collider can be optionally added. public static Entity Add3DGround(this Game game, string? entityName = \"Ground\", Vector2? size = null, bool includeCollider = true) Parameters game Game The Game instance to which the ground entity will be added. entityName string The optional name for the ground entity. If not provided, it defaults to \"Ground\". size Vector2? The size of the ground, specified as a 2D vector. If not provided, it defaults to (10, 10) units. includeCollider bool Specifies whether to add a collider to the ground. Defaults to true. Returns Entity The created Entity object representing the 3D ground. AddInfinite3DGround(Game, string?, Vector2?, bool) Adds an infinite 3D ground entity to the game. The visible part of the ground is defined by the size parameter, while the collider is infinite and extends beyond the visible ground. public static Entity AddInfinite3DGround(this Game game, string? entityName = \"Ground\", Vector2? size = null, bool includeCollider = true) Parameters game Game The Game instance to which the infinite ground entity will be added. entityName string The optional name for the ground entity. If not provided, it defaults to \"Ground\". size Vector2? Defines the visible part of the ground, specified as a 2D vector. If not provided, it defaults to (10, 10) units. includeCollider bool Specifies whether to add a collider to the ground. The collider is infinite, extending beyond the visible part. Defaults to true. Returns Entity The created Entity object representing the infinite 3D ground. Create2DPrimitive(IGame, Primitive2DModelType, Primitive2DCreationOptions?) public static Entity Create2DPrimitive(this IGame game, Primitive2DModelType type, Primitive2DCreationOptions? options = null) Parameters game IGame type Primitive2DModelType options Primitive2DCreationOptions Returns Entity Create3DPrimitive(IGame, PrimitiveModelType, Primitive3DCreationOptions?) Creates a primitive 3D model entity of the specified type with optional customizations. public static Entity Create3DPrimitive(this IGame game, PrimitiveModelType type, Primitive3DCreationOptions? options = null) Parameters game IGame The game instance. type PrimitiveModelType The type of primitive model to create. options Primitive3DCreationOptions The options for creating the primitive model. If null, default options are used. Returns Entity A new entity representing the specified primitive model. Remarks The options parameter allows specifying various settings such as entity name, material, collider inclusion, size, render group, and 2D flag. Dimensions in the Vector3 for size are used in the order X, Y, Z. If size is null, default dimensions are used for the model. If no collider is included, the entity is returned without it. SetupBase2DScene(Game) public static void SetupBase2DScene(this Game game) Parameters game Game SetupBase3DScene(Game) Sets up a default 3D scene for the game, similar to creating an empty project through the editor. public static void SetupBase3DScene(this Game game) Parameters game Game The Game instance for which the base 3D scene will be set up. Remarks This method performs the following setup operations in sequence: Adds a default GraphicsCompositor to the game's SceneSystem and applies a clean UI stage. Adds a camera to the game and sets it up with a MouseLookCamera component. Adds a directional light to the game scene. Adds ground geometry to the game scene. ShowColliders(Game) Enables the visualization of collider shapes in the game scene. This feature is useful for debugging physics-related issues. public static void ShowColliders(this Game game) Parameters game Game The current game instance. Remarks This method activates the rendering of collider shapes within the physics simulation. It helps to visually inspect and debug the positioning and behaviour of colliders at runtime."
  },
  "api/Stride.CommunityToolkit.Bullet.Primitive2DCreationOptions.html": {
    "href": "api/Stride.CommunityToolkit.Bullet.Primitive2DCreationOptions.html",
    "title": "Class Primitive2DCreationOptions | Stride Community Toolkit",
    "summary": "Class Primitive2DCreationOptions Namespace Stride.CommunityToolkit.Bullet Assembly Stride.CommunityToolkit.Bullet.dll Provides options for creating a 2D primitive entity, such as a square or rectangle. Inherits common entity creation options from PrimitiveCreationOptions and adds specific settings for 2D primitive models. public class Primitive2DCreationOptions : PrimitiveCreationOptions Inheritance object PrimitiveCreationOptions Primitive2DCreationOptions Inherited Members PrimitiveCreationOptions.EntityName PrimitiveCreationOptions.Material PrimitiveCreationOptions.IncludeCollider PrimitiveCreationOptions.RenderGroup Properties Depth Gets or sets the depth of the 2D primitive. Defaults to 0.04f. The depth adds a third dimension (Z-axis) to the 2D object, making it slightly thicker than a flat object. This is useful for the physics engine, which may be optimized for 3D physics calculations. Even when handling 2D objects, the physics system often operates in 3D space with constraints applied to specific axes. public float Depth { get; set; } Property Value float PhysicsComponent Gets or sets the physics component to be added to the entity. Defaults to a new instance of RigidbodyComponent. This component allows the 2D primitive to interact with the physics system, enabling movement and collisions. public PhysicsComponent? PhysicsComponent { get; set; } Property Value PhysicsComponent Size Gets or sets the size of the 2D primitive model. If null, default size values will be used. The Vector2 represents width (X) and height (Y) dimensions. public Vector2? Size { get; set; } Property Value Vector2?"
  },
  "api/Stride.CommunityToolkit.Bullet.Primitive3DCreationOptions.html": {
    "href": "api/Stride.CommunityToolkit.Bullet.Primitive3DCreationOptions.html",
    "title": "Class Primitive3DCreationOptions | Stride Community Toolkit",
    "summary": "Class Primitive3DCreationOptions Namespace Stride.CommunityToolkit.Bullet Assembly Stride.CommunityToolkit.Bullet.dll Provides options for creating a primitive entity in a 3D scene. public class Primitive3DCreationOptions : PrimitiveCreationOptions Inheritance object PrimitiveCreationOptions Primitive3DCreationOptions Inherited Members PrimitiveCreationOptions.EntityName PrimitiveCreationOptions.Material PrimitiveCreationOptions.IncludeCollider PrimitiveCreationOptions.RenderGroup Remarks This class inherits from PrimitiveCreationOptions and extends it with properties specific to 3D models, such as size and physics components. Properties PhysicsComponent Gets or sets the physics component to be added to the entity. Defaults to a new instance of RigidbodyComponent. public PhysicsComponent? PhysicsComponent { get; set; } Property Value PhysicsComponent Remarks By default, a RigidbodyComponent is assigned to the entity to handle physics simulations, but you can override this with a custom physics component if needed. Size Gets or sets the size of the 3D primitive model. If null, default dimensions are used. public Vector3? Size { get; set; } Property Value Vector3? Remarks The Size property allows you to specify custom dimensions for the 3D model. If no size is specified, default dimensions will be applied, based on the type of primitive."
  },
  "api/Stride.CommunityToolkit.Bullet.SimulationExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Bullet.SimulationExtensions.html",
    "title": "Class SimulationExtensions | Stride Community Toolkit",
    "summary": "Class SimulationExtensions Namespace Stride.CommunityToolkit.Bullet Assembly Stride.CommunityToolkit.Bullet.dll Provides extension methods for the Simulation class to perform raycasting operations in a game simulation fro the Bullet physics. public static class SimulationExtensions Inheritance object SimulationExtensions Methods Raycast(Simulation, RaySegment) Raycasts and stops at the first hit. public static HitResult Raycast(this Simulation simulation, RaySegment raySegment) Parameters simulation Simulation Physics simulation. raySegment RaySegment Ray. Returns HitResult The hit results. Exceptions ArgumentNullException If the simulation argument is null. Raycast(Simulation, RaySegment, CollisionFilterGroups, CollisionFilterGroupFlags) Raycasts and stops at the first hit. public static HitResult Raycast(this Simulation simulation, RaySegment raySegment, CollisionFilterGroups collisionFilterGroups, CollisionFilterGroupFlags collisionFilterGroupFlags) Parameters simulation Simulation Physics simulation. raySegment RaySegment Ray. collisionFilterGroups CollisionFilterGroups The collision group of this shape sweep collisionFilterGroupFlags CollisionFilterGroupFlags The collision group that this shape sweep can collide with Returns HitResult The hit results. Exceptions ArgumentNullException If the simulation argument is null. Raycast(Simulation, Entity, Vector3, float, CollisionFilterGroupFlags, EFlags) Performs a raycast from the given entity's position in the specified direction, with the specified length. public static HitResult Raycast(this Simulation simulation, Entity entityPosition, Vector3 direction, float length = 1, CollisionFilterGroupFlags collisionFlags = CollisionFilterGroupFlags.AllFilter, EFlags eFlags = EFlags.None) Parameters simulation Simulation The Simulation instance in which the raycast is performed. entityPosition Entity The Entity from which the ray starts. The ray is cast from the entity's current world position. direction Vector3 The direction in which the ray is cast. length float The length of the ray, which determines how far it should extend from the entity. Defaults to 1. collisionFlags CollisionFilterGroupFlags Specifies which collision groups to include in the raycast. Defaults to AllFilter. eFlags EFlags Additional raycasting flags for fine-tuning the behavior. Defaults to None. Returns HitResult A HitResult that contains information about the first object hit by the ray, or an empty result if nothing is hit. Raycast(Simulation, Entity, float, CollisionFilterGroupFlags, EFlags) Performs a raycast from the given entity's position in the direction the entity is facing, with the specified length. public static HitResult Raycast(this Simulation simulation, Entity entityPosition, float length = 1, CollisionFilterGroupFlags collisionFlags = CollisionFilterGroupFlags.AllFilter, EFlags eFlags = EFlags.None) Parameters simulation Simulation The Simulation instance in which the raycast is performed. entityPosition Entity The Entity from which the ray starts. The ray is cast from the entity's current world position and direction. length float The length of the ray, which determines how far it should extend from the entity. Defaults to 1. collisionFlags CollisionFilterGroupFlags Specifies which collision groups to include in the raycast. Defaults to AllFilter. eFlags EFlags Additional raycasting flags for fine-tuning the behavior. Defaults to None. Returns HitResult A HitResult that contains information about the first object hit by the ray, or an empty result if nothing is hit. Remarks Ensure that you are using the actual rotating entity, as debugging with the wrong entity can lead to unexpected results. RaycastPenetrating(Simulation, RaySegment) Raycasts penetrating any shape the ray encounters. public static List<HitResult> RaycastPenetrating(this Simulation simulation, RaySegment raySegment) Parameters simulation Simulation Physics simulation. raySegment RaySegment Ray. Returns List<HitResult> The list with hit results. Exceptions ArgumentNullException If the simulation argument is null. RaycastPenetrating(Simulation, RaySegment, CollisionFilterGroups, CollisionFilterGroupFlags) Raycasts penetrating any shape the ray encounters. public static List<HitResult> RaycastPenetrating(this Simulation simulation, RaySegment raySegment, CollisionFilterGroups collisionFilterGroups, CollisionFilterGroupFlags collisionFilterGroupFlags) Parameters simulation Simulation Physics simulation. raySegment RaySegment Ray. collisionFilterGroups CollisionFilterGroups The collision group of this shape sweep collisionFilterGroupFlags CollisionFilterGroupFlags The collision group that this shape sweep can collide with Returns List<HitResult> The list with hit results. Exceptions ArgumentNullException If the simulation argument is null. RaycastPenetrating(Simulation, RaySegment, IList<HitResult>) Raycasts penetrating any shape the ray encounters. public static void RaycastPenetrating(this Simulation simulation, RaySegment raySegment, IList<HitResult> resultsOutput) Parameters simulation Simulation Physics simulation. raySegment RaySegment Ray. resultsOutput IList<HitResult> The list to fill with results. Exceptions ArgumentNullException If the simulation argument is null. RaycastPenetrating(Simulation, RaySegment, IList<HitResult>, CollisionFilterGroups, CollisionFilterGroupFlags) Raycasts penetrating any shape the ray encounters. Filtering by CollisionGroup public static void RaycastPenetrating(this Simulation simulation, RaySegment raySegment, IList<HitResult> resultsOutput, CollisionFilterGroups collisionFilterGroups, CollisionFilterGroupFlags collisionFilterGroupFlags) Parameters simulation Simulation Physics simulation. raySegment RaySegment Ray. resultsOutput IList<HitResult> The list to fill with results. collisionFilterGroups CollisionFilterGroups The collision group of this shape sweep collisionFilterGroupFlags CollisionFilterGroupFlags The collision group that this shape sweep can collide with Exceptions ArgumentNullException If the simulation argument is null."
  },
  "api/Stride.CommunityToolkit.Bullet.html": {
    "href": "api/Stride.CommunityToolkit.Bullet.html",
    "title": "Namespace Stride.CommunityToolkit.Bullet | Stride Community Toolkit",
    "summary": "Namespace Stride.CommunityToolkit.Bullet Classes CameraComponentExtensions Provides a set of static methods for working with CameraComponent instances. GameExtensions Provides extension methods for the Game class to simplify common game setup tasks for the Bullet Physics engine. Primitive2DCreationOptions Provides options for creating a 2D primitive entity, such as a square or rectangle. Inherits common entity creation options from PrimitiveCreationOptions and adds specific settings for 2D primitive models. Primitive3DCreationOptions Provides options for creating a primitive entity in a 3D scene. SimulationExtensions Provides extension methods for the Simulation class to perform raycasting operations in a game simulation fro the Bullet physics."
  },
  "api/Stride.CommunityToolkit.Collections.CollectionExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Collections.CollectionExtensions.html",
    "title": "Class CollectionExtensions | Stride Community Toolkit",
    "summary": "Class CollectionExtensions Namespace Stride.CommunityToolkit.Collections Assembly Stride.CommunityToolkit.dll Provides a set of extension methods for common collection types, including ICollection<T>, Queue<T>, and Stack<T>. These methods offer additional functionality for efficiently adding or manipulating multiple elements in bulk. public static class CollectionExtensions Inheritance object CollectionExtensions Remarks These extensions simplify common tasks such as adding multiple elements to collections, queues, and stacks. While built-in methods like Add(T) and Enqueue(T) only handle single elements, these methods support adding multiple elements at once, improving code readability and reducing verbosity. The collection types covered by these extensions include: ICollection<T>: Add multiple elements to collections in bulk. Queue<T>: Enqueue multiple elements at once. Stack<T>: Push multiple elements onto a stack. All methods are null-safe and will throw ArgumentNullException if the target collection or input collection is null. Methods AddRange<T>(ICollection<T?>, IEnumerable<T?>) Adds the elements of the specified collection to the end of the ICollection<T>, allowing for nullable elements. public static void AddRange<T>(this ICollection<T?> destination, IEnumerable<T?> collection) Parameters destination ICollection<T> The ICollection<T> to add items to. Can contain null elements. collection IEnumerable<T> The collection whose elements should be added to the end of the destination. It can contain elements that are null if T is a reference type. Type Parameters T The type of elements in the collection. If T is a reference type, T?? allows nullable elements. Remarks This extension is useful for adding range functionality to collections like HashSet<T> or Queue<T> that do not have AddRange by default. If T is a reference type, T?? explicitly allows null values. Exceptions ArgumentNullException Thrown if destination or collection are null. EnqueueRange<T>(Queue<T?>, IEnumerable<T?>) Enqueues the elements of the specified collection into the Queue<T>. public static void EnqueueRange<T>(this Queue<T?> queue, IEnumerable<T?> collection) Parameters queue Queue<T> The Queue<T> to which items will be added. This collection can accept null elements, if T is a reference type. collection IEnumerable<T> The collection whose elements should be added to the queue. It can contain elements that are null, if T is a reference type. Type Parameters T The type of elements in the collection. Exceptions ArgumentNullException Thrown if either queue or collection is null. PushRange<T>(Stack<T?>, IEnumerable<T?>) Pushes the elements of the specified collection onto the Stack<T>. public static void PushRange<T>(this Stack<T?> stack, IEnumerable<T?> collection) Parameters stack Stack<T> The Stack<T> to which items will be pushed. This stack can accept null elements, if T is a reference type. collection IEnumerable<T> The collection whose elements should be pushed onto the stack. It can contain elements that are null, if T is a reference type. Type Parameters T The type of elements in the collection. Exceptions ArgumentNullException Thrown if either stack or collection is null."
  },
  "api/Stride.CommunityToolkit.Collections.DictionaryExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Collections.DictionaryExtensions.html",
    "title": "Class DictionaryExtensions | Stride Community Toolkit",
    "summary": "Class DictionaryExtensions Namespace Stride.CommunityToolkit.Collections Assembly Stride.CommunityToolkit.dll Extension methods for IDictionary<TKey, TValue>. public static class DictionaryExtensions Inheritance object DictionaryExtensions Methods GetOrAdd<TKey, TValue>(IDictionary<TKey, TValue>, TKey, Func<TKey, TValue>) Gets the element with the specified key or adds it if it is not in the dictionary. public static TValue? GetOrAdd<TKey, TValue>(this IDictionary<TKey, TValue> dictionary, TKey key, Func<TKey, TValue> getValue) Parameters dictionary IDictionary<TKey, TValue> The dictionary to get element from. key TKey The key of the element to get. getValue Func<TKey, TValue> The callback delegate to return value if element with specified key does not exist in the dictionary. Returns TValue The element with the specified key, or the added value. Type Parameters TKey The type of keys in the dictionary. TValue The type of values in the dictionary. Exceptions ArgumentNullException If dictionary or getValue are null. GetOrAdd<TKey, TValue>(IDictionary<TKey, TValue>, TKey, Func<TKey, TValue>, Func<TValue, bool>) Gets the element with the specified key in the dictionary or the new value returned from the getValue callback. If the shouldAdd callback returns true then the new value is added to the dictionary. public static TValue? GetOrAdd<TKey, TValue>(this IDictionary<TKey, TValue> dictionary, TKey key, Func<TKey, TValue> getValue, Func<TValue, bool> shouldAdd) Parameters dictionary IDictionary<TKey, TValue> The dictionary to get element from. key TKey The key of the element to get. getValue Func<TKey, TValue> The callback delegate to return value if element with specified key does not exist in the dictionary. shouldAdd Func<TValue, bool> The callback delegate to determine if the new value should be added to the dictionary. Returns TValue The element with the specified key, or the new value. Type Parameters TKey The type of keys in the dictionary. TValue The type of values in the dictionary. Exceptions ArgumentNullException If dictionary, getValue or shouldAdd are null. GetOrDefault<TKey, TValue>(IDictionary<TKey, TValue>, TKey, TValue?) Gets the element with the specified key or a default value if it is not in the dictionary. public static TValue? GetOrDefault<TKey, TValue>(this IDictionary<TKey, TValue> dictionary, TKey key, TValue? defaultValue = default) Parameters dictionary IDictionary<TKey, TValue> The dictionary to get element from. key TKey The key of the element to get. defaultValue TValue The value to return if element with specified key does not exist in the dictionary. Returns TValue The element with the specified key, or the default value. Type Parameters TKey The type of keys in the dictionary. TValue The type of values in the dictionary. Exceptions ArgumentNullException If dictionary is null. Increment<TKey>(IDictionary<TKey, int>, TKey) Increments integer value in a dictionary by 1. public static int Increment<TKey>(this IDictionary<TKey, int> dictionary, TKey key) Parameters dictionary IDictionary<TKey, int> The dictionary to get element from. key TKey The key of the element to increment and get. Returns int The element incremented by 1 with the specified key. Type Parameters TKey The type of keys in the dictionary. Exceptions ArgumentNullException If dictionary is null. MergeInto<TKey, TValue>(IDictionary<TKey, TValue>, IDictionary<TKey, TValue>) Adds items from one dictionary to the other. public static void MergeInto<TKey, TValue>(this IDictionary<TKey, TValue> source, IDictionary<TKey, TValue> target) Parameters source IDictionary<TKey, TValue> The dictionary items are copied from. target IDictionary<TKey, TValue> The dictionary items are added to. Type Parameters TKey The type of keys in the dictionary. TValue The type of values in the dictionary. Exceptions ArgumentNullException If source or target are null."
  },
  "api/Stride.CommunityToolkit.Collections.EnumerableExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Collections.EnumerableExtensions.html",
    "title": "Class EnumerableExtensions | Stride Community Toolkit",
    "summary": "Class EnumerableExtensions Namespace Stride.CommunityToolkit.Collections Assembly Stride.CommunityToolkit.dll Extension methods for IEnumerable<T>. public static class EnumerableExtensions Inheritance object EnumerableExtensions Methods Concat<T>(IEnumerable<T>, params T[]) Concatenates two sequences. public static IEnumerable<T> Concat<T>(this IEnumerable<T> first, params T[] second) Parameters first IEnumerable<T> The first sequence to concatenate. second T[] The sequence to concatenate to the first sequence. Returns IEnumerable<T> An IEnumerable<T> that contains the concatenated elements of the two input sequences. Type Parameters T The type of the elements of the input sequences. Exceptions ArgumentException first or second is null. ForEach<T>(IEnumerable<T>, Action<T>) Performs the specified action on each element of the IEnumerable<T>. public static void ForEach<T>(this IEnumerable<T> source, Action<T> action) Parameters source IEnumerable<T> The sequence of elements to execute the IEnumerable<T>. action Action<T> The Action<T> delegate to perform on each element of the IEnumerable<T>1. Type Parameters T The type of the elements of the input sequence. Exceptions ArgumentException source or action is null. IsNullOrEmpty<T>(IEnumerable<T>) Checks if enumerable is null or empty. public static bool IsNullOrEmpty<T>(this IEnumerable<T> enumerable) Parameters enumerable IEnumerable<T> The IEnumerable<T> to check. Returns bool Returns true if enumerable is null or empty, otherwise false. Type Parameters T The type of elements in the collection."
  },
  "api/Stride.CommunityToolkit.Collections.ListStackExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Collections.ListStackExtensions.html",
    "title": "Class ListStackExtensions | Stride Community Toolkit",
    "summary": "Class ListStackExtensions Namespace Stride.CommunityToolkit.Collections Assembly Stride.CommunityToolkit.dll Extension methods to use stack like methods for IList<T>. public static class ListStackExtensions Inheritance object ListStackExtensions Methods Peek<T>(IList<T>) Gets the last item in the IList<T>. public static T Peek<T>(this IList<T> stack) Parameters stack IList<T> The IList<T> to use as a stack. Returns T The last item in the collection. Type Parameters T The type of elements in the collection. Exceptions ArgumentNullException If stack is null. ArgumentException If stack is empty. PopFront<T>(IList<T>) Removes and returns the object at the start of the IList<T>. public static T PopFront<T>(this IList<T> stack) Parameters stack IList<T> The IList<T> to use as a stack. Returns T The object removed from the start of the IList<T>. Type Parameters T The type of elements in the collection. Exceptions ArgumentNullException If stack is null. ArgumentException If stack is empty. Pop<T>(IList<T>) Removes and returns the object at the end of the IList<T>. public static T Pop<T>(this IList<T> stack) Parameters stack IList<T> The IList<T> to use as a stack. Returns T The object removed from the end of the IList<T>. Type Parameters T The type of elements in the collection. Exceptions ArgumentNullException If stack is null. ArgumentException If stack is empty. Push<T>(IList<T>, T) Adds an object to the end of the IList<T>. public static void Push<T>(this IList<T> stack, T item) Parameters stack IList<T> The IList<T> to use as a stack. item T The item to push on to the stack. The value can be null for reference types. Type Parameters T The type of elements in the collection. Exceptions ArgumentNullException If stack is null."
  },
  "api/Stride.CommunityToolkit.Collections.RandomListExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Collections.RandomListExtensions.html",
    "title": "Class RandomListExtensions | Stride Community Toolkit",
    "summary": "Class RandomListExtensions Namespace Stride.CommunityToolkit.Collections Assembly Stride.CommunityToolkit.dll Provides extension methods for the Random class to facilitate random selection and shuffling of collections. public static class RandomListExtensions Inheritance object RandomListExtensions Remarks These extensions add functionality for randomly selecting an element from a collection or array, and for shuffling elements in place. Useful for games, simulations, or any scenario requiring random operations on lists or arrays. Methods Choose<T>(Random, IList<T>) Selects a random item from a given collection. public static T Choose<T>(this Random random, IList<T> collection) Parameters random Random An instance of Random used to generate the random selection. collection IList<T> The collection to choose an item from. Returns T A randomly chosen item from the collection. Type Parameters T The type of elements in the collection. Exceptions ArgumentNullException Thrown if random or collection is null. ArgumentOutOfRangeException Thrown if collection is empty. Choose<T>(Random, params T[]) Selects a random item from a given array. public static T Choose<T>(this Random random, params T[] collection) Parameters random Random An instance of Random used to generate the random selection. collection T[] The array to choose an item from. Returns T A randomly chosen item from the collection. Type Parameters T The type of elements in the array. Exceptions ArgumentNullException Thrown if random or collection is null. ArgumentOutOfRangeException Thrown if collection is empty. Shuffle<T>(Random, IList<T>) Shuffles the elements of the specified collection in place using the Fisher-Yates shuffle algorithm. public static void Shuffle<T>(this Random random, IList<T> collection) Parameters random Random An instance of Random used to generate random indices for shuffling. collection IList<T> The collection to shuffle. Type Parameters T The type of elements in the collection. Exceptions ArgumentNullException Thrown if random or collection is null."
  },
  "api/Stride.CommunityToolkit.Collections.html": {
    "href": "api/Stride.CommunityToolkit.Collections.html",
    "title": "Namespace Stride.CommunityToolkit.Collections | Stride Community Toolkit",
    "summary": "Namespace Stride.CommunityToolkit.Collections Classes CollectionExtensions Provides a set of extension methods for common collection types, including ICollection<T>, Queue<T>, and Stack<T>. These methods offer additional functionality for efficiently adding or manipulating multiple elements in bulk. DictionaryExtensions Extension methods for IDictionary<TKey, TValue>. EnumerableExtensions Extension methods for IEnumerable<T>. ListStackExtensions Extension methods to use stack like methods for IList<T>. RandomListExtensions Provides extension methods for the Random class to facilitate random selection and shuffling of collections."
  },
  "api/Stride.CommunityToolkit.DebugShapes.Code.DebugShapeExtensions.html": {
    "href": "api/Stride.CommunityToolkit.DebugShapes.Code.DebugShapeExtensions.html",
    "title": "Class DebugShapeExtensions | Stride Community Toolkit",
    "summary": "Class DebugShapeExtensions Namespace Stride.CommunityToolkit.DebugShapes.Code Assembly Stride.CommunityToolkit.DebugShapes.dll public static class DebugShapeExtensions Inheritance object DebugShapeExtensions Methods AddDebugShapes(Game, RenderGroup) Adds ImmediateDebugRenderFeature and ImmediateDebugRenderSystem to the game. Registers the system to the service registry for easy access. public static void AddDebugShapes(this Game game, RenderGroup debugShapeRenderGroup = RenderGroup.Group1) Parameters game Game debugShapeRenderGroup RenderGroup AddImmediateDebugRenderFeature(GraphicsCompositor) Adds an immediate debug render feature to the specified GraphicsCompositor. This method ensures the debug render feature is added only once and links it with both the \"Opaque\" and \"Transparent\" render stages. public static void AddImmediateDebugRenderFeature(this GraphicsCompositor graphicsCompositor) Parameters graphicsCompositor GraphicsCompositor The GraphicsCompositor to modify. Exceptions NullReferenceException Thrown when the \"Opaque\" or \"Transparent\" render stages are not found in the graphicsCompositor. TryGetRenderStage(GraphicsCompositor, string, out RenderStage?) Attempts to retrieve a render stage from the specified GraphicsCompositor based on the provided effect name. public static bool TryGetRenderStage(this GraphicsCompositor graphicsCompositor, string effectName, out RenderStage? renderStage) Parameters graphicsCompositor GraphicsCompositor The GraphicsCompositor containing the render stages. effectName string The name of the render stage to search for. renderStage RenderStage When this method returns, contains the RenderStage if the render stage was found; otherwise, null. This parameter is passed uninitialized. Returns bool true if the render stage is found; otherwise, false."
  },
  "api/Stride.CommunityToolkit.DebugShapes.Code.ImmediateDebugPrimitives.html": {
    "href": "api/Stride.CommunityToolkit.DebugShapes.Code.ImmediateDebugPrimitives.html",
    "title": "Class ImmediateDebugPrimitives | Stride Community Toolkit",
    "summary": "Class ImmediateDebugPrimitives Namespace Stride.CommunityToolkit.DebugShapes.Code Assembly Stride.CommunityToolkit.DebugShapes.dll public static class ImmediateDebugPrimitives Inheritance object ImmediateDebugPrimitives Methods CopyFromGeometricPrimitive(GeometricMeshData<VertexPositionNormalTexture>, ref VertexPositionTexture[], ref int[]) public static void CopyFromGeometricPrimitive(GeometricMeshData<VertexPositionNormalTexture> primitiveData, ref VertexPositionTexture[] vertices, ref int[] indices) Parameters primitiveData GeometricMeshData<VertexPositionNormalTexture> vertices VertexPositionTexture[] indices int[] GenerateCapsule(float, float, int, int) public static (VertexPositionTexture[] Vertices, int[] Indices) GenerateCapsule(float length, float radius, int tesselation, int uvSplits = 4) Parameters length float radius float tesselation int uvSplits int Returns (VertexPositionTexture[] Vertices, int[] Indices) GenerateCircle(float, int, int, float, bool, int) public static (VertexPositionTexture[] Vertices, int[] Indices) GenerateCircle(float radius = 0.5, int tesselations = 16, int uvSplits = 0, float yOffset = 0, bool isFlipped = false, int uvOffset = 0) Parameters radius float tesselations int uvSplits int yOffset float isFlipped bool uvOffset int Returns (VertexPositionTexture[] Vertices, int[] Indices) GenerateCone(float, float, int, int, int) public static (VertexPositionTexture[] Vertices, int[] Indices) GenerateCone(float height, float radius, int tesselations, int uvSplits = 4, int uvSplitsBottom = 0) Parameters height float radius float tesselations int uvSplits int uvSplitsBottom int Returns (VertexPositionTexture[] Vertices, int[] Indices) GenerateCube(float) public static (VertexPositionTexture[] Vertices, int[] Indices) GenerateCube(float size = 1) Parameters size float Returns (VertexPositionTexture[] Vertices, int[] Indices) GenerateCylinder(float, float, int, int, int?) public static (VertexPositionTexture[] Vertices, int[] Indices) GenerateCylinder(float height = 1, float radius = 0.5, int tesselations = 16, int uvSplits = 4, int? uvSidesForCircle = null) Parameters height float radius float tesselations int uvSplits int uvSidesForCircle int? Returns (VertexPositionTexture[] Vertices, int[] Indices) GenerateQuad(float, float) public static (VertexPositionTexture[] Vertices, int[] Indices) GenerateQuad(float width, float height) Parameters width float height float Returns (VertexPositionTexture[] Vertices, int[] Indices) GenerateSphere(float, int, int, int) public static (VertexPositionTexture[] Vertices, int[] Indices) GenerateSphere(float radius = 0.5, int tesselations = 16, int uvSplits = 4, int uvSplitOffsetVertical = 0) Parameters radius float tesselations int uvSplits int uvSplitOffsetVertical int Returns (VertexPositionTexture[] Vertices, int[] Indices) GetCircleVector(int, int) public static Vector3 GetCircleVector(int i, int tessellation) Parameters i int tessellation int Returns Vector3"
  },
  "api/Stride.CommunityToolkit.DebugShapes.Code.ImmediateDebugRenderFeature.html": {
    "href": "api/Stride.CommunityToolkit.DebugShapes.Code.ImmediateDebugRenderFeature.html",
    "title": "Class ImmediateDebugRenderFeature | Stride Community Toolkit",
    "summary": "Class ImmediateDebugRenderFeature Namespace Stride.CommunityToolkit.DebugShapes.Code Assembly Stride.CommunityToolkit.DebugShapes.dll public class ImmediateDebugRenderFeature : RootRenderFeature, IComponent, IReferencable, ICollectorHolder, IGraphicsRendererCore, IDisposable Inheritance object DisposeBase ComponentBase RenderFeature RootRenderFeature ImmediateDebugRenderFeature Implements IComponent IReferencable ICollectorHolder IGraphicsRendererCore IDisposable Inherited Members RootRenderFeature.RenderData RootRenderFeature.RenderObjects RootRenderFeature.GetRenderNode(RenderNodeReference) RootRenderFeature.GetViewObjectNode(ViewObjectNodeReference) RootRenderFeature.GetObjectNode(ObjectNodeReference) RootRenderFeature.CreateViewObjectNode(RenderView, RenderObject) RootRenderFeature.OnAddRenderObject(RenderObject) RootRenderFeature.OnRemoveRenderObject(RenderObject) RootRenderFeature.Reset() RootRenderFeature.PrepareDataArrays() RootRenderFeature.ComputeDataArrayExpectedSize(DataType) RootRenderFeature.BindPerViewShaderResource(string, RenderView, GraphicsResource) RootRenderFeature.Index RootRenderFeature.SortKey RootRenderFeature.ObjectNodeReferences RootRenderFeature.RenderNodes RootRenderFeature.RenderStageSelectors RenderFeature.Initialize(RenderContext) RenderFeature.Destroy() RenderFeature.Collect() RenderFeature.PrepareEffectPermutations(RenderDrawContext) RenderFeature.Draw(RenderDrawContext, RenderView, RenderViewStage) RenderFeature.OnRenderSystemChanged() RenderFeature.Context RenderFeature.RenderSystem RenderFeature.Initialized RenderFeature.Enabled ComponentBase.Tags ComponentBase.OnNameChanged() ComponentBase.ToString() ComponentBase.Name DisposeBase.Dispose() DisposeBase.OnAddReference() DisposeBase.OnReleaseReference() DisposeBase.IsDisposed Constructors ImmediateDebugRenderFeature() public ImmediateDebugRenderFeature() Properties SupportedRenderObjectType Gets the type of render object supported by this RootRenderFeature. public override Type SupportedRenderObjectType { get; } Property Value Type Methods Draw(RenderDrawContext, RenderView, RenderViewStage, int, int) Performs GPU updates and/or draw. public override void Draw(RenderDrawContext context, RenderView renderView, RenderViewStage renderViewStage, int startIndex, int endIndex) Parameters context RenderDrawContext renderView RenderView renderViewStage RenderViewStage startIndex int endIndex int Extract() Extract data from entities, should be as fast as possible to not block simulation loop. It should be mostly copies, and the actual processing should be part of Prepare(). public override void Extract() Flush(RenderDrawContext) Releases temporary resources and cleans the state. Should be called once after all Draw(RenderDrawContext, RenderView, RenderViewStage) calls have finished. public override void Flush(RenderDrawContext context) Parameters context RenderDrawContext InitializeCore() Initializes this instance. Query for specific cbuffer (either new one, like PerMaterial, or parts of an existing one, like PerObject=>Skinning) protected override void InitializeCore() Prepare(RenderDrawContext) Performs most of the work (computation and resource preparation). Later game simulation might be running during that step. public override void Prepare(RenderDrawContext context) Parameters context RenderDrawContext Unload() public override void Unload()"
  },
  "api/Stride.CommunityToolkit.DebugShapes.Code.ImmediateDebugRenderObject.html": {
    "href": "api/Stride.CommunityToolkit.DebugShapes.Code.ImmediateDebugRenderObject.html",
    "title": "Class ImmediateDebugRenderObject | Stride Community Toolkit",
    "summary": "Class ImmediateDebugRenderObject Namespace Stride.CommunityToolkit.DebugShapes.Code Assembly Stride.CommunityToolkit.DebugShapes.dll public class ImmediateDebugRenderObject : RenderObject Inheritance object RenderObject ImmediateDebugRenderObject Inherited Members RenderObject.Enabled RenderObject.RenderGroup RenderObject.BoundingBox RenderObject.RenderFeature RenderObject.ObjectNode RenderObject.StaticObjectNode RenderObject.VisibilityObjectNode RenderObject.ActiveRenderStages RenderObject.StateSortKey RenderObject.Index RenderObject.Source Methods DrawCapsule(ref Vector3, float, float, ref Quaternion, ref Color, bool) public void DrawCapsule(ref Vector3 position, float height, float radius, ref Quaternion rotation, ref Color color, bool depthTest = true) Parameters position Vector3 height float radius float rotation Quaternion color Color depthTest bool DrawCircle(ref Vector3, float, ref Quaternion, ref Color, bool) public void DrawCircle(ref Vector3 position, float radius, ref Quaternion rotation, ref Color color, bool depthTest = true) Parameters position Vector3 radius float rotation Quaternion color Color depthTest bool DrawCone(ref Vector3, float, float, ref Quaternion, ref Color, bool) public void DrawCone(ref Vector3 position, float height, float radius, ref Quaternion rotation, ref Color color, bool depthTest = true) Parameters position Vector3 height float radius float rotation Quaternion color Color depthTest bool DrawCube(ref Vector3, ref Vector3, ref Quaternion, ref Color, bool) public void DrawCube(ref Vector3 start, ref Vector3 end, ref Quaternion rotation, ref Color color, bool depthTest = true) Parameters start Vector3 end Vector3 rotation Quaternion color Color depthTest bool DrawCylinder(ref Vector3, float, float, ref Quaternion, ref Color, bool) public void DrawCylinder(ref Vector3 position, float height, float radius, ref Quaternion rotation, ref Color color, bool depthTest = true) Parameters position Vector3 height float radius float rotation Quaternion color Color depthTest bool DrawHalfSphere(ref Vector3, float, ref Quaternion, ref Color, bool) public void DrawHalfSphere(ref Vector3 position, float radius, ref Quaternion rotation, ref Color color, bool depthTest = true) Parameters position Vector3 radius float rotation Quaternion color Color depthTest bool DrawLine(ref Vector3, ref Vector3, ref Color, bool) public void DrawLine(ref Vector3 start, ref Vector3 end, ref Color color, bool depthTest = true) Parameters start Vector3 end Vector3 color Color depthTest bool DrawQuad(ref Vector3, ref Vector2, ref Quaternion, ref Color, bool) public void DrawQuad(ref Vector3 position, ref Vector2 size, ref Quaternion rotation, ref Color color, bool depthTest = true) Parameters position Vector3 size Vector2 rotation Quaternion color Color depthTest bool DrawSphere(ref Vector3, float, ref Color, bool) public void DrawSphere(ref Vector3 position, float radius, ref Color color, bool depthTest = true) Parameters position Vector3 radius float color Color depthTest bool"
  },
  "api/Stride.CommunityToolkit.DebugShapes.Code.ImmediateDebugRenderStageSelector.html": {
    "href": "api/Stride.CommunityToolkit.DebugShapes.Code.ImmediateDebugRenderStageSelector.html",
    "title": "Class ImmediateDebugRenderStageSelector | Stride Community Toolkit",
    "summary": "Class ImmediateDebugRenderStageSelector Namespace Stride.CommunityToolkit.DebugShapes.Code Assembly Stride.CommunityToolkit.DebugShapes.dll public class ImmediateDebugRenderStageSelector : RenderStageSelector Inheritance object RenderStageSelector ImmediateDebugRenderStageSelector Properties OpaqueRenderStage public RenderStage? OpaqueRenderStage { get; set; } Property Value RenderStage RenderGroup public RenderGroupMask RenderGroup { get; set; } Property Value RenderGroupMask TransparentRenderStage public RenderStage? TransparentRenderStage { get; set; } Property Value RenderStage Methods Process(RenderObject) public override void Process(RenderObject renderObject) Parameters renderObject RenderObject"
  },
  "api/Stride.CommunityToolkit.DebugShapes.Code.ImmediateDebugRenderSystem.html": {
    "href": "api/Stride.CommunityToolkit.DebugShapes.Code.ImmediateDebugRenderSystem.html",
    "title": "Class ImmediateDebugRenderSystem | Stride Community Toolkit",
    "summary": "Class ImmediateDebugRenderSystem Namespace Stride.CommunityToolkit.DebugShapes.Code Assembly Stride.CommunityToolkit.DebugShapes.dll public class ImmediateDebugRenderSystem : GameSystemBase, IDisposable, ICollectorHolder, IGameSystemBase, IComponent, IReferencable, IUpdateable, IDrawable, IContentable Inheritance object DisposeBase ComponentBase GameSystemBase ImmediateDebugRenderSystem Implements IDisposable ICollectorHolder IGameSystemBase IComponent IReferencable IUpdateable IDrawable IContentable Inherited Members GameSystemBase.BeginDraw() GameSystemBase.Draw(GameTime) GameSystemBase.EndDraw() GameSystemBase.Initialize() GameSystemBase.InitGraphicsDeviceService() GameSystemBase.OnDrawOrderChanged(object, EventArgs) GameSystemBase.OnUpdateOrderChanged(object, EventArgs) GameSystemBase.LoadContent() GameSystemBase.UnloadContent() GameSystemBase.Game GameSystemBase.Services GameSystemBase.Content GameSystemBase.GraphicsDevice GameSystemBase.Visible GameSystemBase.DrawOrder GameSystemBase.Enabled GameSystemBase.UpdateOrder GameSystemBase.DrawOrderChanged GameSystemBase.VisibleChanged GameSystemBase.EnabledChanged GameSystemBase.UpdateOrderChanged ComponentBase.Tags ComponentBase.Destroy() ComponentBase.OnNameChanged() ComponentBase.ToString() ComponentBase.Name DisposeBase.Dispose() DisposeBase.OnAddReference() DisposeBase.OnReleaseReference() DisposeBase.IsDisposed Constructors ImmediateDebugRenderSystem(IServiceRegistry, RenderGroup) public ImmediateDebugRenderSystem(IServiceRegistry registry, RenderGroup renderGroup = RenderGroup.Group31) Parameters registry IServiceRegistry renderGroup RenderGroup Properties MaxPrimitives public int MaxPrimitives { get; set; } Property Value int MaxPrimitivesWithLifetime public int MaxPrimitivesWithLifetime { get; set; } Property Value int PrimitiveColor public Color PrimitiveColor { get; set; } Property Value Color RenderGroup public RenderGroup RenderGroup { get; set; } Property Value RenderGroup Methods DrawArrow(Vector3, Vector3, float, float, Color, float, bool, bool) public void DrawArrow(Vector3 from, Vector3 to, float coneHeight = 0.25, float coneRadius = 0.125, Color color = default, float duration = 0, bool depthTest = true, bool solid = false) Parameters from Vector3 to Vector3 coneHeight float coneRadius float color Color duration float depthTest bool solid bool DrawBounds(Vector3, Vector3, Quaternion, Color, float, bool, bool) public void DrawBounds(Vector3 start, Vector3 end, Quaternion rotation = default, Color color = default, float duration = 0, bool depthTest = true, bool solid = false) Parameters start Vector3 end Vector3 rotation Quaternion color Color duration float depthTest bool solid bool DrawCapsule(Vector3, float, float, Quaternion, Color, float, bool, bool) public void DrawCapsule(Vector3 position, float height, float radius, Quaternion rotation = default, Color color = default, float duration = 0, bool depthTest = true, bool solid = false) Parameters position Vector3 height float radius float rotation Quaternion color Color duration float depthTest bool solid bool DrawCircle(Vector3, float, Quaternion, Color, float, bool, bool) public void DrawCircle(Vector3 position, float radius, Quaternion rotation = default, Color color = default, float duration = 0, bool depthTest = true, bool solid = false) Parameters position Vector3 radius float rotation Quaternion color Color duration float depthTest bool solid bool DrawCone(Vector3, float, float, Quaternion, Color, float, bool, bool) public void DrawCone(Vector3 position, float height, float radius, Quaternion rotation = default, Color color = default, float duration = 0, bool depthTest = true, bool solid = false) Parameters position Vector3 height float radius float rotation Quaternion color Color duration float depthTest bool solid bool DrawCube(Vector3, Vector3, Quaternion, Color, float, bool, bool) public void DrawCube(Vector3 start, Vector3 size, Quaternion rotation = default, Color color = default, float duration = 0, bool depthTest = true, bool solid = false) Parameters start Vector3 size Vector3 rotation Quaternion color Color duration float depthTest bool solid bool DrawCylinder(Vector3, float, float, Quaternion, Color, float, bool, bool) public void DrawCylinder(Vector3 position, float height, float radius, Quaternion rotation = default, Color color = default, float duration = 0, bool depthTest = true, bool solid = false) Parameters position Vector3 height float radius float rotation Quaternion color Color duration float depthTest bool solid bool DrawHalfSphere(Vector3, float, Color, Quaternion, float, bool, bool) public void DrawHalfSphere(Vector3 position, float radius, Color color = default, Quaternion rotation = default, float duration = 0, bool depthTest = true, bool solid = false) Parameters position Vector3 radius float color Color rotation Quaternion duration float depthTest bool solid bool DrawLine(Vector3, Vector3, Color, float, bool) public void DrawLine(Vector3 start, Vector3 end, Color color = default, float duration = 0, bool depthTest = true) Parameters start Vector3 end Vector3 color Color duration float depthTest bool DrawLines(Vector3[], Color?, float, bool) public void DrawLines(Vector3[] vertices, Color? color = null, float duration = 0, bool depthTest = true) Parameters vertices Vector3[] color Color? duration float depthTest bool DrawQuad(Vector3, Vector2, Quaternion, Color, float, bool, bool) public void DrawQuad(Vector3 position, Vector2 size, Quaternion rotation = default, Color color = default, float duration = 0, bool depthTest = true, bool solid = false) Parameters position Vector3 size Vector2 rotation Quaternion color Color duration float depthTest bool solid bool DrawRay(Vector3, Vector3, Color, float, bool) public void DrawRay(Vector3 start, Vector3 dir, Color color = default, float duration = 0, bool depthTest = true) Parameters start Vector3 dir Vector3 color Color duration float depthTest bool DrawSphere(Vector3, float, Color, float, bool, bool) public void DrawSphere(Vector3 position, float radius, Color color = default, float duration = 0, bool depthTest = true, bool solid = false) Parameters position Vector3 radius float color Color duration float depthTest bool solid bool Update(GameTime) This method is called when this game component is updated. public override void Update(GameTime gameTime) Parameters gameTime GameTime The current timing."
  },
  "api/Stride.CommunityToolkit.DebugShapes.Code.html": {
    "href": "api/Stride.CommunityToolkit.DebugShapes.Code.html",
    "title": "Namespace Stride.CommunityToolkit.DebugShapes.Code | Stride Community Toolkit",
    "summary": "Namespace Stride.CommunityToolkit.DebugShapes.Code Classes DebugShapeExtensions ImmediateDebugPrimitives ImmediateDebugRenderFeature ImmediateDebugRenderObject ImmediateDebugRenderStageSelector ImmediateDebugRenderSystem"
  },
  "api/Stride.CommunityToolkit.Engine.AnimationComponentExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Engine.AnimationComponentExtensions.html",
    "title": "Class AnimationComponentExtensions | Stride Community Toolkit",
    "summary": "Class AnimationComponentExtensions Namespace Stride.CommunityToolkit.Engine Assembly Stride.CommunityToolkit.dll Provides extension methods for the AnimationComponent to enhance animation playback functionality. public static class AnimationComponentExtensions Inheritance object AnimationComponentExtensions Remarks These extensions simplify the process of controlling animations, such as checking if an animation is already playing before starting it. Methods PlayAnimation(AnimationComponent, string) Plays the specified animation on the animation component if it is not already playing. public static void PlayAnimation(this AnimationComponent animationComponent, string name) Parameters animationComponent AnimationComponent The AnimationComponent on which to play the animation. name string The name of the animation to be played. Remarks This method first checks if the animation with the given name is already playing. If it is not, the animation will be started. This approach prevents restarting an animation that is currently running, allowing for smooth transitions between animations."
  },
  "api/Stride.CommunityToolkit.Engine.CameraComponentExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Engine.CameraComponentExtensions.html",
    "title": "Class CameraComponentExtensions | Stride Community Toolkit",
    "summary": "Class CameraComponentExtensions Namespace Stride.CommunityToolkit.Engine Assembly Stride.CommunityToolkit.dll Provides a set of static methods for working with CameraComponent instances. public static class CameraComponentExtensions Inheritance object CameraComponentExtensions Remarks This class includes extension methods for performing various operations with CameraComponent instances, such as raycasting, converting screen positions to world positions, and more. These methods are useful for implementing features like object picking, camera control, and coordinate transformations in a 3D environment. Methods CalculateRayFromScreenPosition(CameraComponent, Vector2) Calculates a ray from the camera's position through a specified point on the screen, projecting from screen space into the 3D world space. public static (Vector3 nearPoint, Vector3 farPoint) CalculateRayFromScreenPosition(this CameraComponent camera, Vector2 screenPosition) Parameters camera CameraComponent The CameraComponent used to generate the view and projection matrices for the calculation. screenPosition Vector2 The normalized position on the screen (typically the mouse position), with coordinates ranging from (0,0) at the bottom-left to (1,1) at the top-right. Returns (Vector3 nearPoint, Vector3 farPoint) A tuple containing two points: nearPoint, which is the world-space position on the near plane, and farPoint, which is the world-space position on the far plane. These two points define the ray from the camera into the 3D world through the specified screen position. Remarks This method is typically used for raycasting and object picking in 3D space, where you need to determine what objects lie under a particular screen-space position, such as the mouse cursor. The ray is defined by transforming the screen position into world space, calculating points on the near and far planes of the camera's view frustum. GetPickRay(CameraComponent, Vector2) Calculates a ray from the camera through a specified point on the screen, projecting into the 3D world space. public static Ray GetPickRay(this CameraComponent camera, Vector2 screenPosition) Parameters camera CameraComponent The CameraComponent used for the ray calculation. screenPosition Vector2 The position on the screen, typically the mouse position, normalized between (0,0) (bottom-left) and (1,1) (top-right). Returns Ray A Ray starting from the camera and pointing into the 3D world through the specified screen position. Remarks This method is commonly used for object picking or raycasting operations, where interaction with 3D objects is based on screen space coordinates (e.g., mouse cursor). The ray is calculated by transforming the screen position into world space, creating a direction vector from the camera's near plane to its far plane. LogicDirectionToWorldDirection(CameraComponent, Vector2) Converts a 2D logical direction into a 3D world direction relative to the camera's orientation. public static Vector3 LogicDirectionToWorldDirection(this CameraComponent camera, Vector2 logicDirection) Parameters camera CameraComponent The camera component used for the calculation. logicDirection Vector2 The 2D logical direction (e.g., input from a joystick or keyboard), typically normalized between -1 and 1. Returns Vector3 The corresponding 3D world direction vector. Remarks This method is useful for converting 2D input commands into 3D movements in the world, taking into account the camera's current orientation. LogicDirectionToWorldDirection(CameraComponent, Vector2, Vector3) Converts a 2D logical direction into a 3D world direction relative to the camera's orientation, using a specified up vector. public static Vector3 LogicDirectionToWorldDirection(this CameraComponent camera, Vector2 logicDirection, Vector3 upVector) Parameters camera CameraComponent The camera component used for the calculation. logicDirection Vector2 The 2D logical direction (e.g., input from a joystick or keyboard), typically normalized between -1 and 1. upVector Vector3 The up vector to be used for the calculation, defining the vertical direction in world space. Returns Vector3 The corresponding 3D world direction vector. Remarks This method is useful for converting 2D input commands into 3D movements in the world, taking into account the camera's current orientation and a custom vertical orientation. ScreenPointToRay(CameraComponent, Vector2) Calculates the near and far vectors for a ray that starts at the camera and passes through a given screen point. The ray is in world space, starting at the near plane of the camera and extending through the specified pixel coordinates on the screen. public static (Vector4 VectorNear, Vector4 VectorFar) ScreenPointToRay(this CameraComponent camera, Vector2 screenPosition) Parameters camera CameraComponent The camera component used to calculate the ray. screenPosition Vector2 The screen position (in normalized coordinates) through which the ray passes. Returns (Vector4 VectorNear, Vector4 VectorFar) A tuple containing the near vector (VectorNear) and the far vector (VectorFar) of the ray in world space. ScreenToWorldPoint(CameraComponent, Vector3) Converts the screen position to a point in world coordinates relative to cameraComponent. public static Vector3 ScreenToWorldPoint(this CameraComponent cameraComponent, Vector3 position) Parameters cameraComponent CameraComponent The camera component used to perform the calculation. position Vector3 The screen position in normalized X, Y coordinates. Top-left is (0,0), bottom-right is (1,1). Z is in world units from the near camera plane. Passed by value, which may be simpler to use but less efficient in memory-constrained environments. Returns Vector3 The world position calculated from the screen position. Remarks This method does not update the ViewMatrix or ProjectionMatrix before performing the transformation. If the CameraComponent or its containing Entity TransformComponent has been modified since the last frame, you may need to call the Update() method first. This method takes the position parameter by value, which is simpler to use but may involve a copy of the vector, which could be less efficient for large or frequent transformations. Exceptions ArgumentNullException Thrown if cameraComponent is null. ScreenToWorldPoint(CameraComponent, ref Vector3) Converts the screen position to a point in world coordinates relative to cameraComponent. public static Vector3 ScreenToWorldPoint(this CameraComponent cameraComponent, ref Vector3 position) Parameters cameraComponent CameraComponent The camera component used to perform the calculation. position Vector3 The screen position in normalized X, Y coordinates. Top-left is (0,0), bottom-right is (1,1). Z is in world units from the near camera plane. Passed by reference, allowing for potential optimizations in memory usage. Returns Vector3 The world position calculated from the screen position. Remarks This method does not update the ViewMatrix or ProjectionMatrix before performing the transformation. If the CameraComponent or its containing Entity TransformComponent has been modified since the last frame, you may need to call the Update() method first. This method takes the position parameter by reference (ref), which may optimize memory usage and prevent unnecessary copies of the vector. Exceptions ArgumentNullException Thrown if cameraComponent is null. ScreenToWorldPoint(CameraComponent, ref Vector3, out Vector3) Converts the screen position to a point in world coordinates. public static void ScreenToWorldPoint(this CameraComponent cameraComponent, ref Vector3 position, out Vector3 result) Parameters cameraComponent CameraComponent position Vector3 The screen position in normalized X, Y coordinates. Top-left is (0,0), bottom-right is (1,1). Z is in world units from near camera plane. result Vector3 Position in world coordinates. Remarks This method does not update the ViewMatrix or ProjectionMatrix before performing the transformation. If the CameraComponent or it's containing Entity TransformComponenthas been modified since the last frame you may need to call the Update() method first. Exceptions ArgumentNullException If the cameraComponent argument is null. ScreenToWorldRaySegment(CameraComponent, Vector2) Converts the screen position to a RaySegment in world coordinates. public static RaySegment ScreenToWorldRaySegment(this CameraComponent cameraComponent, Vector2 position) Parameters cameraComponent CameraComponent position Vector2 Returns RaySegment RaySegment, starting at near plain and ending at the far plain. Remarks This method does not update the ViewMatrix or ProjectionMatrix before performing the transformation. If the CameraComponent or it's containing Entity TransformComponenthas been modified since the last frame you may need to call the Update() method first. Exceptions ArgumentNullException If the cameraComponent argument is null. ScreenToWorldRaySegment(CameraComponent, ref Vector2, out RaySegment) Converts the screen position to a RaySegment in world coordinates. public static void ScreenToWorldRaySegment(this CameraComponent cameraComponent, ref Vector2 position, out RaySegment result) Parameters cameraComponent CameraComponent position Vector2 result RaySegment RaySegment, starting at near plain and ending at the far plain. Remarks This method does not update the ViewMatrix or ProjectionMatrix before performing the transformation. If the CameraComponent or it's containing Entity TransformComponenthas been modified since the last frame you may need to call the Update() method first. WorldToClip(CameraComponent, ref Vector3) Transforms a world-space position to clip space coordinates relative to camera, using the camera's view-projection matrix. The result is returned as a Vector3. public static Vector3 WorldToClip(this CameraComponent cameraComponent, ref Vector3 position) Parameters cameraComponent CameraComponent The camera component whose view-projection matrix will be used. position Vector3 The world-space position to be transformed. Returns Vector3 The position in clip space as a Vector3. Remarks This method does not update the ViewMatrix or ProjectionMatrix before performing the transformation. If the CameraComponent or it's containing Entity TransformComponenthas been modified since the last frame you may need to call the Update() method first. Exceptions ArgumentNullException Thrown if cameraComponent is null. WorldToClip(CameraComponent, ref Vector3, out Vector3) Transforms a world-space position to clip space coordinates relative to camera, using the camera's view-projection matrix. The result is returned via the result parameter. public static void WorldToClip(this CameraComponent cameraComponent, ref Vector3 position, out Vector3 result) Parameters cameraComponent CameraComponent The camera component whose view-projection matrix will be used. position Vector3 The world-space position to be transformed. result Vector3 The resulting position in clip space. Remarks This method does not update the ViewMatrix or ProjectionMatrix before performing the transformation. If the CameraComponent or it's containing Entity TransformComponenthas been modified since the last frame you may need to call the Update() method first. Exceptions ArgumentNullException Thrown if cameraComponent is null. WorldToScreenPoint(CameraComponent, Vector3) Converts the world position to screen space coordinates relative to cameraComponent. public static Vector3 WorldToScreenPoint(this CameraComponent cameraComponent, Vector3 position) Parameters cameraComponent CameraComponent The camera component used to perform the calculation. position Vector3 The world space position to be converted to screen space. Passed by value, which may be simpler to use but less efficient in memory-constrained environments. Returns Vector3 The screen position in normalized X, Y coordinates. Top-left is (0,0), bottom-right is (1,1). Z is in world units from near camera plane. Remarks This method does not update the ViewMatrix or ProjectionMatrix before performing the transformation. If the CameraComponent or its containing Entity TransformComponent has been modified since the last frame, you may need to call the Update() method first. This method takes the position parameter by value, which is simpler to use but may involve a copy of the vector, which could be less efficient for large or frequent transformations. Exceptions ArgumentNullException Thrown if cameraComponent is null. WorldToScreenPoint(CameraComponent, ref Vector3) Converts the world position to screen space coordinates relative to cameraComponent. public static Vector3 WorldToScreenPoint(this CameraComponent cameraComponent, ref Vector3 position) Parameters cameraComponent CameraComponent The camera component used to perform the calculation. position Vector3 The world space position to be converted to screen space. Passed by reference, allowing for potential optimizations in memory usage. Returns Vector3 The screen position in normalized X, Y coordinates. Top-left is (0,0), bottom-right is (1,1). Z is in world units from near camera plane. Remarks This method does not update the ViewMatrix or ProjectionMatrix before performing the transformation. If the CameraComponent or its containing Entity TransformComponent has been modified since the last frame, you may need to call the Update() method first. This method takes the position parameter by reference (ref), which may optimize memory usage and prevent unnecessary copies of the vector. Exceptions ArgumentNullException Thrown if cameraComponent is null. WorldToScreenPoint(CameraComponent, ref Vector3, out Vector3) Converts the world position to screen space coordinates relative to camera. public static void WorldToScreenPoint(this CameraComponent cameraComponent, ref Vector3 position, out Vector3 result) Parameters cameraComponent CameraComponent The camera component used to perform the calculation. position Vector3 The world space position to be converted to screen space. result Vector3 The screen position in normalized X, Y coordinates. Top-left is (0,0), bottom-right is (1,1). Z is in world units from near camera plane. Remarks This method does not update the ViewMatrix or ProjectionMatrix before performing the transformation. If the CameraComponent or it's containing Entity TransformComponenthas been modified since the last frame you may need to call the Update() method first. Exceptions ArgumentNullException Thrown if cameraComponent is null. WorldToScreenPoint(CameraComponent, ref Vector3, GraphicsDevice) Converts the world position to screen space coordinates relative to cameraComponent and the window size of the graphicsDevice. public static Vector2 WorldToScreenPoint(this CameraComponent cameraComponent, ref Vector3 position, GraphicsDevice graphicsDevice) Parameters cameraComponent CameraComponent The camera component used to perform the calculation. position Vector3 The world space position to be converted to screen space. graphicsDevice GraphicsDevice The graphics device providing information about the window size. Returns Vector2 The screen position as normalized X * graphicsDevice width, normalized Y * graphicsDevice height. Z is always 0. Remarks This method does not update the ViewMatrix or ProjectionMatrix before performing the transformation. If the CameraComponent or it's containing Entity TransformComponenthas been modified since the last frame you may need to call the Update() method first. Exceptions ArgumentNullException If the cameraComponent argument is null."
  },
  "api/Stride.CommunityToolkit.Engine.CameraDefaults.html": {
    "href": "api/Stride.CommunityToolkit.Engine.CameraDefaults.html",
    "title": "Class CameraDefaults | Stride Community Toolkit",
    "summary": "Class CameraDefaults Namespace Stride.CommunityToolkit.Engine Assembly Stride.CommunityToolkit.dll Provides default settings for camera initialization within a game or scene, including default positions, rotations, and the main camera name. public static class CameraDefaults Inheritance object CameraDefaults Fields Initial2DPosition Specifies the default initial position for a 2D camera within the game or scene. This position is set as (0, 0, 50), placing the camera far enough from the origin to see the 2D plane. public static readonly Vector3 Initial2DPosition Field Value Vector3 Initial2DRotation Specifies the default initial rotation for a 2D camera within the game or scene. This rotation is set as (0, 0, 0) by default, representing no rotation around the X, Y, and Z axes. public static readonly Vector3 Initial2DRotation Field Value Vector3 Initial3DPosition Specifies the default initial position for a 3D camera within the game or scene. This position is set as (6, 6, 6) by default, representing the X, Y, and Z coordinates. public static readonly Vector3 Initial3DPosition Field Value Vector3 Initial3DRotation Specifies the default initial rotation (in degrees) for a 3D camera within the game or scene. The rotation is set as (45, -30, 0) by default, representing rotations around the Yaw (X), Pitch (Y), and Roll (Z) axes. public static readonly Vector3 Initial3DRotation Field Value Vector3 MainCameraName The default name for the main camera used in Stride game projects. public const string MainCameraName = \"Main\" Field Value string"
  },
  "api/Stride.CommunityToolkit.Engine.EntityComponentCollectionExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Engine.EntityComponentCollectionExtensions.html",
    "title": "Class EntityComponentCollectionExtensions | Stride Community Toolkit",
    "summary": "Class EntityComponentCollectionExtensions Namespace Stride.CommunityToolkit.Engine Assembly Stride.CommunityToolkit.dll Extension methods for IEnumerable<T> and IEnumerable<T>. public static class EntityComponentCollectionExtensions Inheritance object EntityComponentCollectionExtensions Methods Disable<T>(IEnumerable<T>) Disables all ActivableEntityComponent in the collection. public static void Disable<T>(this IEnumerable<T> components) where T : ActivableEntityComponent Parameters components IEnumerable<T> A collection of ActivableEntityComponent to enable. Type Parameters T The type of component. Exceptions ArgumentNullException If components is null. Enable<T>(IEnumerable<T>) Enables all ActivableEntityComponent in the collection. public static void Enable<T>(this IEnumerable<T> components) where T : ActivableEntityComponent Parameters components IEnumerable<T> A collection of ActivableEntityComponent to enable. Type Parameters T The type of component. Exceptions ArgumentNullException If components is null. Toggle<T>(IEnumerable<T>) Toggles the Enabled state all ActivableEntityComponent in the collection. public static void Toggle<T>(this IEnumerable<T> components) where T : ActivableEntityComponent Parameters components IEnumerable<T> A collection of ActivableEntityComponent to enable. Type Parameters T The type of component. Exceptions ArgumentNullException If components is null."
  },
  "api/Stride.CommunityToolkit.Engine.EntityExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Engine.EntityExtensions.html",
    "title": "Class EntityExtensions | Stride Community Toolkit",
    "summary": "Class EntityExtensions Namespace Stride.CommunityToolkit.Engine Assembly Stride.CommunityToolkit.dll Provides extension methods for the Entity class to simplify common operations, such as adding camera controllers, gizmos, and retrieving or manipulating components. public static class EntityExtensions Inheritance object EntityExtensions Methods Add2DCameraController(Entity) public static void Add2DCameraController(this Entity entity) Parameters entity Entity Add3DCameraController(Entity) Adds an interactive camera script Basic3DCameraController to the specified entity, enabling camera movement and rotation through various input methods. public static void Add3DCameraController(this Entity entity) Parameters entity Entity The entity to which the interactive camera script will be added. Remarks The camera entity can be moved using W, A, S, D, Q and E, arrow keys, a gamepad's left stick or by dragging/scaling using multi-touch. Rotation is achieved using the Numpad, the mouse while holding the right mouse button, a gamepad's right stick, or by dragging using single-touch. AddGizmo(Entity, GraphicsDevice, Color?, Color?, Color?, bool, bool) Adds a TranslationGizmo to the specified entity with optional custom colors. public static void AddGizmo(this Entity entity, GraphicsDevice graphicsDevice, Color? redColor = null, Color? greenColor = null, Color? blueColor = null, bool showAxisName = false, bool rotateAxisNames = true) Parameters entity Entity The entity to which the gizmo will be added. graphicsDevice GraphicsDevice The graphics device used for rendering the gizmo. redColor Color? Optional custom color for the X-axis of the gizmo. If not specified, a default color is used. greenColor Color? Optional custom color for the Y-axis of the gizmo. If not specified, a default color is used. blueColor Color? Optional custom color for the Z-axis of the gizmo. If not specified, a default color is used. showAxisName bool Optional flag to show axis names. Default is false. rotateAxisNames bool Optional flag to rotate axis names. Default is true. Examples This example shows how to add a gizmo to an entity with the default colors: var entity = new Entity(); // Assume 'game' is an existing Game instance entity.AddGizmo(game.GraphicsDevice); AddLightDirectionalGizmo(Entity, GraphicsDevice, Color?) Adds a directional light gizmo to the specified entity for visual representation and manipulation in the editor or during runtime. public static void AddLightDirectionalGizmo(this Entity entity, GraphicsDevice graphicsDevice, Color? color = null) Parameters entity Entity The entity to which the directional light gizmo will be added. graphicsDevice GraphicsDevice The graphics device used to render the gizmo. color Color? Optional color for the gizmo. If not specified, a default color is used. Examples This example shows how to add a light directional gizmo to an entity with the default colors: var entity = new Entity(); // Assume 'game' is an existing Game instance entity.AddLightDirectionalGizmo(game.GraphicsDevice); Remarks This method is useful for visually representing the direction and orientation of a directional light in a scene. The gizmo can be used during runtime to provide a visual reference for the light's direction. FindEntity(Entity, string) Searches for an entity by name within the top-level entities of the current scene. public static Entity? FindEntity(this Entity entity, string name) Parameters entity Entity The reference entity used to access the scene. name string The name of the entity to find. Returns Entity The first entity matching the specified name, or null if no match is found. This search does not include child entities. FindEntityRecursive(Entity, string) Searches for an entity by name within the top-level entities of the current scene. public static Entity? FindEntityRecursive(this Entity parent, string name) Parameters parent Entity The reference entity used to access the scene. name string The name of the entity to find. Returns Entity The first entity matching the specified name, or null if no match is found. This search does not include child entities. GetComponentInChildren<T>(Entity) Recursively searches the entity's children and their descendants using a depth-first search (DFS) for the first component of the specified type. public static T? GetComponentInChildren<T>(this Entity entity) Parameters entity Entity The Entity from which to start the search. Returns T The first component of the specified type found in the entity's children or descendants, or null if no such component exists. Type Parameters T The type of component to retrieve. Exceptions ArgumentNullException Thrown when the entity is null. GetComponent<T>(Entity) Retrieves the first component of the specified type from the entity. public static T? GetComponent<T>(this Entity entity) Parameters entity Entity Returns T The first component of the specified type, or null if no such component exists. Type Parameters T The type of component to retrieve. GetComponents<T>(Entity) Retrieves all components of the specified type from the entity. public static IEnumerable<T> GetComponents<T>(this Entity entity) Parameters entity Entity Returns IEnumerable<T> An IEnumerable<T> of components of the specified type. Type Parameters T The type of components to retrieve. Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9, TComponent10>(Entity) Gets ten specified components from the entity. public static (TComponent1?, TComponent2?, TComponent3?, TComponent4?, TComponent5?, TComponent6?, TComponent7?, TComponent8?, TComponent9?, TComponent10?) Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9, TComponent10>(this Entity entity) where TComponent1 : EntityComponent where TComponent2 : EntityComponent where TComponent3 : EntityComponent where TComponent4 : EntityComponent where TComponent5 : EntityComponent where TComponent6 : EntityComponent where TComponent7 : EntityComponent where TComponent8 : EntityComponent where TComponent9 : EntityComponent where TComponent10 : EntityComponent Parameters entity Entity The Entity from which the components are retrieved. Returns (TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9, TComponent10) A tuple containing the ten components, which may be null if they do not exist. Type Parameters TComponent1 The type of the first component to retrieve. TComponent2 The type of the second component to retrieve. TComponent3 The type of the third component to retrieve. TComponent4 The type of the fourth component to retrieve. TComponent5 The type of the fifth component to retrieve. TComponent6 The type of the sixth component to retrieve. TComponent7 The type of the seventh component to retrieve. TComponent8 The type of the eighth component to retrieve. TComponent9 The type of the ninth component to retrieve. TComponent10 The type of the tenth component to retrieve. Exceptions ArgumentNullException Thrown when the entity is null. Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9, TComponent10, TComponent11>(Entity) Gets eleven specified components from the entity. public static (TComponent1?, TComponent2?, TComponent3?, TComponent4?, TComponent5?, TComponent6?, TComponent7?, TComponent8?, TComponent9?, TComponent10?, TComponent11?) Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9, TComponent10, TComponent11>(this Entity entity) where TComponent1 : EntityComponent where TComponent2 : EntityComponent where TComponent3 : EntityComponent where TComponent4 : EntityComponent where TComponent5 : EntityComponent where TComponent6 : EntityComponent where TComponent7 : EntityComponent where TComponent8 : EntityComponent where TComponent9 : EntityComponent where TComponent10 : EntityComponent where TComponent11 : EntityComponent Parameters entity Entity The Entity from which the components are retrieved. Returns (TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9, TComponent10, TComponent11) A tuple containing the eleven components, which may be null if they do not exist. Type Parameters TComponent1 The type of the first component to retrieve. TComponent2 The type of the second component to retrieve. TComponent3 The type of the third component to retrieve. TComponent4 The type of the fourth component to retrieve. TComponent5 The type of the fifth component to retrieve. TComponent6 The type of the sixth component to retrieve. TComponent7 The type of the seventh component to retrieve. TComponent8 The type of the eighth component to retrieve. TComponent9 The type of the ninth component to retrieve. TComponent10 The type of the tenth component to retrieve. TComponent11 The type of the eleventh component to retrieve. Exceptions ArgumentNullException Thrown when the entity is null. Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9, TComponent10, TComponent11, TComponent12>(Entity) Gets twelve specified components from the entity. public static (TComponent1?, TComponent2?, TComponent3?, TComponent4?, TComponent5?, TComponent6?, TComponent7?, TComponent8?, TComponent9?, TComponent10?, TComponent11?, TComponent12?) Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9, TComponent10, TComponent11, TComponent12>(this Entity entity) where TComponent1 : EntityComponent where TComponent2 : EntityComponent where TComponent3 : EntityComponent where TComponent4 : EntityComponent where TComponent5 : EntityComponent where TComponent6 : EntityComponent where TComponent7 : EntityComponent where TComponent8 : EntityComponent where TComponent9 : EntityComponent where TComponent10 : EntityComponent where TComponent11 : EntityComponent where TComponent12 : EntityComponent Parameters entity Entity The Entity from which the components are retrieved. Returns (TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9, TComponent10, TComponent11, TComponent12) A tuple containing the twelve components, which may be null if they do not exist. Type Parameters TComponent1 The type of the first component to retrieve. TComponent2 The type of the second component to retrieve. TComponent3 The type of the third component to retrieve. TComponent4 The type of the fourth component to retrieve. TComponent5 The type of the fifth component to retrieve. TComponent6 The type of the sixth component to retrieve. TComponent7 The type of the seventh component to retrieve. TComponent8 The type of the eighth component to retrieve. TComponent9 The type of the ninth component to retrieve. TComponent10 The type of the tenth component to retrieve. TComponent11 The type of the eleventh component to retrieve. TComponent12 The type of the twelfth component to retrieve. Exceptions ArgumentNullException Thrown when the entity is null. Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9, TComponent10, TComponent11, TComponent12, TComponent13>(Entity) Gets thirteen specified components from the entity. public static (TComponent1?, TComponent2?, TComponent3?, TComponent4?, TComponent5?, TComponent6?, TComponent7?, TComponent8?, TComponent9?, TComponent10?, TComponent11?, TComponent12?, TComponent13?) Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9, TComponent10, TComponent11, TComponent12, TComponent13>(this Entity entity) where TComponent1 : EntityComponent where TComponent2 : EntityComponent where TComponent3 : EntityComponent where TComponent4 : EntityComponent where TComponent5 : EntityComponent where TComponent6 : EntityComponent where TComponent7 : EntityComponent where TComponent8 : EntityComponent where TComponent9 : EntityComponent where TComponent10 : EntityComponent where TComponent11 : EntityComponent where TComponent12 : EntityComponent where TComponent13 : EntityComponent Parameters entity Entity The Entity from which the components are retrieved. Returns (TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9, TComponent10, TComponent11, TComponent12, TComponent13) A tuple containing the thirteen components, which may be null if they do not exist. Type Parameters TComponent1 The type of the first component to retrieve. TComponent2 The type of the second component to retrieve. TComponent3 The type of the third component to retrieve. TComponent4 The type of the fourth component to retrieve. TComponent5 The type of the fifth component to retrieve. TComponent6 The type of the sixth component to retrieve. TComponent7 The type of the seventh component to retrieve. TComponent8 The type of the eighth component to retrieve. TComponent9 The type of the ninth component to retrieve. TComponent10 The type of the tenth component to retrieve. TComponent11 The type of the eleventh component to retrieve. TComponent12 The type of the twelfth component to retrieve. TComponent13 The type of the thirteenth component to retrieve. Exceptions ArgumentNullException Thrown when the entity is null. Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9, TComponent10, TComponent11, TComponent12, TComponent13, TComponent14>(Entity) Gets fourteen specified components from the entity. public static (TComponent1?, TComponent2?, TComponent3?, TComponent4?, TComponent5?, TComponent6?, TComponent7?, TComponent8?, TComponent9?, TComponent10?, TComponent11?, TComponent12?, TComponent13?, TComponent14?) Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9, TComponent10, TComponent11, TComponent12, TComponent13, TComponent14>(this Entity entity) where TComponent1 : EntityComponent where TComponent2 : EntityComponent where TComponent3 : EntityComponent where TComponent4 : EntityComponent where TComponent5 : EntityComponent where TComponent6 : EntityComponent where TComponent7 : EntityComponent where TComponent8 : EntityComponent where TComponent9 : EntityComponent where TComponent10 : EntityComponent where TComponent11 : EntityComponent where TComponent12 : EntityComponent where TComponent13 : EntityComponent where TComponent14 : EntityComponent Parameters entity Entity The Entity from which the components are retrieved. Returns (TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9, TComponent10, TComponent11, TComponent12, TComponent13, TComponent14) A tuple containing the fourteen components, which may be null if they do not exist. Type Parameters TComponent1 The type of the first component to retrieve. TComponent2 The type of the second component to retrieve. TComponent3 The type of the third component to retrieve. TComponent4 The type of the fourth component to retrieve. TComponent5 The type of the fifth component to retrieve. TComponent6 The type of the sixth component to retrieve. TComponent7 The type of the seventh component to retrieve. TComponent8 The type of the eighth component to retrieve. TComponent9 The type of the ninth component to retrieve. TComponent10 The type of the tenth component to retrieve. TComponent11 The type of the eleventh component to retrieve. TComponent12 The type of the twelfth component to retrieve. TComponent13 The type of the thirteenth component to retrieve. TComponent14 The type of the fourteenth component to retrieve. Exceptions ArgumentNullException Thrown when the entity is null. Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9, TComponent10, TComponent11, TComponent12, TComponent13, TComponent14, TComponent15>(Entity) Gets fifteen specified components from the entity. public static (TComponent1?, TComponent2?, TComponent3?, TComponent4?, TComponent5?, TComponent6?, TComponent7?, TComponent8?, TComponent9?, TComponent10?, TComponent11?, TComponent12?, TComponent13?, TComponent14?, TComponent15?) Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9, TComponent10, TComponent11, TComponent12, TComponent13, TComponent14, TComponent15>(this Entity entity) where TComponent1 : EntityComponent where TComponent2 : EntityComponent where TComponent3 : EntityComponent where TComponent4 : EntityComponent where TComponent5 : EntityComponent where TComponent6 : EntityComponent where TComponent7 : EntityComponent where TComponent8 : EntityComponent where TComponent9 : EntityComponent where TComponent10 : EntityComponent where TComponent11 : EntityComponent where TComponent12 : EntityComponent where TComponent13 : EntityComponent where TComponent14 : EntityComponent where TComponent15 : EntityComponent Parameters entity Entity The Entity from which the components are retrieved. Returns (TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9, TComponent10, TComponent11, TComponent12, TComponent13, TComponent14, TComponent15) A tuple containing the fifteen components, which may be null if they do not exist. Type Parameters TComponent1 The type of the first component to retrieve. TComponent2 The type of the second component to retrieve. TComponent3 The type of the third component to retrieve. TComponent4 The type of the fourth component to retrieve. TComponent5 The type of the fifth component to retrieve. TComponent6 The type of the sixth component to retrieve. TComponent7 The type of the seventh component to retrieve. TComponent8 The type of the eighth component to retrieve. TComponent9 The type of the ninth component to retrieve. TComponent10 The type of the tenth component to retrieve. TComponent11 The type of the eleventh component to retrieve. TComponent12 The type of the twelfth component to retrieve. TComponent13 The type of the thirteenth component to retrieve. TComponent14 The type of the fourteenth component to retrieve. TComponent15 The type of the fifteenth component to retrieve. Exceptions ArgumentNullException Thrown when the entity is null. Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9, TComponent10, TComponent11, TComponent12, TComponent13, TComponent14, TComponent15, TComponent16>(Entity) Gets sixteen specified components from the entity. public static (TComponent1?, TComponent2?, TComponent3?, TComponent4?, TComponent5?, TComponent6?, TComponent7?, TComponent8?, TComponent9?, TComponent10?, TComponent11?, TComponent12?, TComponent13?, TComponent14?, TComponent15?, TComponent16?) Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9, TComponent10, TComponent11, TComponent12, TComponent13, TComponent14, TComponent15, TComponent16>(this Entity entity) where TComponent1 : EntityComponent where TComponent2 : EntityComponent where TComponent3 : EntityComponent where TComponent4 : EntityComponent where TComponent5 : EntityComponent where TComponent6 : EntityComponent where TComponent7 : EntityComponent where TComponent8 : EntityComponent where TComponent9 : EntityComponent where TComponent10 : EntityComponent where TComponent11 : EntityComponent where TComponent12 : EntityComponent where TComponent13 : EntityComponent where TComponent14 : EntityComponent where TComponent15 : EntityComponent where TComponent16 : EntityComponent Parameters entity Entity The Entity from which the components are retrieved. Returns (TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9, TComponent10, TComponent11, TComponent12, TComponent13, TComponent14, TComponent15, TComponent16) A tuple containing the sixteen components, which may be null if they do not exist. Type Parameters TComponent1 The type of the first component to retrieve. TComponent2 The type of the second component to retrieve. TComponent3 The type of the third component to retrieve. TComponent4 The type of the fourth component to retrieve. TComponent5 The type of the fifth component to retrieve. TComponent6 The type of the sixth component to retrieve. TComponent7 The type of the seventh component to retrieve. TComponent8 The type of the eighth component to retrieve. TComponent9 The type of the ninth component to retrieve. TComponent10 The type of the tenth component to retrieve. TComponent11 The type of the eleventh component to retrieve. TComponent12 The type of the twelfth component to retrieve. TComponent13 The type of the thirteenth component to retrieve. TComponent14 The type of the fourteenth component to retrieve. TComponent15 The type of the fifteenth component to retrieve. TComponent16 The type of the sixteenth component to retrieve. Exceptions ArgumentNullException Thrown when the entity is null. Get<TComponent1, TComponent2>(Entity) Gets two specified components from the entity. public static (TComponent1?, TComponent2?) Get<TComponent1, TComponent2>(this Entity entity) where TComponent1 : EntityComponent where TComponent2 : EntityComponent Parameters entity Entity The Entity from which the components are retrieved. Returns (TComponent1, TComponent2) A tuple containing the two components, which may be null if they do not exist. Type Parameters TComponent1 The type of the first component to retrieve. TComponent2 The type of the second component to retrieve. Exceptions ArgumentNullException Thrown when the entity is null. Get<TComponent1, TComponent2, TComponent3>(Entity) Gets three specified components from the entity. public static (TComponent1?, TComponent2?, TComponent3?) Get<TComponent1, TComponent2, TComponent3>(this Entity entity) where TComponent1 : EntityComponent where TComponent2 : EntityComponent where TComponent3 : EntityComponent Parameters entity Entity The Entity from which the components are retrieved. Returns (TComponent1, TComponent2, TComponent3) A tuple containing the three components, which may be null if they do not exist. Type Parameters TComponent1 The type of the first component to retrieve. TComponent2 The type of the second component to retrieve. TComponent3 The type of the third component to retrieve. Exceptions ArgumentNullException Thrown when the entity is null. Get<TComponent1, TComponent2, TComponent3, TComponent4>(Entity) Gets four specified components from the entity. public static (TComponent1?, TComponent2?, TComponent3?, TComponent4?) Get<TComponent1, TComponent2, TComponent3, TComponent4>(this Entity entity) where TComponent1 : EntityComponent where TComponent2 : EntityComponent where TComponent3 : EntityComponent where TComponent4 : EntityComponent Parameters entity Entity The Entity from which the components are retrieved. Returns (TComponent1, TComponent2, TComponent3, TComponent4) A tuple containing the four components, which may be null if they do not exist. Type Parameters TComponent1 The type of the first component to retrieve. TComponent2 The type of the second component to retrieve. TComponent3 The type of the third component to retrieve. TComponent4 The type of the fourth component to retrieve. Exceptions ArgumentNullException Thrown when the entity is null. Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5>(Entity) Gets five specified components from the entity. public static (TComponent1?, TComponent2?, TComponent3?, TComponent4?, TComponent5?) Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5>(this Entity entity) where TComponent1 : EntityComponent where TComponent2 : EntityComponent where TComponent3 : EntityComponent where TComponent4 : EntityComponent where TComponent5 : EntityComponent Parameters entity Entity The Entity from which the components are retrieved. Returns (TComponent1, TComponent2, TComponent3, TComponent4, TComponent5) A tuple containing the five components, which may be null if they do not exist. Type Parameters TComponent1 The type of the first component to retrieve. TComponent2 The type of the second component to retrieve. TComponent3 The type of the third component to retrieve. TComponent4 The type of the fourth component to retrieve. TComponent5 The type of the fifth component to retrieve. Exceptions ArgumentNullException Thrown when the entity is null. Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6>(Entity) Gets six specified components from the entity. public static (TComponent1?, TComponent2?, TComponent3?, TComponent4?, TComponent5?, TComponent6?) Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6>(this Entity entity) where TComponent1 : EntityComponent where TComponent2 : EntityComponent where TComponent3 : EntityComponent where TComponent4 : EntityComponent where TComponent5 : EntityComponent where TComponent6 : EntityComponent Parameters entity Entity The Entity from which the components are retrieved. Returns (TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6) A tuple containing the six components, which may be null if they do not exist. Type Parameters TComponent1 The type of the first component to retrieve. TComponent2 The type of the second component to retrieve. TComponent3 The type of the third component to retrieve. TComponent4 The type of the fourth component to retrieve. TComponent5 The type of the fifth component to retrieve. TComponent6 The type of the sixth component to retrieve. Exceptions ArgumentNullException Thrown when the entity is null. Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7>(Entity) Gets seven specified components from the entity. public static (TComponent1?, TComponent2?, TComponent3?, TComponent4?, TComponent5?, TComponent6?, TComponent7?) Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7>(this Entity entity) where TComponent1 : EntityComponent where TComponent2 : EntityComponent where TComponent3 : EntityComponent where TComponent4 : EntityComponent where TComponent5 : EntityComponent where TComponent6 : EntityComponent where TComponent7 : EntityComponent Parameters entity Entity The Entity from which the components are retrieved. Returns (TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7) A tuple containing the seven components, which may be null if they do not exist. Type Parameters TComponent1 The type of the first component to retrieve. TComponent2 The type of the second component to retrieve. TComponent3 The type of the third component to retrieve. TComponent4 The type of the fourth component to retrieve. TComponent5 The type of the fifth component to retrieve. TComponent6 The type of the sixth component to retrieve. TComponent7 The type of the seventh component to retrieve. Exceptions ArgumentNullException Thrown when the entity is null. Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8>(Entity) Gets eight specified components from the entity. public static (TComponent1?, TComponent2?, TComponent3?, TComponent4?, TComponent5?, TComponent6?, TComponent7?, TComponent8?) Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8>(this Entity entity) where TComponent1 : EntityComponent where TComponent2 : EntityComponent where TComponent3 : EntityComponent where TComponent4 : EntityComponent where TComponent5 : EntityComponent where TComponent6 : EntityComponent where TComponent7 : EntityComponent where TComponent8 : EntityComponent Parameters entity Entity The Entity from which the components are retrieved. Returns (TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8) A tuple containing the eight components, which may be null if they do not exist. Type Parameters TComponent1 The type of the first component to retrieve. TComponent2 The type of the second component to retrieve. TComponent3 The type of the third component to retrieve. TComponent4 The type of the fourth component to retrieve. TComponent5 The type of the fifth component to retrieve. TComponent6 The type of the sixth component to retrieve. TComponent7 The type of the seventh component to retrieve. TComponent8 The type of the eighth component to retrieve. Exceptions ArgumentNullException Thrown when the entity is null. Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9>(Entity) Gets nine specified components from the entity. public static (TComponent1?, TComponent2?, TComponent3?, TComponent4?, TComponent5?, TComponent6?, TComponent7?, TComponent8?, TComponent9?) Get<TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9>(this Entity entity) where TComponent1 : EntityComponent where TComponent2 : EntityComponent where TComponent3 : EntityComponent where TComponent4 : EntityComponent where TComponent5 : EntityComponent where TComponent6 : EntityComponent where TComponent7 : EntityComponent where TComponent8 : EntityComponent where TComponent9 : EntityComponent Parameters entity Entity The Entity from which the components are retrieved. Returns (TComponent1, TComponent2, TComponent3, TComponent4, TComponent5, TComponent6, TComponent7, TComponent8, TComponent9) A tuple containing the nine components, which may be null if they do not exist. Type Parameters TComponent1 The type of the first component to retrieve. TComponent2 The type of the second component to retrieve. TComponent3 The type of the third component to retrieve. TComponent4 The type of the fourth component to retrieve. TComponent5 The type of the fifth component to retrieve. TComponent6 The type of the sixth component to retrieve. TComponent7 The type of the seventh component to retrieve. TComponent8 The type of the eighth component to retrieve. TComponent9 The type of the ninth component to retrieve. Exceptions ArgumentNullException Thrown when the entity is null. Remove(Entity) Removes the entity from its current scene by setting its Scene property to null. public static void Remove(this Entity entity) Parameters entity Entity The entity to be removed from its current scene. TryGetComponent<T>(Entity, out T) Tries to retrieve a component of type T from the given entity. public static bool TryGetComponent<T>(this Entity entity, out T result) Parameters entity Entity The entity from which to retrieve the component. result T When this method returns, contains the first component of type Returns bool true if a component of type T is found in the entity; otherwise, false. Type Parameters T The type of component to retrieve. WorldPosition(Entity, bool) Retrieves the world position of the entity. This is a convenience method to get the TranslationVector from the WorldMatrix. public static Vector3 WorldPosition(this Entity entity, bool updateTransforms = true) Parameters entity Entity The Entity to get the world position from. updateTransforms bool If true, it will update the world matrix to the current frame's world matrix. Returns Vector3 The Vector3 representing the world position of the Entity."
  },
  "api/Stride.CommunityToolkit.Engine.EntitySearchExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Engine.EntitySearchExtensions.html",
    "title": "Class EntitySearchExtensions | Stride Community Toolkit",
    "summary": "Class EntitySearchExtensions Namespace Stride.CommunityToolkit.Engine Assembly Stride.CommunityToolkit.dll Provides extension methods for searching and retrieving EntityComponent instances within an Entity hierarchy. This class includes methods for performing breadth-first and depth-first searches to find components in children, descendants, and ancestors of an entity. public static class EntitySearchExtensions Inheritance object EntitySearchExtensions Examples Example usage: var component = entity.GetComponentInChildrenBFS<MyComponent>(); var allComponents = entity.GetComponentsInDescendants<MyComponent>(); Remarks The methods in this class support various search options, including: Searching only in children or including the entity itself. Including or excluding disabled components. Retrieving a single component or all components of a specified type. Methods GetComponentInChildrenAndSelf<T>(Entity) Performs a breadth first search of the entity and it's children for a component of the specified type. public static T? GetComponentInChildrenAndSelf<T>(this Entity entity) where T : EntityComponent Parameters entity Entity The entity. Returns T The component or null if does no exist. Type Parameters T The type of component. Exceptions ArgumentNullException The entity was null. GetComponentInChildrenAndSelf<T>(Entity, bool) Performs a breadth first search of the entity and it's children for a component of the specified type. public static T? GetComponentInChildrenAndSelf<T>(this Entity entity, bool includeDisabled = false) where T : ActivableEntityComponent Parameters entity Entity The entity. includeDisabled bool Should search include ActivableEntityComponent where Enabled is false. Returns T The component or null if does no exist. Type Parameters T The type of component. Exceptions ArgumentNullException The entity was null. GetComponentInChildrenBFS<T>(Entity) Searches the entity's children using a breadth-first search (BFS) to find the first component of the specified type. public static T? GetComponentInChildrenBFS<T>(this Entity entity) where T : EntityComponent Parameters entity Entity The Entity to search within. Returns T The first component of type T found in the entity's children, or null if none exists. Type Parameters T The type of component to retrieve. Exceptions ArgumentNullException Thrown if the entity is null. GetComponentInChildren<T>(Entity, bool) Performs a breadth first search of the entities children for a component of the specified type. public static T? GetComponentInChildren<T>(this Entity entity, bool includeDisabled = false) where T : ActivableEntityComponent Parameters entity Entity The entity. includeDisabled bool Should search include ActivableEntityComponent where Enabled is false. Returns T The component or null if does no exist. Type Parameters T The type of component. Exceptions ArgumentNullException The entity was null. GetComponentInParent<T>(Entity) Performs a search of the entity and it's ancestors for a component of the specified type. public static T? GetComponentInParent<T>(this Entity entity) where T : EntityComponent Parameters entity Entity The entity. Returns T The component or null if does no exist. Type Parameters T The type of component. Exceptions ArgumentNullException The entity was null. GetComponentInParent<T>(Entity, bool) Performs a search of the entity and it's ancestors for a component of the specified type. public static T? GetComponentInParent<T>(this Entity entity, bool includeDisabled = false) where T : ActivableEntityComponent Parameters entity Entity The entity. includeDisabled bool Should search include ActivableEntityComponent where Enabled is false. Returns T The component or null if does no exist. Type Parameters T The type of component. Exceptions ArgumentNullException The entity was null. GetComponentsInChildrenAndSelf<T>(Entity) Performs a depth first search of the entity and it's children for all components of the specified type. public static IEnumerable<T> GetComponentsInChildrenAndSelf<T>(this Entity entity) where T : EntityComponent Parameters entity Entity The entity. Returns IEnumerable<T> An iteration on the components. Type Parameters T The type of component. Exceptions ArgumentNullException The entity was null. GetComponentsInChildrenAndSelf<T>(Entity, bool) Performs a depth first search of the entity and it's children for all components of the specified type. public static IEnumerable<T> GetComponentsInChildrenAndSelf<T>(this Entity entity, bool includeDisabled = false) where T : ActivableEntityComponent Parameters entity Entity The entity. includeDisabled bool Should search include ActivableEntityComponent where Enabled is false. Returns IEnumerable<T> An iteration on the components. Type Parameters T The type of component. Exceptions ArgumentNullException The entity was null. GetComponentsInChildren<T>(Entity) Performs a depth first search of the entities children for all components of the specified type. public static IEnumerable<T> GetComponentsInChildren<T>(this Entity entity) where T : EntityComponent Parameters entity Entity The entity. Returns IEnumerable<T> An iteration on the components. Type Parameters T The type of component. Exceptions ArgumentNullException The entity was null. GetComponentsInChildren<T>(Entity, bool) Performs a depth first search of the entities children for all components of the specified type. public static IEnumerable<T> GetComponentsInChildren<T>(this Entity entity, bool includeDisabled = false) where T : ActivableEntityComponent Parameters entity Entity The entity. includeDisabled bool Should search include ActivableEntityComponent where Enabled is false. Returns IEnumerable<T> An iteration on the components. Type Parameters T The type of component. Exceptions ArgumentNullException The entity was null. GetComponentsInDescendantsAndSelf<T>(Entity) Performs a depth first search of the entity and it's decendants for all components of the specified type. public static IEnumerable<T> GetComponentsInDescendantsAndSelf<T>(this Entity entity) where T : EntityComponent Parameters entity Entity The entity. Returns IEnumerable<T> An iteration on the components. Type Parameters T The type of component. Exceptions ArgumentNullException The entity was null. GetComponentsInDescendantsAndSelf<T>(Entity, bool) Performs a depth first search of the entity and it's decendants for all components of the specified type. public static IEnumerable<T> GetComponentsInDescendantsAndSelf<T>(this Entity entity, bool includeDisabled = false) where T : ActivableEntityComponent Parameters entity Entity The entity. includeDisabled bool Should search include ActivableEntityComponent where Enabled is false. Returns IEnumerable<T> An iteration on the components. Type Parameters T The type of component. Exceptions ArgumentNullException The entity was null. GetComponentsInDescendants<T>(Entity) Performs a depth first search of the entities decendants for all components of the specified type. public static IEnumerable<T> GetComponentsInDescendants<T>(this Entity entity) where T : EntityComponent Parameters entity Entity The entity. Returns IEnumerable<T> An iteration on the components. Type Parameters T The type of component. Exceptions ArgumentNullException The entity was null. GetComponentsInDescendants<T>(Entity, bool) Performs a depth first search of the entity and it's decendants for all components of the specified type. public static IEnumerable<T> GetComponentsInDescendants<T>(this Entity entity, bool includeDisabled = false) where T : ActivableEntityComponent Parameters entity Entity The entity. includeDisabled bool Should search include ActivableEntityComponent where Enabled is false. Returns IEnumerable<T> An iteration on the components. Type Parameters T The type of component. Exceptions ArgumentNullException The entity was null. GetComponentsInParent<T>(Entity) Performs a search of the entity and it's ancestors for all components of the specified type. public static IEnumerable<T> GetComponentsInParent<T>(this Entity entity) where T : EntityComponent Parameters entity Entity The entity. Returns IEnumerable<T> An iteration on the components. Type Parameters T The type of component. Exceptions ArgumentNullException The entity was null. GetComponentsInParent<T>(Entity, bool) Performs a search of the entity and it's ancestors for all components of the specified type. public static IEnumerable<T> GetComponentsInParent<T>(this Entity entity, bool includeDisabled = false) where T : ActivableEntityComponent Parameters entity Entity The entity. includeDisabled bool Should search include ActivableEntityComponent where Enabled is false. Returns IEnumerable<T> An iteration on the components. Type Parameters T The type of component. Exceptions ArgumentNullException The entity was null."
  },
  "api/Stride.CommunityToolkit.Engine.GameDefaults.html": {
    "href": "api/Stride.CommunityToolkit.Engine.GameDefaults.html",
    "title": "Class GameDefaults | Stride Community Toolkit",
    "summary": "Class GameDefaults Namespace Stride.CommunityToolkit.Engine Assembly Stride.CommunityToolkit.dll Provides default values for the game project. public static class GameDefaults Inheritance object GameDefaults Fields Default2DGroundSize The default size of the 2D ground entity. public static readonly Vector3 Default2DGroundSize Field Value Vector3 Default3DGroundSize The default size of the 3D ground entity. public static readonly Vector2 Default3DGroundSize Field Value Vector2 DefaultGroundMaterialColor The default material color for the ground entity. public static readonly Color DefaultGroundMaterialColor Field Value Color DefaultGroundName The default name for the ground entity. public const string DefaultGroundName = \"Ground\" Field Value string DefaultMaterialColor The default material color for 3D entities. public static readonly Color DefaultMaterialColor Field Value Color GraphicsCompositorNotSet The message to display when the GraphicsCompositor is not set. public const string GraphicsCompositorNotSet = \"GraphicsCompositor is not set.\" Field Value string"
  },
  "api/Stride.CommunityToolkit.Engine.GameExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Engine.GameExtensions.html",
    "title": "Class GameExtensions | Stride Community Toolkit",
    "summary": "Class GameExtensions Namespace Stride.CommunityToolkit.Engine Assembly Stride.CommunityToolkit.dll Provides extension methods for the Game class to simplify common game setup tasks, such as adding cameras, lights, and ground entities, as well as configuring scenes and running the game with custom logic. public static class GameExtensions Inheritance object GameExtensions Methods Add2DCamera(Game, string?, Vector3?, Vector3?) Adds a 2D camera entity to the game's root scene with customizable position and rotation, defaulting to orthographic projection. public static Entity Add2DCamera(this Game game, string? cameraName = \"Main\", Vector3? initialPosition = null, Vector3? initialRotation = null) Parameters game Game The Game instance to which the camera entity will be added. cameraName string Optional name for the camera entity and camera slot. Defaults to \"MainCamera\" if not provided. If null, the entity will not be named. initialPosition Vector3? Initial position for the camera entity. If not provided, the camera will be positioned at a default 2D position. initialRotation Vector3? Initial rotation for the camera entity specified in degrees. If not provided, the camera will be rotated to the default 2D orientation. Returns Entity The created Entity object representing the 2D camera. Remarks The camera entity will be created with an orthographic projection mode and added to the game's root scene. It will also be assigned to the first available camera slot in the GraphicsCompositor. Add3DCamera(Game, string?, Vector3?, Vector3?, CameraProjectionMode) Adds a 3D camera entity to the game's root scene with customizable position, rotation, projection mode and default camera name \"Main\". public static Entity Add3DCamera(this Game game, string? cameraName = \"Main\", Vector3? initialPosition = null, Vector3? initialRotation = null, CameraProjectionMode projectionMode = CameraProjectionMode.Perspective) Parameters game Game The Game instance to which the camera entity will be added. cameraName string Optional name for the camera entity and camera slot. Defaults to \"MainCamera\" if not provided. If null, the entity will not be named. initialPosition Vector3? Initial position for the camera entity. If not provided, the camera will be positioned at a default 3D position (6, 6, 6). initialRotation Vector3? Initial rotation for the camera entity specified in degrees. If not provided, the camera will be rotated to face towards the origin with default angles (Yaw: 45, Pitch: -30, Roll: 0). projectionMode CameraProjectionMode The projection mode for the camera (Perspective or Orthographic). Defaults to Perspective. Returns Entity The created Entity object representing the 3D camera. Remarks The camera entity will be created with the specified projection mode and added to the game's root scene. It will also be assigned to the first available camera slot in the GraphicsCompositor. Exceptions InvalidOperationException Thrown if the GraphicsCompositor does not have any camera slots defined. AddAllDirectionLighting(Game, float, bool) Adds directional lighting from multiple angles to the current scene, enhancing scene illumination. public static void AddAllDirectionLighting(this Game game, float intensity, bool showLightGizmo = true) Parameters game Game The game instance to which the lighting will be added. intensity float The intensity of the light sources. showLightGizmo bool Specifies whether to display a gizmo for the light in the editor. Default is true. Remarks This method creates six directional lights positioned around a central point, each aiming from a unique angle to simulate uniform lighting from all directions. The lights are added at predefined positions and rotations to cover the scene evenly. AddDirectionalLight(Game, string?) Adds a directional light entity to the game's root scene with optional customization. public static Entity AddDirectionalLight(this Game game, string? entityName = \"Directional Light\") Parameters game Game The Game instance to which the directional light will be added. entityName string Optional name for the new directional light entity. If null, the entity will not be named. Returns Entity The created Entity object representing the directional light. Remarks This method creates a directional light with the following default settings: - Intensity: 20.0f - Position: (0, 2.0f, 0) - Rotation: X-axis rotated by -30 degrees and Y-axis rotated by -180 degrees. - Shadow Enabled: True - Shadow Size: Large - Shadow Filter: PCF (Percentage Closer Filtering) with a filter size of 5x5 The entity will be added to the game's root scene. You can customize the light properties by accessing the returned Entity object. AddEntityDebugSceneRenderer(Game, EntityDebugSceneRendererOptions?) Adds an EntityDebugSceneRenderer to the game's GraphicsCompositor for rendering entity debug information. public static void AddEntityDebugSceneRenderer(this Game game, EntityDebugSceneRendererOptions? options = null) Parameters game Game The Game instance to which the entity debug renderer will be added. options EntityDebugSceneRendererOptions Optional settings to customize the appearance of the debug renderer. If not provided, default options will be used. Examples The following example demonstrates how to add an entity debug renderer with default settings: game.EntityDebugSceneRenderer(); You can also specify custom options: var options = new EntityDebugRendererOptions { FontSize = 16, FontColor = Color.Red }; game.EntityDebugSceneRenderer(options); Remarks This method adds a custom EntityDebugSceneRenderer to the game's graphics compositor, allowing the display of debug information such as entity names and positions in a 3D scene. The renderer can be customized using the options parameter, which allows the user to define font size, color, and other settings. Exceptions InvalidOperationException Thrown if the GraphicsCompositor is not set in the game's SceneSystem. AddGraphicsCompositor(Game) Adds a default GraphicsCompositor with enabled post-effects to the specified Game instance and sets it as the game's SceneSystem GraphicsCompositor. public static GraphicsCompositor AddGraphicsCompositor(this Game game) Parameters game Game The Game instance to which the GraphicsCompositor will be added. Returns GraphicsCompositor The newly configured GraphicsCompositor instance with enabled post-effects. AddGroundGizmo(Game, Vector3?, bool, bool) Adds a ground gizmo to the game's root scene, attached to an existing ground entity. public static void AddGroundGizmo(this Game game, Vector3? position = null, bool showAxisName = false, bool rotateAxisNames = true) Parameters game Game The Game instance in which the ground gizmo will be added. position Vector3? The position of the gizmo in 3D space. If null, the gizmo will be placed at the origin (0, 0, 0). showAxisName bool A boolean indicating whether the axis names (X, Y, Z) should be displayed on the gizmo. Default is false. rotateAxisNames bool A boolean indicating whether the axis names should rotate to always face the camera. Default is true. Remarks The gizmo is added as a child to an existing ground entity. If the ground entity is not found, the method will return without adding the gizmo. The gizmo helps visualize the ground with axis indicators in 3D space. AddParticleRenderer(Game) public static void AddParticleRenderer(this Game game) Parameters game Game AddProfiler(Game, string?) Adds a profiler to the game, which can be toggled on/off with Left Shift + Left Ctrl + P, and provides other keyboard shortcuts. Changing the filtering mode with F1, altering the sorting mode with F2, navigating result pages with F3 and F4, and adjusting the refresh interval with the plus and minus keys. public static Entity AddProfiler(this Game game, string? entityName = \"Game Profiler\") Parameters game Game The game to which the profiler will be added. entityName string Optional name for the entity to which the GameProfiler script will be attached. Returns Entity The entity to which the GameProfiler script was attached. Remarks This extension method creates an entity and attaches a GameProfiler script to it, enabling in-game profiling. The profiler's behaviour can be interacted with using various keyboard shortcuts as described in the GameProfiler class. AddRootRenderFeature(Game, RootRenderFeature) public static void AddRootRenderFeature(this Game game, RootRenderFeature renderFeature) Parameters game Game renderFeature RootRenderFeature AddSceneRenderer(Game, SceneRendererBase) Adds a scene renderer to the game's GraphicsCompositor. public static void AddSceneRenderer(this Game game, SceneRendererBase renderer) Parameters game Game The Game instance to add the renderer to. renderer SceneRendererBase The scene renderer to be added, inheriting from SceneRendererBase. Exceptions ArgumentNullException Thrown when the renderer is null. InvalidOperationException Thrown if the GraphicsCompositor is not set in the game's SceneSystem. CreateMaterial(IGame, Color?, float, float) Creates a basic material with optional color, specular reflection, and microsurface smoothness values. public static Material CreateMaterial(this IGame game, Color? color = null, float specular = 1, float microSurface = 0.65) Parameters game IGame The game instance used to access the graphics device. color Color? The color of the material. Defaults to null, which will use the _defaultMaterialColor. specular float The specular reflection factor of the material. Defaults to 1.0f. microSurface float The microsurface smoothness value of the material. Defaults to 0.65f. Returns Material A new material instance with the specified or default attributes. Run(Game, GameContext?, Action<Game>?, Action<Game>?) Initializes the game, starts the game loop, and handles game events. public static void Run(this Game game, GameContext? context = null, Action<Game>? start = null, Action<Game>? update = null) Parameters game Game The Game instance to initialize and run. context GameContext Optional GameContext to be used. Defaults to null. start Action<Game> Optional action to execute at the start of the game. Takes the game as a parameter. update Action<Game> Optional action to execute during each game loop iteration. Takes the game as a parameter. Remarks This method performs the following actions: Schedules the root script for execution. Initiates the game loop by calling Run(GameContext). Invokes the provided start and update delegates. Run(Game, GameContext?, Action<Scene>?, Action<Scene, GameTime>?) Initializes the game, starts the game loop, and handles game events. public static void Run(this Game game, GameContext? context = null, Action<Scene>? start = null, Action<Scene, GameTime>? update = null) Parameters game Game The Game instance to initialize and run. context GameContext Optional GameContext to be used. Defaults to null. start Action<Scene> Optional action to execute at the start of the game. Takes the root scene as a parameter. update Action<Scene, GameTime> Optional action to execute during each game loop iteration. Takes the root scene and game time as parameters. Remarks This method performs the following actions: Schedules the root script for execution. Initiates the game loop by calling Run(GameContext). Invokes the provided start and update delegates. SetupBase(Game) Sets up essential components for the game, including a GraphicsCompositor, a camera, and a directional light. public static void SetupBase(this Game game) Parameters game Game The Game instance that will receive the base setup. Remarks This method performs the following operations: Adds a default GraphicsCompositor to the game's SceneSystem and applies a clean UI stage. Adds a camera to the game. Adds a directional light to the game. TakeScreenShot(IGame, string, ImageFileType) Saves a screenshot of the current frame to the specified file path. public static void TakeScreenShot(this IGame game, string fileName, ImageFileType fileType = ImageFileType.Png) Parameters game IGame fileName string creates a file with this name fileType ImageFileType"
  },
  "api/Stride.CommunityToolkit.Engine.ModelComponentExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Engine.ModelComponentExtensions.html",
    "title": "Class ModelComponentExtensions | Stride Community Toolkit",
    "summary": "Class ModelComponentExtensions Namespace Stride.CommunityToolkit.Engine Assembly Stride.CommunityToolkit.dll Provides extension methods for the ModelComponent class, enabling additional functionality such as calculating model dimensions and extracting mesh data. public static class ModelComponentExtensions Inheritance object ModelComponentExtensions Methods GetMeshHWL(ModelComponent) Calculates the height, width, and length of the model represented by the ModelComponent. public static Vector3 GetMeshHWL(this ModelComponent modelComponent) Parameters modelComponent ModelComponent The ModelComponent whose model dimensions are to be calculated. Returns Vector3 A Vector3 representing the height, width, and length of the model. Remarks The dimensions are calculated based on the model's bounding box. The returned Vector3 contains the height (Y-axis), width (X-axis), and length (Z-axis) of the bounding box. GetMeshHeight(ModelComponent) Calculates the height of the model represented by the ModelComponent. public static float GetMeshHeight(this ModelComponent modelComponent) Parameters modelComponent ModelComponent The ModelComponent whose model height is to be calculated. Returns float The height of the model along the Y-axis. Remarks The height is calculated based on the model's bounding box, which encompasses its maximum extent in 3D space. GetMeshVerticesAndIndices(ModelComponent, IGame) Retrieves the vertices and indices from the ModelComponent's mesh data. public static (List<Vector3> vertices, List<int> indices) GetMeshVerticesAndIndices(this ModelComponent model, IGame game) Parameters model ModelComponent The ModelComponent from which to extract mesh data. game IGame The game instance, used to access graphics context for data extraction. Returns (List<Vector3> vertices, List<int> indices) A tuple containing two lists: the first list holds the vertices (as Vector3), and the second list holds the indices (as int). Remarks This method extracts raw vertex and index data from the meshes in the provided ModelComponent. It's useful for operations that require direct access to mesh data, such as custom rendering, collision detection, or physics simulations. Note that this method extracts combined vertex and index data from all meshes in the ModelComponent. SetMaterialParameter<T>(ModelComponent, ObjectParameterAccessor<T>, T, int, int) Sets an object of the material pass parameter. Cloning the Material if required. public static void SetMaterialParameter<T>(this ModelComponent modelComponent, ObjectParameterAccessor<T> parameterAccessor, T value, int materialIndex = 0, int passIndex = 0) Parameters modelComponent ModelComponent The ModelComponent to update material parameter on. parameterAccessor ObjectParameterAccessor<T> The parameter to update. value T The value. materialIndex int The index of the material to update. Default is 0. passIndex int The index of the pass of the material to update. Default is 0. Type Parameters T The type of value. Exceptions ArgumentNullException If modelComponent is null. ArgumentOutOfRangeException If materialIndex is less than 0 or greater than GetMaterialCount() and not in Materials. Or if passIndex is less than 0 or greater than or equal to the mu,ber of passes the material has. SetMaterialParameter<T>(ModelComponent, ObjectParameterKey<T>, T, int, int) Sets an object of the material pass parameter. Cloning the Material if required. public static void SetMaterialParameter<T>(this ModelComponent modelComponent, ObjectParameterKey<T> parameter, T value, int materialIndex = 0, int passIndex = 0) Parameters modelComponent ModelComponent The ModelComponent to update material parameter on. parameter ObjectParameterKey<T> The parameter to update. value T The value. materialIndex int The index of the material to update. Default is 0. passIndex int The index of the pass of the material to update. Default is 0. Type Parameters T The type of value. Exceptions ArgumentNullException If modelComponent is null. ArgumentOutOfRangeException If materialIndex is less than 0 or greater than GetMaterialCount() and not in Materials. Or if passIndex is less than 0 or greater than or equal to the mu,ber of passes the material has. SetMaterialParameter<T>(ModelComponent, PermutationParameterKey<T>, T, int, int) Sets a permutation of the material pass parameter. Cloning the Material if required. public static void SetMaterialParameter<T>(this ModelComponent modelComponent, PermutationParameterKey<T> parameter, T value, int materialIndex = 0, int passIndex = 0) Parameters modelComponent ModelComponent The ModelComponent to update material parameter on. parameter PermutationParameterKey<T> The parameter to update. value T The value. materialIndex int The index of the material to update. Default is 0. passIndex int The index of the pass of the material to update. Default is 0. Type Parameters T The type of value. Exceptions ArgumentNullException If modelComponent is null. ArgumentOutOfRangeException If materialIndex is less than 0 or greater than GetMaterialCount() and not in Materials. Or if passIndex is less than 0 or greater than or equal to the mu,ber of passes the material has. SetMaterialParameter<T>(ModelComponent, PermutationParameter<T>, T, int, int) Sets a permutation of the material pass parameter. Cloning the Material if required. public static void SetMaterialParameter<T>(this ModelComponent modelComponent, PermutationParameter<T> parameter, T value, int materialIndex = 0, int passIndex = 0) Parameters modelComponent ModelComponent The ModelComponent to update material parameter on. parameter PermutationParameter<T> The parameter to update. value T The value. materialIndex int The index of the material to update. Default is 0. passIndex int The index of the pass of the material to update. Default is 0. Type Parameters T The type of value. Exceptions ArgumentNullException If modelComponent is null. ArgumentOutOfRangeException If materialIndex is less than 0 or greater than GetMaterialCount() and not in Materials. Or if passIndex is less than 0 or greater than or equal to the mu,ber of passes the material has. SetMaterialParameter<T>(ModelComponent, ValueParameterKey<T>, int, ref T, int, int) Sets blittable values of the material pass parameter. Cloning the Material if required. public static void SetMaterialParameter<T>(this ModelComponent modelComponent, ValueParameterKey<T> parameter, int count, ref T firstValue, int materialIndex = 0, int passIndex = 0) where T : struct Parameters modelComponent ModelComponent The ModelComponent to update material parameter on. parameter ValueParameterKey<T> The parameter to update. count int Number of values. firstValue T The values. materialIndex int The index of the material to update. Default is 0. passIndex int The index of the pass of the material to update. Default is 0. Type Parameters T The type of value. Exceptions ArgumentNullException If modelComponent is null. ArgumentOutOfRangeException If materialIndex is less than 0 or greater than GetMaterialCount() and not in Materials. Or if passIndex is less than 0 or greater than or equal to the mu,ber of passes the material has. SetMaterialParameter<T>(ModelComponent, ValueParameterKey<T>, T, int, int) Sets a blittable of the material pass parameter. Cloning the Material if required. public static void SetMaterialParameter<T>(this ModelComponent modelComponent, ValueParameterKey<T> parameter, T value, int materialIndex = 0, int passIndex = 0) where T : struct Parameters modelComponent ModelComponent The ModelComponent to update material parameter on. parameter ValueParameterKey<T> The parameter to update. value T The value. materialIndex int The index of the material to update. Default is 0. passIndex int The index of the pass of the material to update. Default is 0. Type Parameters T The type of value. Exceptions ArgumentNullException If modelComponent is null. ArgumentOutOfRangeException If materialIndex is less than 0 or greater than GetMaterialCount() and not in Materials. Or if passIndex is less than 0 or greater than or equal to the mu,ber of passes the material has. SetMaterialParameter<T>(ModelComponent, ValueParameterKey<T>, ref T, int, int) Sets a blittable value of the material pass parameter. Cloning the Material if required. public static void SetMaterialParameter<T>(this ModelComponent modelComponent, ValueParameterKey<T> parameter, ref T value, int materialIndex = 0, int passIndex = 0) where T : struct Parameters modelComponent ModelComponent The ModelComponent to update material parameter on. parameter ValueParameterKey<T> The parameter to update. value T The value. materialIndex int The index of the material to update. Default is 0. passIndex int The index of the pass of the material to update. Default is 0. Type Parameters T The type of value. Exceptions ArgumentNullException If modelComponent is null. ArgumentOutOfRangeException If materialIndex is less than 0 or greater than GetMaterialCount() and not in Materials. Or if passIndex is less than 0 or greater than or equal to the mu,ber of passes the material has. SetMaterialParameter<T>(ModelComponent, ValueParameterKey<T>, T[], int, int) Sets blittable values of the material pass parameter. Cloning the Material if required. public static void SetMaterialParameter<T>(this ModelComponent modelComponent, ValueParameterKey<T> parameter, T[] values, int materialIndex = 0, int passIndex = 0) where T : struct Parameters modelComponent ModelComponent The ModelComponent to update material parameter on. parameter ValueParameterKey<T> The parameter to update. values T[] The values. materialIndex int The index of the material to update. Default is 0. passIndex int The index of the pass of the material to update. Default is 0. Type Parameters T The type of value. Exceptions ArgumentNullException If modelComponent is null. ArgumentOutOfRangeException If materialIndex is less than 0 or greater than GetMaterialCount() and not in Materials. Or if passIndex is less than 0 or greater than or equal to the mu,ber of passes the material has. SetMaterialParameter<T>(ModelComponent, ValueParameter<T>, int, ref T, int, int) Sets blittable values of the material pass parameter. Cloning the Material if required. public static void SetMaterialParameter<T>(this ModelComponent modelComponent, ValueParameter<T> parameter, int count, ref T firstValue, int materialIndex = 0, int passIndex = 0) where T : struct Parameters modelComponent ModelComponent The ModelComponent to update material parameter on. parameter ValueParameter<T> The parameter to update. count int Number of values. firstValue T The values. materialIndex int The index of the material to update. Default is 0. passIndex int The index of the pass of the material to update. Default is 0. Type Parameters T The type of value. Exceptions ArgumentNullException If modelComponent is null. ArgumentOutOfRangeException If materialIndex is less than 0 or greater than GetMaterialCount() and not in Materials. Or if passIndex is less than 0 or greater than or equal to the mu,ber of passes the material has. SetMaterialParameter<T>(ModelComponent, ValueParameter<T>, T, int, int) Sets a blittable value of the material pass parameter. Cloning the Material if required. public static void SetMaterialParameter<T>(this ModelComponent modelComponent, ValueParameter<T> parameter, T value, int materialIndex = 0, int passIndex = 0) where T : struct Parameters modelComponent ModelComponent The ModelComponent to update material parameter on. parameter ValueParameter<T> The parameter to update. value T The value. materialIndex int The index of the material to update. Default is 0. passIndex int The index of the pass of the material to update. Default is 0. Type Parameters T The type of value. Exceptions ArgumentNullException If modelComponent is null. ArgumentOutOfRangeException If materialIndex is less than 0 or greater than GetMaterialCount() and not in Materials. Or if passIndex is less than 0 or greater than or equal to the mu,ber of passes the material has. SetMaterialParameter<T>(ModelComponent, ValueParameter<T>, ref T, int, int) Sets blittable value of the material pass parameter. Cloning the Material if required. public static void SetMaterialParameter<T>(this ModelComponent modelComponent, ValueParameter<T> parameter, ref T value, int materialIndex = 0, int passIndex = 0) where T : struct Parameters modelComponent ModelComponent The ModelComponent to update material parameter on. parameter ValueParameter<T> The parameter to update. value T The value. materialIndex int The index of the material to update. Default is 0. passIndex int The index of the pass of the material to update. Default is 0. Type Parameters T The type of value. Exceptions ArgumentNullException If modelComponent is null. ArgumentOutOfRangeException If materialIndex is less than 0 or greater than GetMaterialCount() and not in Materials. Or if passIndex is less than 0 or greater than or equal to the mu,ber of passes the material has."
  },
  "api/Stride.CommunityToolkit.Engine.PrefabExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Engine.PrefabExtensions.html",
    "title": "Class PrefabExtensions | Stride Community Toolkit",
    "summary": "Class PrefabExtensions Namespace Stride.CommunityToolkit.Engine Assembly Stride.CommunityToolkit.dll Extension methods for Prefab. public static class PrefabExtensions Inheritance object PrefabExtensions Methods Instantiate(Prefab, Vector3) Instantiates a Prefab and a applies a transform to all the entites. public static List<Entity> Instantiate(this Prefab prefab, Vector3 translation) Parameters prefab Prefab The Prefab to instantiate. translation Vector3 The Vector3 to translate the entities by. Returns List<Entity> The instantiated and translated entities. Exceptions ArgumentException If prefab is null. Instantiate(Prefab, Vector3, Quaternion) Instantiates a Prefab and a applies a transform to all the entites. public static List<Entity> Instantiate(this Prefab prefab, Vector3 translation, Quaternion rotation) Parameters prefab Prefab The Prefab to instantiate. translation Vector3 The Vector3 to translate the entities by. rotation Quaternion The Quaternion to rotate the entities by. Returns List<Entity> The instantiated and translated entities. Exceptions ArgumentException If prefab is null. Instantiate(Prefab, Vector3, Quaternion, Vector3) Instantiates a Prefab and a applies a transform to all the entites. public static List<Entity> Instantiate(this Prefab prefab, Vector3 translation, Quaternion rotation, Vector3 scale) Parameters prefab Prefab The Prefab to instantiate. translation Vector3 The Vector3 to translate the entities by. rotation Quaternion The Quaternion to rotate the entities by. scale Vector3 The Vector3 to scale the entities by. Returns List<Entity> The instantiated and translated entities. Exceptions ArgumentException If prefab is null. Instantiate(Prefab, Vector3, Vector3) Instantiates a Prefab and a applies a transform to all the entites. public static List<Entity> Instantiate(this Prefab prefab, Vector3 translation, Vector3 rotationEulerAngles) Parameters prefab Prefab The Prefab to instantiate. translation Vector3 The Vector3 to translate the entities by. rotationEulerAngles Vector3 The X, Y and Z rotations in euler angles to rotate the entities by. Returns List<Entity> The instantiated and translated entities. Exceptions ArgumentException If prefab is null. Instantiate(Prefab, Vector3, Vector3, Vector3) Instantiates a Prefab and a applies a transform to all the entites. public static List<Entity> Instantiate(this Prefab prefab, Vector3 translation, Vector3 rotationEulerAngles, Vector3 scale) Parameters prefab Prefab The Prefab to instantiate. translation Vector3 The Vector3 to translate the entities by. rotationEulerAngles Vector3 The X, Y and Z rotations in euler angles to rotate the entities by. scale Vector3 The Vector3 to scale the entities by. Returns List<Entity> The instantiated and translated entities. Exceptions ArgumentException If prefab is null. Instantiate(Prefab, ref Vector3) Instantiates a Prefab and a applies a transform to all the entites. public static List<Entity> Instantiate(this Prefab prefab, ref Vector3 translation) Parameters prefab Prefab The Prefab to instantiate. translation Vector3 The Vector3 to translate the entities by. Returns List<Entity> The instantiated and translated entities. Exceptions ArgumentException If prefab is null. Instantiate(Prefab, ref Vector3, ref Quaternion) Instantiates a Prefab and a applies a transform to all the entites. public static List<Entity> Instantiate(this Prefab prefab, ref Vector3 translation, ref Quaternion rotation) Parameters prefab Prefab The Prefab to instantiate. translation Vector3 The Vector3 to translate the entities by. rotation Quaternion The Quaternion to rotate the entities by. Returns List<Entity> The instantiated and translated entities. Exceptions ArgumentException If prefab is null. Instantiate(Prefab, ref Vector3, ref Quaternion, ref Vector3) Instantiates a Prefab and a applies a transform to all the entites. public static List<Entity> Instantiate(this Prefab prefab, ref Vector3 translation, ref Quaternion rotation, ref Vector3 scale) Parameters prefab Prefab The Prefab to instantiate. translation Vector3 The Vector3 to translate the entities by. rotation Quaternion The Quaternion to rotate the entities by. scale Vector3 The Vector3 to scale the entities by. Returns List<Entity> The instantiated and translated entities. Exceptions ArgumentException If prefab is null. Instantiate(Prefab, ref Vector3, ref Vector3) Instantiates a Prefab and a applies a transform to all the entites. public static List<Entity> Instantiate(this Prefab prefab, ref Vector3 translation, ref Vector3 rotationEulerAngles) Parameters prefab Prefab The Prefab to instantiate. translation Vector3 The Vector3 to translate the entities by. rotationEulerAngles Vector3 The X, Y and Z rotations in euler angles to rotate the entities by. Returns List<Entity> The instantiated and translated entities. Exceptions ArgumentException If prefab is null. Instantiate(Prefab, ref Vector3, ref Vector3, ref Vector3) Instantiates a Prefab and a applies a transform to all the entites. public static List<Entity> Instantiate(this Prefab prefab, ref Vector3 translation, ref Vector3 rotationEulerAngles, ref Vector3 scale) Parameters prefab Prefab The Prefab to instantiate. translation Vector3 The Vector3 to translate the entities by. rotationEulerAngles Vector3 The X, Y and Z rotations in euler angles to rotate the entities by. scale Vector3 The Vector3 to scale the entities by. Returns List<Entity> The instantiated and translated entities. Exceptions ArgumentException If prefab is null. InstantiateSingle(Prefab) Instantiates a Prefab that contains a single Entity. public static Entity InstantiateSingle(this Prefab prefab) Parameters prefab Prefab The Prefab to instantiate. Returns Entity The instantiated and translated Entity. Exceptions ArgumentException If prefab is null. InvalidOperationException If prefab does not have exactly 1 Entity. InstantiateSingle(Prefab, Vector3) Instantiates a Prefab that contains a single Entity and applies a transform. public static Entity InstantiateSingle(this Prefab prefab, Vector3 translation) Parameters prefab Prefab The Prefab to instantiate. translation Vector3 The Vector3 to translate the entity by. Returns Entity The instantiated and translated Entity. Exceptions ArgumentException If prefab is null. InvalidOperationException If prefab does not have exactly 1 Entity. InstantiateSingle(Prefab, Vector3, Quaternion) Instantiates a Prefab that contains a single Entity and applies a transform. public static Entity InstantiateSingle(this Prefab prefab, Vector3 translation, Quaternion rotation) Parameters prefab Prefab The Prefab to instantiate. translation Vector3 The Vector3 to translate the entity by. rotation Quaternion The Quaternion to rotate the entity by. Returns Entity The instantiated and translated Entity. Exceptions ArgumentException If prefab is null. InvalidOperationException If prefab does not have exactly 1 Entity. InstantiateSingle(Prefab, Vector3, Quaternion, Vector3) Instantiates a Prefab that contains a single Entity and applies a transform. public static Entity InstantiateSingle(this Prefab prefab, Vector3 translation, Quaternion rotation, Vector3 scale) Parameters prefab Prefab The Prefab to instantiate. translation Vector3 The Vector3 to translate the entity by. rotation Quaternion The Quaternion to rotate the entity by. scale Vector3 The Vector3 to scale the entity by. Returns Entity The instantiated and translated Entity. Exceptions ArgumentException If prefab is null. InvalidOperationException If prefab does not have exactly 1 Entity. InstantiateSingle(Prefab, Vector3, Vector3) Instantiates a Prefab that contains a single Entity and applies a transform. public static Entity InstantiateSingle(this Prefab prefab, Vector3 translation, Vector3 rotationEulerAngles) Parameters prefab Prefab The Prefab to instantiate. translation Vector3 The Vector3 to translate the entity by. rotationEulerAngles Vector3 The X, Y and Z rotations in radians to rotate the entity by. Returns Entity The instantiated and translated Entity. Exceptions ArgumentException If prefab is null. InvalidOperationException If prefab does not have exactly 1 Entity. InstantiateSingle(Prefab, Vector3, Vector3, Vector3) Instantiates a Prefab that contains a single Entity and applies a transform. public static Entity InstantiateSingle(this Prefab prefab, Vector3 translation, Vector3 rotationEulerAngles, Vector3 scale) Parameters prefab Prefab The Prefab to instantiate. translation Vector3 The Vector3 to translate the entity by. rotationEulerAngles Vector3 The X, Y and Z rotations in radians to rotate the entity by. scale Vector3 The Vector3 to scale the entity by. Returns Entity The instantiated and translated Entity. Exceptions ArgumentException If prefab is null. InvalidOperationException If prefab does not have exactly 1 Entity. InstantiateSingle(Prefab, ref Vector3) Instantiates a Prefab that contains a single Entity and applies a transform. public static Entity InstantiateSingle(this Prefab prefab, ref Vector3 translation) Parameters prefab Prefab The Prefab to instantiate. translation Vector3 The Vector3 to translate the entity by. Returns Entity The instantiated and translated Entity. Exceptions ArgumentException If prefab is null. InvalidOperationException If prefab does not have exactly 1 Entity. InstantiateSingle(Prefab, ref Vector3, ref Quaternion) Instantiates a Prefab that contains a single Entity and applies a transform. public static Entity InstantiateSingle(this Prefab prefab, ref Vector3 translation, ref Quaternion rotation) Parameters prefab Prefab The Prefab to instantiate. translation Vector3 The Vector3 to translate the entity by. rotation Quaternion The Quaternion to rotate the entity by. Returns Entity The instantiated and translated Entity. Exceptions ArgumentException If prefab is null. InvalidOperationException If prefab does not have exactly 1 Entity. InstantiateSingle(Prefab, ref Vector3, ref Quaternion, ref Vector3) Instantiates a Prefab that contains a single Entity and applies a transform. public static Entity InstantiateSingle(this Prefab prefab, ref Vector3 translation, ref Quaternion rotation, ref Vector3 scale) Parameters prefab Prefab The Prefab to instantiate. translation Vector3 The Vector3 to translate the entity by. rotation Quaternion The Quaternion to rotate the entity by. scale Vector3 The Vector3 to scale the entity by. Returns Entity The instantiated and translated Entity. Exceptions ArgumentException If prefab is null. InvalidOperationException If prefab does not have exactly 1 Entity. InstantiateSingle(Prefab, ref Vector3, ref Vector3) Instantiates a Prefab that contains a single Entity and applies a transform. public static Entity InstantiateSingle(this Prefab prefab, ref Vector3 translation, ref Vector3 rotationEulerAngles) Parameters prefab Prefab The Prefab to instantiate. translation Vector3 The Vector3 to translate the entity by. rotationEulerAngles Vector3 The X, Y and Z rotations in radians to rotate the entity by. Returns Entity The instantiated and translated Entity. Exceptions ArgumentException If prefab is null. InvalidOperationException If prefab does not have exactly 1 Entity. InstantiateSingle(Prefab, ref Vector3, ref Vector3, ref Vector3) Instantiates a Prefab that contains a single Entity and applies a transform. public static Entity InstantiateSingle(this Prefab prefab, ref Vector3 translation, ref Vector3 rotationEulerAngles, ref Vector3 scale) Parameters prefab Prefab The Prefab to instantiate. translation Vector3 The Vector3 to translate the entity by. rotationEulerAngles Vector3 The X, Y and Z rotations in radians to rotate the entity by. scale Vector3 The Vector3 to scale the entity by. Returns Entity The instantiated and translated Entity. Exceptions ArgumentException If prefab is null. InvalidOperationException If prefab does not have exactly 1 Entity."
  },
  "api/Stride.CommunityToolkit.Engine.PrimitiveCreationOptions.html": {
    "href": "api/Stride.CommunityToolkit.Engine.PrimitiveCreationOptions.html",
    "title": "Class PrimitiveCreationOptions | Stride Community Toolkit",
    "summary": "Class PrimitiveCreationOptions Namespace Stride.CommunityToolkit.Engine Assembly Stride.CommunityToolkit.dll Provides options for creating a primitive entity, such as a cube, sphere, or other 3D object. These options allow customization of the entity's name, material, collider inclusion, and render group. public abstract class PrimitiveCreationOptions Inheritance object PrimitiveCreationOptions Derived Primitive2DCreationOptions Primitive3DCreationOptions Primitive2DCreationOptions Primitive3DCreationOptions Properties EntityName Gets or sets the name of the entity. This can be useful for identifying the entity within the scene or debugging purposes. public string? EntityName { get; set; } Property Value string IncludeCollider Determines whether to include a collider component in the entity. Defaults to true. A collider is necessary for physics interactions, such as detecting collisions with other entities. public bool IncludeCollider { get; set; } Property Value bool Material Gets or sets the material to be applied to the primitive model. The material defines the appearance of the primitive, including its color and texture. public Material? Material { get; set; } Property Value Material RenderGroup Gets or sets the render group for the entity. Defaults to Group0. Render groups allow different entities to be rendered in separate stages or layers, which can be useful for organizing complex scenes or applying different rendering effects. public RenderGroup RenderGroup { get; set; } Property Value RenderGroup"
  },
  "api/Stride.CommunityToolkit.Engine.SceneExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Engine.SceneExtensions.html",
    "title": "Class SceneExtensions | Stride Community Toolkit",
    "summary": "Class SceneExtensions Namespace Stride.CommunityToolkit.Engine Assembly Stride.CommunityToolkit.dll Provides extension methods for the Scene class to enhance camera-related functionality. public static class SceneExtensions Inheritance object SceneExtensions Methods GetCamera(Scene) Retrieves the first CameraComponent found in the scene. public static CameraComponent? GetCamera(this Scene scene) Parameters scene Scene The Scene in which to search for the camera. Returns CameraComponent The first CameraComponent found in the scene, or null if no camera is present. Remarks This method searches through the scene's entities and returns the first camera it finds. It performs a recursive search through child entities as well. GetCamera(Scene, string) Retrieves the first CameraComponent in the scene that belongs to an entity with the specified name. public static CameraComponent? GetCamera(this Scene scene, string name) Parameters scene Scene The Scene in which to search for the camera. name string The name of the Entity containing the desired camera. Returns CameraComponent The first CameraComponent found with the specified entity name, or null if no matching camera is found. Remarks This method searches through the scene's entities for a camera that belongs to an entity with the given name. It performs a recursive search through child entities as well."
  },
  "api/Stride.CommunityToolkit.Engine.ScriptComponentExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Engine.ScriptComponentExtensions.html",
    "title": "Class ScriptComponentExtensions | Stride Community Toolkit",
    "summary": "Class ScriptComponentExtensions Namespace Stride.CommunityToolkit.Engine Assembly Stride.CommunityToolkit.dll Provides extension methods for ScriptComponent to enhance interactions with game timing and cameras in the GraphicsCompositor. public static class ScriptComponentExtensions Inheritance object ScriptComponentExtensions Methods DeltaTime(ScriptComponent) Retrieves the time elapsed since the last game update in seconds. public static float DeltaTime(this ScriptComponent scriptComponent) Parameters scriptComponent ScriptComponent The ScriptComponent used to access game timing information. Returns float The time elapsed since the last game update, in seconds, as a single-precision floating-point number. GetFirstGCCamera(ScriptComponent) Retrieves the first camera from the GraphicsCompositor. Note that the camera might not be available during the first 2-3 frames. public static CameraComponent GetFirstGCCamera(this ScriptComponent scriptComponent) Parameters scriptComponent ScriptComponent The ScriptComponent from which to access the GraphicsCompositor. Returns CameraComponent The first CameraComponent in the camera collection. Remarks Ensure that the GraphicsCompositor is initialized with cameras before calling this method. GetGCCamera(ScriptComponent) Retrieves the camera named \"Main\" from the GraphicsCompositor. Note that the camera might not be available during the first 2-3 frames. public static CameraComponent? GetGCCamera(this ScriptComponent scriptComponent) Parameters scriptComponent ScriptComponent The ScriptComponent from which to access the GraphicsCompositor. Returns CameraComponent The CameraComponent named \"Main\", if found; otherwise, null. Remarks Ensure that the GraphicsCompositor is initialized with cameras before calling this method, or it may return null. GetGCCamera(ScriptComponent, string) Retrieves a camera from the GraphicsCompositor with the specified name. Note that the camera might not be available during the first 2-3 frames. public static CameraComponent? GetGCCamera(this ScriptComponent scriptComponent, string cameraName) Parameters scriptComponent ScriptComponent The ScriptComponent from which to access the GraphicsCompositor. cameraName string The name of the camera to retrieve. Returns CameraComponent The CameraComponent with the specified name, if found; otherwise, null. Remarks Ensure that the GraphicsCompositor is initialized with cameras before calling this method, or it may return null."
  },
  "api/Stride.CommunityToolkit.Engine.ScriptSystemExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Engine.ScriptSystemExtensions.html",
    "title": "Class ScriptSystemExtensions | Stride Community Toolkit",
    "summary": "Class ScriptSystemExtensions Namespace Stride.CommunityToolkit.Engine Assembly Stride.CommunityToolkit.dll Provides extension methods for the ScriptSystem to facilitate time-based operations, including delays and frame-based executions. These extensions are useful for managing time in game logic, such as delaying actions or executing logic over a period of time. public static class ScriptSystemExtensions Inheritance object ScriptSystemExtensions Examples Example 1: Delaying an action for 2 seconds in game time (affected by time warp): await scriptSystem.DelayWarped(2.0f); // Action will be delayed for 2 in-game seconds, accounting for any time warp factors. Example 2: Running a continuous action for 5 seconds of real time (unaffected by time warp): await scriptSystem.ExecuteInTime(5.0f, elapsed => { // Perform action based on the elapsed time in real seconds. DebugText.Print($\"Time elapsed: {elapsed} seconds\"); }); Example 3: Delaying an action for 3 real-time seconds (unaffected by time warp): await scriptSystem.Delay(3.0f); // Action will be delayed for exactly 3 real seconds. Remarks These extensions allow you to control how game logic interacts with time, whether you need frame-based operations or time delays. The methods are useful for both real-time and in-game time-based operations. Methods AddAction(ScriptSystem, Action, TimeSpan, long) Adds a micro thread function to the scriptSystem that executes after waiting specified delay. public static MicroThread AddAction(this ScriptSystem scriptSystem, Action action, TimeSpan delay, long priority = 0) Parameters scriptSystem ScriptSystem The ScriptSystem. action Action The micro thread function to execute. delay TimeSpan The amount of time to wait for. priority long The priority of the micro thread action being added. Returns MicroThread The MicroThread. Remarks If the action is a ScriptComponent instance method the micro thread will be automatically stopped if the ScriptComponent or Entity is removed. Exceptions ArgumentNullException If scriptSystem or action is null. ArgumentOutOfRangeException If delay is less than zero. AddAction(ScriptSystem, Action, TimeSpan, TimeSpan, long) Adds a micro thread function to the scriptSystem that executes after waiting specified delay and repeats execution. public static MicroThread AddAction(this ScriptSystem scriptSystem, Action action, TimeSpan delay, TimeSpan repeatEvery, long priority = 0) Parameters scriptSystem ScriptSystem The ScriptSystem. action Action The micro thread function to execute. delay TimeSpan The amount of time to wait for. repeatEvery TimeSpan The amount of time to wait for between repetition. priority long The priority of the micro thread action being added. Returns MicroThread The MicroThread. Remarks If the action is a ScriptComponent instance method the micro thread will be automatically stopped if the ScriptComponent or Entity is removed. Exceptions ArgumentNullException If scriptSystem or action is null. ArgumentOutOfRangeException If delay or repeatEvery is less than zero. AddOnEventAction<T>(ScriptSystem, EventKey<T>, Action<T>, long) Adds a micro thread function to the scriptSystem that executes when the event is published. public static MicroThread AddOnEventAction<T>(this ScriptSystem scriptSystem, EventKey<T> eventKey, Action<T> action, long priority = 0) Parameters scriptSystem ScriptSystem The ScriptSystem. eventKey EventKey<T> The event to wait for. action Action<T> The micro thread function to execute. priority long The priority of the micro thread action being added. Returns MicroThread The MicroThread. Type Parameters T The type of the event handler parameter. Remarks If the action is a ScriptComponent instance method the micro thread will be automatically stopped if the ScriptComponent or Entity is removed. Exceptions ArgumentNullException If scriptSystem, eventKey or action is null. AddOnEventAction<T>(ScriptSystem, EventReceiver<T>, Action<T>, long) Adds a micro thread function to the scriptSystem that executes when the event is published. public static MicroThread AddOnEventAction<T>(this ScriptSystem scriptSystem, EventReceiver<T> receiver, Action<T> action, long priority = 0) Parameters scriptSystem ScriptSystem The ScriptSystem. receiver EventReceiver<T> The event reciever to listen to for. action Action<T> The micro thread function to execute. priority long The priority of the micro thread action being added. Returns MicroThread The MicroThread. Type Parameters T The type of the event handler parameter. Remarks If the action is a ScriptComponent instance method the micro thread will be automatically stopped if the ScriptComponent or Entity is removed. Exceptions ArgumentNullException If scriptSystem, receiver or action is null. AddOnEventTask<T>(ScriptSystem, EventKey<T>, Func<T, Task>, long) Adds a micro thread function to the scriptSystem that executes when the event is published. public static MicroThread AddOnEventTask<T>(this ScriptSystem scriptSystem, EventKey<T> eventKey, Func<T, Task> action, long priority = 0) Parameters scriptSystem ScriptSystem The ScriptSystem. eventKey EventKey<T> The event to wait for. action Func<T, Task> The micro thread function to execute. priority long The priority of the micro thread action being added. Returns MicroThread The MicroThread. Type Parameters T The type of the event handler parameter. Remarks If the action is a ScriptComponent instance method the micro thread will be automatically stopped if the ScriptComponent or Entity is removed. Exceptions ArgumentNullException If scriptSystem, eventKey or action is null. AddOnEventTask<T>(ScriptSystem, EventReceiver<T>, Func<T, Task>, long) Adds a micro thread function to the scriptSystem that executes when the event is published. public static MicroThread AddOnEventTask<T>(this ScriptSystem scriptSystem, EventReceiver<T> receiver, Func<T, Task> action, long priority = 0) Parameters scriptSystem ScriptSystem The ScriptSystem. receiver EventReceiver<T> The event reciever to listen to for. action Func<T, Task> The micro thread function to execute. priority long The priority of the micro thread action being added. Returns MicroThread The MicroThread. Type Parameters T The type of the event handler parameter. Remarks If the action is a ScriptComponent instance method the micro thread will be automatically stopped if the ScriptComponent or Entity is removed. Exceptions ArgumentNullException If scriptSystem, receiver or action is null. AddOverTimeAction(ScriptSystem, Action<float>, TimeSpan, long) Adds a micro thread function to the scriptSystem that executes after waiting specified delay and repeats execution. public static MicroThread AddOverTimeAction(this ScriptSystem scriptSystem, Action<float> action, TimeSpan duration, long priority = 0) Parameters scriptSystem ScriptSystem The ScriptSystem. action Action<float> The micro thread function to execute. The parameter is the progress over time from 0.0f to 1.0f. duration TimeSpan The duration of the time to execute the micro thread function for. priority long The priority of the micro thread action being added. Returns MicroThread The MicroThread. Remarks If the action is a ScriptComponent instance method the micro thread will be automatically stopped if the ScriptComponent or Entity is removed. Exceptions ArgumentNullException If scriptSystem or action is null. ArgumentOutOfRangeException If duration is less than zero. AddTask(ScriptSystem, Func<Task>, TimeSpan, long) Adds a micro thread function to the scriptSystem that executes after waiting specified delay. public static MicroThread AddTask(this ScriptSystem scriptSystem, Func<Task> action, TimeSpan delay, long priority = 0) Parameters scriptSystem ScriptSystem The ScriptSystem. action Func<Task> The micro thread function to execute. delay TimeSpan The amount of time to wait for. priority long The priority of the micro thread action being added. Returns MicroThread The MicroThread. Remarks If the action is a ScriptComponent instance method the micro thread will be automatically stopped if the ScriptComponent or Entity is removed. Exceptions ArgumentNullException If scriptSystem or action is null. ArgumentOutOfRangeException If delay is less than zero. AddTask(ScriptSystem, Func<Task>, TimeSpan, TimeSpan, long) Adds a micro thread function to the scriptSystem that executes after waiting specified delay and repeats execution. public static MicroThread AddTask(this ScriptSystem scriptSystem, Func<Task> action, TimeSpan delay, TimeSpan repeatEvery, long priority = 0) Parameters scriptSystem ScriptSystem The ScriptSystem. action Func<Task> The micro thread function to execute. delay TimeSpan The amount of time to wait for. repeatEvery TimeSpan The amount of time to wait for between repetition. priority long The priority of the micro thread action being added. Returns MicroThread The MicroThread. Remarks If the action is a ScriptComponent instance method the micro thread will be automatically stopped if the ScriptComponent or Entity is removed. Exceptions ArgumentNullException If scriptSystem or action is null. ArgumentOutOfRangeException If delay or repeatEvery is less than zero. CancelAll(ICollection<MicroThread>) Cancels all MicroThread and clears the microThreads collection. public static void CancelAll(this ICollection<MicroThread> microThreads) Parameters microThreads ICollection<MicroThread> A collection of MicroThread to cancel. Exceptions ArgumentNullException If microThreads is null. Delay(ScriptSystem, float) Waits for a specified amount of real time (not accounting for any time warp factors). public static Task Delay(this ScriptSystem script, float seconds) Parameters script ScriptSystem The ScriptSystem instance used to execute the delay. seconds float The number of seconds to delay execution. Returns Task A Task representing the delay. Remarks This delay operates in real time without considering the game's time warp. DelayWarped(ScriptSystem, float) Waits for a specified amount of time, adjusting for any time warp factors. public static Task DelayWarped(this ScriptSystem script, float seconds) Parameters script ScriptSystem The ScriptSystem instance used to execute the delay. seconds float The number of seconds to delay execution. Returns Task A Task representing the delay. Remarks This delay takes into account the game's time warp factor, using the WarpElapsed property of UpdateTime. ExecuteInTime(ScriptSystem, float, Action<float>) Executes an action every frame for a specified duration, using real time (not accounting for any time warp factors). public static Task ExecuteInTime(this ScriptSystem script, float seconds, Action<float> action) Parameters script ScriptSystem The ScriptSystem instance used to execute the action. seconds float The duration in seconds for which the action will be executed. action Action<float> The action to perform on each frame, which receives the elapsed time as a parameter. Returns Task A Task representing the action execution. Remarks This method operates in real time, without considering the game's time warp. ExecuteInWarpedTime(ScriptSystem, float, Action<float>) Executes an action every frame for a specified duration, adjusting for any time warp factors. public static Task ExecuteInWarpedTime(this ScriptSystem script, float seconds, Action<float> action) Parameters script ScriptSystem The ScriptSystem instance used to execute the action. seconds float The duration in seconds for which the action will be executed. action Action<float> The action to perform on each frame, which receives the elapsed time as a parameter. Returns Task A Task representing the action execution. Remarks This method accounts for the game's WarpElapsed time factor during execution. WaitFor(ScriptSystem, TimeSpan) Waits for the specified delay delay . public static Task WaitFor(this ScriptSystem scriptSystem, TimeSpan delay) Parameters scriptSystem ScriptSystem The ScriptSystem. delay TimeSpan The amount of time to wait. Returns Task The Task to await."
  },
  "api/Stride.CommunityToolkit.Engine.Space.html": {
    "href": "api/Stride.CommunityToolkit.Engine.Space.html",
    "title": "Enum Space | Stride Community Toolkit",
    "summary": "Enum Space Namespace Stride.CommunityToolkit.Engine Assembly Stride.CommunityToolkit.dll The coordinate space in which to operate. public enum Space Fields Self = 1 Applies transformation relative to the local coordinate system. World = 0 Applies transformation relative to the world coordinate system."
  },
  "api/Stride.CommunityToolkit.Engine.TransformExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Engine.TransformExtensions.html",
    "title": "Class TransformExtensions | Stride Community Toolkit",
    "summary": "Class TransformExtensions Namespace Stride.CommunityToolkit.Engine Assembly Stride.CommunityToolkit.dll Extension methods for TransformComponent. public static class TransformExtensions Inheritance object TransformExtensions Fields WorldUp The default world up vector. The default is UnitY. public static Vector3 WorldUp Field Value Vector3 Methods InverseTransformDirection(TransformComponent, Vector3) Performs a direction transformation using the inverse of the given WorldMatrix. public static Vector3 InverseTransformDirection(this TransformComponent transform, Vector3 direction) Parameters transform TransformComponent The transform to get the world matrix from. direction Vector3 The direction vector to transform. Returns Vector3 The transformed direction. Remarks This method does not update the WorldMatrix before performing the transformation. If the TransformComponent has been modified since the last frame you may need to call the UpdateWorldMatrix() method first. Exceptions ArgumentNullException If transform is null. InverseTransformDirection(TransformComponent, ref Vector3, out Vector3) Performs a direction transformation using the inverse of the given WorldMatrix. public static void InverseTransformDirection(this TransformComponent transform, ref Vector3 direction, out Vector3 result) Parameters transform TransformComponent The transform to get the world matrix from. direction Vector3 The direction vector to transform. result Vector3 The transformed direction. Remarks This method does not update the WorldMatrix before performing the transformation. If the TransformComponent has been modified since the last frame you may need to call the UpdateWorldMatrix() method first. Exceptions ArgumentNullException If transform is null. InverseTransformPosition(TransformComponent, Vector3) Performs a coordinate transformation using the inverse of the given WorldMatrix. public static Vector3 InverseTransformPosition(this TransformComponent transform, Vector3 position) Parameters transform TransformComponent The transform to get the world matrix from. position Vector3 The coordinate vector to transform. Returns Vector3 The transformed coordinate. Remarks This method does not update the WorldMatrix before performing the transformation. If the TransformComponent has been modified since the last frame you may need to call the UpdateWorldMatrix() method first. Exceptions ArgumentNullException If transform is null. InverseTransformPosition(TransformComponent, ref Vector3, out Vector3) Performs a coordinate transformation using the inverse of the given WorldMatrix. public static void InverseTransformPosition(this TransformComponent transform, ref Vector3 position, out Vector3 result) Parameters transform TransformComponent The transform to get the world matrix from. position Vector3 The coordinate vector to transform. result Vector3 The transformed coordinate. Remarks This method does not update the WorldMatrix before performing the transformation. If the TransformComponent has been modified since the last frame you may need to call the UpdateWorldMatrix() method first. Exceptions ArgumentNullException If transform is null. InverseTransformVector(TransformComponent, Vector3) Performs a normal transformation using the inverse of the given WorldMatrix. public static Vector3 InverseTransformVector(this TransformComponent transform, Vector3 vector) Parameters transform TransformComponent The transform to get the world matrix from. vector Vector3 The normal vector to transform. Returns Vector3 The transformed normal. Remarks This method does not update the WorldMatrix before performing the transformation. If the TransformComponent has been modified since the last frame you may need to call the UpdateWorldMatrix() method first. Exceptions ArgumentNullException If transform is null. InverseTransformVector(TransformComponent, ref Vector3, out Vector3) Performs a normal transformation using the inverse of the given WorldMatrix. public static void InverseTransformVector(this TransformComponent transform, ref Vector3 vector, out Vector3 result) Parameters transform TransformComponent The transform to get the world matrix from. vector Vector3 The normal vector to transform. result Vector3 The transformed normal. Remarks This method does not update the WorldMatrix before performing the transformation. If the TransformComponent has been modified since the last frame you may need to call the UpdateWorldMatrix() method first. Exceptions ArgumentNullException If transform is null. LookAt(TransformComponent, Vector3, Vector3, float) Sets the transforms rotation so it's forward vector points at the target. public static void LookAt(this TransformComponent transform, Vector3 target, Vector3 worldUp, float smooth = 1) Parameters transform TransformComponent The TransformComponent to update. target Vector3 The target to point towards worldUp Vector3 A Vector specifying the upward direction. smooth float Value between 0 and 1 indicating the weight of target orientation. The default is 1. Remarks This method updates the LocalMatrix and WorldMatrix after transformation. Exceptions ArgumentNullException If transform is null. ArgumentException If transform has UseTRS set to null. LookAt(TransformComponent, Vector3, float) Sets the transforms rotation so it's forward vector points at the target. The world up vector use is defined by WorldUp. public static void LookAt(this TransformComponent transform, Vector3 target, float smooth = 1) Parameters transform TransformComponent The TransformComponent to update. target Vector3 The target to point towards smooth float Value between 0 and 1 indicating the weight of target orientation. The default is 1. Remarks This method updates the LocalMatrix and WorldMatrix after transformation. Exceptions ArgumentNullException If transform is null. ArgumentException If transform has UseTRS set to null. LookAt(TransformComponent, ref Vector3, ref Vector3, float) Sets the transforms rotation so it's forward vector points at the target. public static void LookAt(this TransformComponent transform, ref Vector3 target, ref Vector3 worldUp, float smooth = 1) Parameters transform TransformComponent The TransformComponent to update. target Vector3 The target to point towards worldUp Vector3 A Vector specifying the upward direction. smooth float Value between 0 and 1 indicating the weight of target orientation. The default is 1. Remarks This method updates the LocalMatrix and WorldMatrix after transformation. Exceptions ArgumentNullException If transform is null. ArgumentException If transform has UseTRS set to null. LookAt(TransformComponent, ref Vector3, float) Sets the transforms rotation so it's forward vector points at the target. The world up vector use is defined by WorldUp. public static void LookAt(this TransformComponent transform, ref Vector3 target, float smooth = 1) Parameters transform TransformComponent The TransformComponent to update. target Vector3 The target to point towards smooth float Value between 0 and 1 indicating the weight of target orientation. The default is 1. Remarks This method updates the LocalMatrix and WorldMatrix after transformation. Exceptions ArgumentNullException If transform is null. ArgumentException If transform has UseTRS set to null. LookAt(TransformComponent, TransformComponent, Vector3, float) Sets the transforms rotation so it's forward vector points at the target. public static void LookAt(this TransformComponent transform, TransformComponent target, Vector3 worldUp, float smooth = 1) Parameters transform TransformComponent The TransformComponent to update. target TransformComponent The target to point towards worldUp Vector3 A Vector specifying the upward direction. smooth float Value between 0 and 1 indicating the weight of target orientation. The default is 1. Remarks This method updates the LocalMatrix and WorldMatrix after transformation. Exceptions ArgumentNullException If transform or target is null. ArgumentException If transform has UseTRS set to null. LookAt(TransformComponent, TransformComponent, ref Vector3, float) Sets the transforms rotation so it's forward vector points at the target. public static void LookAt(this TransformComponent transform, TransformComponent target, ref Vector3 worldUp, float smooth = 1) Parameters transform TransformComponent The TransformComponent to update. target TransformComponent The target to point towards worldUp Vector3 A Vector specifying the upward direction. smooth float Value between 0 and 1 indicating the weight of target orientation. The default is 1. Remarks This method updates the LocalMatrix and WorldMatrix after transformation. Exceptions ArgumentNullException If transform or target is null. ArgumentException If transform has UseTRS set to null. LookAt(TransformComponent, TransformComponent, float) Sets the transforms rotation so it's forward vector points at the target. The world up vector use is defined by WorldUp. public static void LookAt(this TransformComponent transform, TransformComponent target, float smooth = 1) Parameters transform TransformComponent The TransformComponent to update. target TransformComponent The target to point towards smooth float Value between 0 and 1 indicating the weight of target orientation. The default is 1. Remarks This method updates the LocalMatrix and WorldMatrix after transformation. Exceptions ArgumentNullException If transform or target is null. ArgumentException If transform has UseTRS set to null. Rotate(TransformComponent, Vector3, Space) Rotates the given TransformComponent by the specified eulerAngles in the coordinate space defined by relativeTo. public static void Rotate(this TransformComponent transform, Vector3 eulerAngles, Space relativeTo = Space.Self) Parameters transform TransformComponent The TransformComponent to update. eulerAngles Vector3 The euler angles in radians to rotate by. relativeTo Space The coordinate space to perform the rotation in. Remarks This method updates the LocalMatrix and WorldMatrix after transformation. Exceptions ArgumentNullException If transform is null. ArgumentException If transform has UseTRS set to null. Rotate(TransformComponent, ref Vector3, Space) Rotates the given TransformComponent by the specified eulerAngles in the coordinate space defined by relativeTo. public static void Rotate(this TransformComponent transform, ref Vector3 eulerAngles, Space relativeTo = Space.Self) Parameters transform TransformComponent The TransformComponent to update. eulerAngles Vector3 The euler angles in radians to rotate by. relativeTo Space The coordinate space to perform the rotation in. Remarks This method updates the LocalMatrix and WorldMatrix after transformation. Exceptions ArgumentNullException If transform is null. ArgumentException If transform has UseTRS set to null. TransformDirection(TransformComponent, Vector3) Performs a direction transformation using the given WorldMatrix. public static Vector3 TransformDirection(this TransformComponent transform, Vector3 direction) Parameters transform TransformComponent The transform to get the world matrix from. direction Vector3 The direction vector to transform. Returns Vector3 The transformed direction. Remarks This method does not update the WorldMatrix before performing the transformation. If the TransformComponent has been modified since the last frame you may need to call the UpdateWorldMatrix() method first. Exceptions ArgumentNullException If transform is null. TransformDirection(TransformComponent, ref Vector3, out Vector3) Performs a direction transformation using the given WorldMatrix. public static void TransformDirection(this TransformComponent transform, ref Vector3 direction, out Vector3 result) Parameters transform TransformComponent The transform to get the world matrix from. direction Vector3 The direction vector to transform. result Vector3 The transformed direction. Remarks This method does not update the WorldMatrix before performing the transformation. If the TransformComponent has been modified since the last frame you may need to call the UpdateWorldMatrix() method first. Exceptions ArgumentNullException If transform is null. TransformPosition(TransformComponent, Vector3) Performs a coordinate transformation using the given WorldMatrix. public static Vector3 TransformPosition(this TransformComponent transform, Vector3 position) Parameters transform TransformComponent The transform to get the world matrix from. position Vector3 The coordinate vector to transform. Returns Vector3 The transformed coordinate. Remarks This method does not update the WorldMatrix before performing the transformation. If the TransformComponent has been modified since the last frame you may need to call the UpdateWorldMatrix() method first. Exceptions ArgumentNullException If transform is null. TransformPosition(TransformComponent, ref Vector3, out Vector3) Performs a coordinate transformation using the given WorldMatrix. public static void TransformPosition(this TransformComponent transform, ref Vector3 position, out Vector3 result) Parameters transform TransformComponent The transform to get the world matrix from. position Vector3 The coordinate vector to transform. result Vector3 The transformed coordinate. Remarks This method does not update the WorldMatrix before performing the transformation. If the TransformComponent has been modified since the last frame you may need to call the UpdateWorldMatrix() method first. Exceptions ArgumentNullException If transform is null. TransformVector(TransformComponent, Vector3) Performs a normal transformation using the given WorldMatrix. public static Vector3 TransformVector(this TransformComponent transform, Vector3 vector) Parameters transform TransformComponent The transform to get the world matrix from. vector Vector3 The normal vector to transform. Returns Vector3 The transformed normal. Remarks This method does not update the WorldMatrix before performing the transformation. If the TransformComponent has been modified since the last frame you may need to call the UpdateWorldMatrix() method first. Exceptions ArgumentNullException If transform is null. TransformVector(TransformComponent, ref Vector3, out Vector3) Performs a normal transformation using the given WorldMatrix. public static void TransformVector(this TransformComponent transform, ref Vector3 vector, out Vector3 result) Parameters transform TransformComponent The transform to get the world matrix from. vector Vector3 The normal vector to transform. result Vector3 The transformed normal. Remarks This method does not update the WorldMatrix before performing the transformation. If the TransformComponent has been modified since the last frame you may need to call the UpdateWorldMatrix() method first. Exceptions ArgumentNullException If transform is null. Translate(TransformComponent, Vector3, Space) Moves the given TransformComponent position by the specified translation in the coordinate space defined by relativeTo. public static void Translate(this TransformComponent transform, Vector3 translation, Space relativeTo = Space.Self) Parameters transform TransformComponent The TransformComponent to update. translation Vector3 The translation vector to move by. relativeTo Space The coordinate space to perform the translation in. Remarks This method updates the LocalMatrix and WorldMatrix after transformation. Exceptions ArgumentNullException If transform is null. ArgumentException If transform has UseTRS set to null. Translate(TransformComponent, Vector3, TransformComponent) Moves the given TransformComponent position by the specified translation relative to the local coordinate space of another TransformComponent. public static void Translate(this TransformComponent transform, Vector3 translation, TransformComponent relativeTo) Parameters transform TransformComponent The TransformComponent to update. translation Vector3 The translation vector to move by. relativeTo TransformComponent The TransformComponent to perform the translation relative to. Remarks This method updates the LocalMatrix and WorldMatrix after transformation. Exceptions ArgumentNullException If transform or relativeTo is null. ArgumentException If transform has UseTRS set to null. Translate(TransformComponent, ref Vector3, Space) Moves the given TransformComponent position by the specified translation in the coordinate space defined by relativeTo. public static void Translate(this TransformComponent transform, ref Vector3 translation, Space relativeTo = Space.Self) Parameters transform TransformComponent The TransformComponent to update. translation Vector3 The translation vector to move by. relativeTo Space The coordinate space to perform the translation in. Remarks This method updates the LocalMatrix and WorldMatrix after transformation. Exceptions ArgumentNullException If transform is null. ArgumentException If transform has UseTRS set to null. Translate(TransformComponent, ref Vector3, TransformComponent) Moves the given TransformComponent position by the specified translation relative to the local coordinate space of another TransformComponent. public static void Translate(this TransformComponent transform, ref Vector3 translation, TransformComponent relativeTo) Parameters transform TransformComponent The TransformComponent to update. translation Vector3 The translation vector to move by. relativeTo TransformComponent The TransformComponent to perform the translation relative to. Remarks This method updates the LocalMatrix and WorldMatrix after transformation. Exceptions ArgumentNullException If transform or relativeTo is null. ArgumentException If transform has UseTRS set to null. UpdateTRSFromLocal(TransformComponent) Updates the Position, Rotation and Scale members of the given TransformComponent. public static void UpdateTRSFromLocal(this TransformComponent transform) Parameters transform TransformComponent The TransformComponent to update. Exceptions ArgumentNullException If transform is null."
  },
  "api/Stride.CommunityToolkit.Engine.html": {
    "href": "api/Stride.CommunityToolkit.Engine.html",
    "title": "Namespace Stride.CommunityToolkit.Engine | Stride Community Toolkit",
    "summary": "Namespace Stride.CommunityToolkit.Engine Classes AnimationComponentExtensions Provides extension methods for the AnimationComponent to enhance animation playback functionality. CameraComponentExtensions Provides a set of static methods for working with CameraComponent instances. CameraDefaults Provides default settings for camera initialization within a game or scene, including default positions, rotations, and the main camera name. EntityComponentCollectionExtensions Extension methods for IEnumerable<T> and IEnumerable<T>. EntityExtensions Provides extension methods for the Entity class to simplify common operations, such as adding camera controllers, gizmos, and retrieving or manipulating components. EntitySearchExtensions Provides extension methods for searching and retrieving EntityComponent instances within an Entity hierarchy. This class includes methods for performing breadth-first and depth-first searches to find components in children, descendants, and ancestors of an entity. GameDefaults Provides default values for the game project. GameExtensions Provides extension methods for the Game class to simplify common game setup tasks, such as adding cameras, lights, and ground entities, as well as configuring scenes and running the game with custom logic. ModelComponentExtensions Provides extension methods for the ModelComponent class, enabling additional functionality such as calculating model dimensions and extracting mesh data. PrefabExtensions Extension methods for Prefab. PrimitiveCreationOptions Provides options for creating a primitive entity, such as a cube, sphere, or other 3D object. These options allow customization of the entity's name, material, collider inclusion, and render group. SceneExtensions Provides extension methods for the Scene class to enhance camera-related functionality. ScriptComponentExtensions Provides extension methods for ScriptComponent to enhance interactions with game timing and cameras in the GraphicsCompositor. ScriptSystemExtensions Provides extension methods for the ScriptSystem to facilitate time-based operations, including delays and frame-based executions. These extensions are useful for managing time in game logic, such as delaying actions or executing logic over a period of time. TransformExtensions Extension methods for TransformComponent. Enums Space The coordinate space in which to operate."
  },
  "api/Stride.CommunityToolkit.Extensions.TextureCanvasExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Extensions.TextureCanvasExtensions.html",
    "title": "Class TextureCanvasExtensions | Stride Community Toolkit",
    "summary": "Class TextureCanvasExtensions Namespace Stride.CommunityToolkit.Extensions Assembly Stride.CommunityToolkit.dll Provides extension methods for creating instances of TextureCanvas. public static class TextureCanvasExtensions Inheritance object TextureCanvasExtensions Methods CreateTextureCanvas(IServiceRegistry, Size2?, PixelFormat) Creates a new instance of TextureCanvas using the specified IServiceRegistry. public static TextureCanvas CreateTextureCanvas(this IServiceRegistry services, Size2? size, PixelFormat pixelFormat = PixelFormat.R8G8B8A8_UNorm) Parameters services IServiceRegistry The service registry to use for creating the texture canvas. size Size2? The size of the texture canvas. If null, a default size will be used. pixelFormat PixelFormat The pixel format of the texture canvas. Default is R8G8B8A8_UNorm. Returns TextureCanvas A new instance of TextureCanvas. CreateTextureCanvas(IGame, Size2?, PixelFormat) Creates a new instance of TextureCanvas using the specified IGame. public static TextureCanvas CreateTextureCanvas(this IGame game, Size2? size, PixelFormat pixelFormat = PixelFormat.R8G8B8A8_UNorm) Parameters game IGame The game instance to use for creating the texture canvas. size Size2? The size of the texture canvas. If null, a default size will be used. pixelFormat PixelFormat The pixel format of the texture canvas. Default is R8G8B8A8_UNorm. Returns TextureCanvas A new instance of TextureCanvas. CreateTextureCanvas(RenderContext, Size2?, PixelFormat) Creates a new instance of TextureCanvas using the specified RenderContext. public static TextureCanvas CreateTextureCanvas(this RenderContext renderContext, Size2? size, PixelFormat pixelFormat = PixelFormat.R8G8B8A8_UNorm) Parameters renderContext RenderContext The render context to use for creating the texture canvas. size Size2? The size of the texture canvas. If null, a default size will be used. pixelFormat PixelFormat The pixel format of the texture canvas. Default is R8G8B8A8_UNorm. Returns TextureCanvas A new instance of TextureCanvas."
  },
  "api/Stride.CommunityToolkit.Extensions.TextureExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Extensions.TextureExtensions.html",
    "title": "Class TextureExtensions | Stride Community Toolkit",
    "summary": "Class TextureExtensions Namespace Stride.CommunityToolkit.Extensions Assembly Stride.CommunityToolkit.dll Provides extension methods for working with Texture objects. This includes methods for finding asset source directories, resizing textures, and reformatting textures. public static class TextureExtensions Inheritance object TextureExtensions Methods FindAssetSourceDir(string, string) Retrieves the full filename of the Source of an asset. workDir should be your Assets directory. public static string FindAssetSourceDir(string urlName, string workDir) Parameters urlName string workDir string Returns string ReFormat(Texture, GraphicsContext, PixelFormat) Reformats the pixels of a given texture via a rendering to texture approach. public static Texture? ReFormat(this Texture texture, GraphicsContext graphicsContext, PixelFormat pixelFormat = PixelFormat.R8G8B8A8_UNorm) Parameters texture Texture graphicsContext GraphicsContext pixelFormat PixelFormat Returns Texture Resize(Texture, int, int, GraphicsContext, PixelFormat) Resizes and reformats a given texture by rendering it to a new texture with the specified dimensions and pixel format. This is useful for processing textures loaded through Content.Load<Texture>(), which may be compressed and default to a smaller size like 32x32 pixels. To properly resize a compressed texture, ensure it's decompressed by loading the source file from disk before applying this method. public static Texture? Resize(this Texture texture, int width, int height, GraphicsContext graphicsContext, PixelFormat pixelFormat = PixelFormat.R8G8B8A8_UNorm) Parameters texture Texture The original texture to resize. width int The desired width of the resized texture. height int The desired height of the resized texture. graphicsContext GraphicsContext The graphics context to use for rendering. pixelFormat PixelFormat The pixel format for the resized texture (default is PixelFormat.R8G8B8A8_UNorm). Returns Texture A new texture with the specified width, height, and pixel format, or null if the operation fails or the original texture has invalid dimensions."
  },
  "api/Stride.CommunityToolkit.Extensions.html": {
    "href": "api/Stride.CommunityToolkit.Extensions.html",
    "title": "Namespace Stride.CommunityToolkit.Extensions | Stride Community Toolkit",
    "summary": "Namespace Stride.CommunityToolkit.Extensions Classes TextureCanvasExtensions Provides extension methods for creating instances of TextureCanvas. TextureExtensions Provides extension methods for working with Texture objects. This includes methods for finding asset source directories, resizing textures, and reformatting textures."
  },
  "api/Stride.CommunityToolkit.Games.GameExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Games.GameExtensions.html",
    "title": "Class GameExtensions | Stride Community Toolkit",
    "summary": "Class GameExtensions Namespace Stride.CommunityToolkit.Games Assembly Stride.CommunityToolkit.dll Provides extension methods for the IGame interface, enhancing game management and performance tuning functionality. public static class GameExtensions Inheritance object GameExtensions Remarks These methods offer additional control over the game's timing, frame rate, and vertical synchronization, allowing for both performance optimization and flexibility. Methods DeltaTime(IGame) Gets the time elapsed since the last game update in seconds as a single-precision floating-point number. public static float DeltaTime(this IGame game) Parameters game IGame The IGame interface providing access to game timing information. Returns float The time elapsed since the last game update in seconds. Exceptions ArgumentNullException Thrown if the game is null. DeltaTimeAccurate(IGame) Gets the time elapsed since the last game update in seconds as a double-precision floating-point number. public static double DeltaTimeAccurate(this IGame game) Parameters game IGame The IGame interface providing access to game timing information. Returns double The time elapsed since the last game update in seconds with double precision. Exceptions ArgumentNullException Thrown if the game is null. DisableVSync(IGame) Disables vertical synchronization (VSync) to allow for uncapped frame rates, potentially increasing performance at the cost of possible screen tearing. public static void DisableVSync(this IGame game) Parameters game IGame The IGame instance on which to disable VSync. EnableVSync(IGame) Enables vertical synchronization (VSync) to prevent screen tearing by synchronizing the frame rate with the display's refresh rate. public static void EnableVSync(this IGame game) Parameters game IGame The IGame instance on which to enable VSync. Exit(IGame) Exits the game if it inherits from GameBase; otherwise, throws an exception. public static void Exit(this IGame game) Parameters game IGame The game to exit. Exceptions ArgumentNullException Thrown if the game is null. ArgumentException Thrown if the game does not inherit from GameBase. FPS(IGame) Retrieves the current frames per second (FPS) rate of the running game. public static float FPS(this IGame game) Parameters game IGame The IGame instance from which to obtain the FPS rate. Returns float The current FPS rate of the game. SetFocusLostFPS(IGame, int) Sets the maximum frames per second (FPS) rate for the game when not in focus. Set targetFPS to 0 for uncapped FPS. public static void SetFocusLostFPS(this IGame game, int targetFPS) Parameters game IGame The IGame instance on which to set the FPS limit. targetFPS int The target FPS rate. Set to 0 for uncapped FPS. SetMaxFPS(IGame, int) Sets the maximum frames per second (FPS) rate for the game. Set targetFPS to 0 for uncapped FPS. public static void SetMaxFPS(this IGame game, int targetFPS) Parameters game IGame The IGame instance on which to set the FPS limit. targetFPS int The target FPS rate. Set to 0 for uncapped FPS."
  },
  "api/Stride.CommunityToolkit.Games.html": {
    "href": "api/Stride.CommunityToolkit.Games.html",
    "title": "Namespace Stride.CommunityToolkit.Games | Stride Community Toolkit",
    "summary": "Namespace Stride.CommunityToolkit.Games Classes GameExtensions Provides extension methods for the IGame interface, enhancing game management and performance tuning functionality."
  },
  "api/Stride.CommunityToolkit.Graphics.GraphicsDeviceExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Graphics.GraphicsDeviceExtensions.html",
    "title": "Class GraphicsDeviceExtensions | Stride Community Toolkit",
    "summary": "Class GraphicsDeviceExtensions Namespace Stride.CommunityToolkit.Graphics Assembly Stride.CommunityToolkit.dll Provides extension methods for the GraphicsDevice to simplify common operations related to graphics rendering. public static class GraphicsDeviceExtensions Inheritance object GraphicsDeviceExtensions Methods GetWindowSize(GraphicsDevice) Retrieves the current window size of the GraphicsDevice as an Int2 structure. public static Int2 GetWindowSize(this GraphicsDevice graphics) Parameters graphics GraphicsDevice The GraphicsDevice for which the window size should be retrieved. Returns Int2 An Int2 representing the current window size. The X value corresponds to the window's width, and the Y value corresponds to the window's height. Remarks This method provides a convenient way to access the dimensions of the back buffer, which corresponds to the size of the window in which the game or application is running."
  },
  "api/Stride.CommunityToolkit.Graphics.html": {
    "href": "api/Stride.CommunityToolkit.Graphics.html",
    "title": "Namespace Stride.CommunityToolkit.Graphics | Stride Community Toolkit",
    "summary": "Namespace Stride.CommunityToolkit.Graphics Classes GraphicsDeviceExtensions Provides extension methods for the GraphicsDevice to simplify common operations related to graphics rendering."
  },
  "api/Stride.CommunityToolkit.Helpers.VectorHelper.html": {
    "href": "api/Stride.CommunityToolkit.Helpers.VectorHelper.html",
    "title": "Class VectorHelper | Stride Community Toolkit",
    "summary": "Class VectorHelper Namespace Stride.CommunityToolkit.Helpers Assembly Stride.CommunityToolkit.dll Provides helper methods for generating and manipulating Vector3 objects. public static class VectorHelper Inheritance object VectorHelper Remarks This class contains utility methods designed to assist with common tasks involving vectors, such as generating random Vector3 values within a specified range. Methods RandomVector3(float, float, Random?) Generates a random Vector3 with each component (X, Y, Z) within the given range. By default, min is 0 and max is required. public static Vector3 RandomVector3(float max, float min = 0, Random? random = null) Parameters max float The maximum value for X, Y, and Z components. min float The minimum value for X, Y, and Z components. Default is 0. random Random Optional random instance for custom seeding or performance. Returns Vector3 A random Vector3. RandomVector3(float[], float[], float[], Random?) Generates a random Vector3 with each component (X, Y, Z) based on the provided ranges. public static Vector3 RandomVector3(float[] xRange, float[] yRange, float[] zRange, Random? random = null) Parameters xRange float[] Array containing [minX, maxX] values for X component. yRange float[] Array containing [minY, maxY] values for Y component. zRange float[] Array containing [minZ, maxZ] values for Z component. random Random Optional random instance for custom seeding or performance. Returns Vector3 A random Vector3. SeedRandom(int) Optionally re-seeds the default random generator for the application. public static void SeedRandom(int seed) Parameters seed int"
  },
  "api/Stride.CommunityToolkit.Helpers.html": {
    "href": "api/Stride.CommunityToolkit.Helpers.html",
    "title": "Namespace Stride.CommunityToolkit.Helpers | Stride Community Toolkit",
    "summary": "Namespace Stride.CommunityToolkit.Helpers Classes VectorHelper Provides helper methods for generating and manipulating Vector3 objects."
  },
  "api/Stride.CommunityToolkit.ImGui.BaseWindow.html": {
    "href": "api/Stride.CommunityToolkit.ImGui.BaseWindow.html",
    "title": "Class BaseWindow | Stride Community Toolkit",
    "summary": "Class BaseWindow Namespace Stride.CommunityToolkit.ImGui Assembly Stride.CommunityToolkit.ImGui.dll public abstract class BaseWindow : GameSystem, IDisposable, ICollectorHolder, IGameSystemBase, IComponent, IReferencable, IUpdateable, IDrawable, IContentable Inheritance object DisposeBase ComponentBase GameSystemBase GameSystem BaseWindow Implements IDisposable ICollectorHolder IGameSystemBase IComponent IReferencable IUpdateable IDrawable IContentable Derived HierarchyView Inspector PerfMonitor Inherited Members GameSystem.Game GameSystemBase.BeginDraw() GameSystemBase.Draw(GameTime) GameSystemBase.EndDraw() GameSystemBase.Initialize() GameSystemBase.InitGraphicsDeviceService() GameSystemBase.OnDrawOrderChanged(object, EventArgs) GameSystemBase.OnUpdateOrderChanged(object, EventArgs) GameSystemBase.LoadContent() GameSystemBase.UnloadContent() GameSystemBase.Services GameSystemBase.Content GameSystemBase.GraphicsDevice GameSystemBase.Visible GameSystemBase.DrawOrder GameSystemBase.Enabled GameSystemBase.UpdateOrder GameSystemBase.DrawOrderChanged GameSystemBase.VisibleChanged GameSystemBase.EnabledChanged GameSystemBase.UpdateOrderChanged ComponentBase.Tags ComponentBase.OnNameChanged() ComponentBase.ToString() ComponentBase.Name DisposeBase.Dispose() DisposeBase.OnAddReference() DisposeBase.OnReleaseReference() DisposeBase.IsDisposed Constructors BaseWindow(IServiceRegistry) protected BaseWindow(IServiceRegistry services) Parameters services IServiceRegistry Fields Id protected uint Id Field Value uint Open protected bool Open Field Value bool Properties Scale public float Scale { get; } Property Value float WindowFlags protected virtual ImGuiWindowFlags WindowFlags { get; } Property Value ImGuiWindowFlags WindowPos protected virtual Vector2? WindowPos { get; } Property Value Vector2? WindowSize protected virtual Vector2? WindowSize { get; } Property Value Vector2? Methods Destroy() Disposes of object resources. protected override void Destroy() OnDestroy() protected abstract void OnDestroy() OnDraw(bool) protected abstract void OnDraw(bool collapsed) Parameters collapsed bool Update(GameTime) This method is called when this game component is updated. public override void Update(GameTime gameTime) Parameters gameTime GameTime The current timing."
  },
  "api/Stride.CommunityToolkit.ImGui.HierarchyView.html": {
    "href": "api/Stride.CommunityToolkit.ImGui.HierarchyView.html",
    "title": "Class HierarchyView | Stride Community Toolkit",
    "summary": "Class HierarchyView Namespace Stride.CommunityToolkit.ImGui Assembly Stride.CommunityToolkit.ImGui.dll public class HierarchyView : BaseWindow, IDisposable, ICollectorHolder, IGameSystemBase, IComponent, IReferencable, IUpdateable, IDrawable, IContentable Inheritance object DisposeBase ComponentBase GameSystemBase GameSystem BaseWindow HierarchyView Implements IDisposable ICollectorHolder IGameSystemBase IComponent IReferencable IUpdateable IDrawable IContentable Inherited Members BaseWindow.Scale BaseWindow.Open BaseWindow.Id BaseWindow.WindowFlags BaseWindow.WindowPos BaseWindow.WindowSize BaseWindow.Update(GameTime) BaseWindow.Destroy() GameSystem.Game GameSystemBase.BeginDraw() GameSystemBase.Draw(GameTime) GameSystemBase.EndDraw() GameSystemBase.Initialize() GameSystemBase.InitGraphicsDeviceService() GameSystemBase.OnDrawOrderChanged(object, EventArgs) GameSystemBase.OnUpdateOrderChanged(object, EventArgs) GameSystemBase.LoadContent() GameSystemBase.UnloadContent() GameSystemBase.Services GameSystemBase.Content GameSystemBase.GraphicsDevice GameSystemBase.Visible GameSystemBase.DrawOrder GameSystemBase.Enabled GameSystemBase.UpdateOrder GameSystemBase.DrawOrderChanged GameSystemBase.VisibleChanged GameSystemBase.EnabledChanged GameSystemBase.UpdateOrderChanged ComponentBase.Tags ComponentBase.OnNameChanged() ComponentBase.ToString() ComponentBase.Name DisposeBase.Dispose() DisposeBase.OnAddReference() DisposeBase.OnReleaseReference() DisposeBase.IsDisposed Constructors HierarchyView(IServiceRegistry) public HierarchyView(IServiceRegistry service) Parameters service IServiceRegistry Methods OnDestroy() protected override void OnDestroy() OnDraw(bool) protected override void OnDraw(bool collapsed) Parameters collapsed bool"
  },
  "api/Stride.CommunityToolkit.ImGui.ImGuiExtension.DisposableImGui.html": {
    "href": "api/Stride.CommunityToolkit.ImGui.ImGuiExtension.DisposableImGui.html",
    "title": "Struct ImGuiExtension.DisposableImGui | Stride Community Toolkit",
    "summary": "Struct ImGuiExtension.DisposableImGui Namespace Stride.CommunityToolkit.ImGui Assembly Stride.CommunityToolkit.ImGui.dll public struct ImGuiExtension.DisposableImGui : IDisposable Implements IDisposable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() Constructors DisposableImGui(bool, DisposableTypes) public DisposableImGui(bool dispose, ImGuiExtension.DisposableTypes type) Parameters dispose bool type ImGuiExtension.DisposableTypes Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose()"
  },
  "api/Stride.CommunityToolkit.ImGui.ImGuiExtension.DisposableImGuiIndent.html": {
    "href": "api/Stride.CommunityToolkit.ImGui.ImGuiExtension.DisposableImGuiIndent.html",
    "title": "Struct ImGuiExtension.DisposableImGuiIndent | Stride Community Toolkit",
    "summary": "Struct ImGuiExtension.DisposableImGuiIndent Namespace Stride.CommunityToolkit.ImGui Assembly Stride.CommunityToolkit.ImGui.dll public struct ImGuiExtension.DisposableImGuiIndent : IDisposable Implements IDisposable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() Constructors DisposableImGuiIndent(float) public DisposableImGuiIndent(float size = 0) Parameters size float Methods Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose()"
  },
  "api/Stride.CommunityToolkit.ImGui.ImGuiExtension.DisposableTypes.html": {
    "href": "api/Stride.CommunityToolkit.ImGui.ImGuiExtension.DisposableTypes.html",
    "title": "Enum ImGuiExtension.DisposableTypes | Stride Community Toolkit",
    "summary": "Enum ImGuiExtension.DisposableTypes Namespace Stride.CommunityToolkit.ImGui Assembly Stride.CommunityToolkit.ImGui.dll public enum ImGuiExtension.DisposableTypes Fields Child = 2 Columns = 5 Combo = 6 ID = 7 Menu = 0 MenuBar = 1 Tooltip = 4 Window = 3"
  },
  "api/Stride.CommunityToolkit.ImGui.ImGuiExtension.html": {
    "href": "api/Stride.CommunityToolkit.ImGui.ImGuiExtension.html",
    "title": "Class ImGuiExtension | Stride Community Toolkit",
    "summary": "Class ImGuiExtension Namespace Stride.CommunityToolkit.ImGui Assembly Stride.CommunityToolkit.ImGui.dll public class ImGuiExtension Inheritance object ImGuiExtension Methods Child(int, Vector2, ImGuiChildFlags, ImGuiWindowFlags) public static ImGuiExtension.DisposableImGui Child(int cln = 0, Vector2 size = default, ImGuiChildFlags childFlags = ImGuiChildFlags.None, ImGuiWindowFlags flags = ImGuiWindowFlags.None) Parameters cln int size Vector2 childFlags ImGuiChildFlags flags ImGuiWindowFlags Returns ImGuiExtension.DisposableImGui ColorPicker3(string, ref Color3) public static bool ColorPicker3(string label, ref Color3 color) Parameters label string color Color3 Returns bool ID(int) public static ImGuiExtension.DisposableImGui ID(int id) Parameters id int Returns ImGuiExtension.DisposableImGui ID(string) public static ImGuiExtension.DisposableImGui ID(string id) Parameters id string Returns ImGuiExtension.DisposableImGui Image(Texture) Adds a texture to the ImGui element with the Texture width and height public static void Image(Texture texture) Parameters texture Texture Image(Texture, int, int) Adds a texture to the ImGui element with a custom width and height public static void Image(Texture texture, int width, int height) Parameters texture Texture width int height int ImageButton(string, Texture) Adds a texture to the ImGui element button with the Texture width and height public static bool ImageButton(string text, Texture texture) Parameters text string texture Texture Returns bool ImageButton(string, Texture, int, int) Adds a texture to the ImGui element button with a custom width and height public static bool ImageButton(string strid, Texture texture, int width, int height) Parameters strid string texture Texture width int height int Returns bool Menu(string, out bool, bool) public static ImGuiExtension.DisposableImGui Menu(string label, out bool open, bool enabled = true) Parameters label string open bool enabled bool Returns ImGuiExtension.DisposableImGui MenuBar(out bool) public static ImGuiExtension.DisposableImGui MenuBar(out bool open) Parameters open bool Returns ImGuiExtension.DisposableImGui PlotLines(string, ref float, int, int, string, float, float, Vector2, int) public static void PlotLines(string label, ref float values, int count, int offset = 0, string overlay = null, float valueMin = 3.4028235E+38, float valueMax = 3.4028235E+38, Vector2 size = default, int stride = 4) Parameters label string values float count int offset int overlay string valueMin float valueMax float size Vector2 stride int Tooltip() public static ImGuiExtension.DisposableImGui Tooltip() Returns ImGuiExtension.DisposableImGui UColumns(int, string, bool) public static ImGuiExtension.DisposableImGui UColumns(int count, string id = null, bool border = false) Parameters count int id string border bool Returns ImGuiExtension.DisposableImGui UCombo(string, string, out bool, ImGuiComboFlags) public static ImGuiExtension.DisposableImGui UCombo(string label, string previewValue, out bool open, ImGuiComboFlags flags = ImGuiComboFlags.None) Parameters label string previewValue string open bool flags ImGuiComboFlags Returns ImGuiExtension.DisposableImGui UIndent(float) public static ImGuiExtension.DisposableImGuiIndent UIndent(float size = 0) Parameters size float Returns ImGuiExtension.DisposableImGuiIndent Window(string, ref bool, out bool, ImGuiWindowFlags) public static ImGuiExtension.DisposableImGui Window(string name, ref bool open, out bool collapsed, ImGuiWindowFlags flags = ImGuiWindowFlags.None) Parameters name string open bool collapsed bool flags ImGuiWindowFlags Returns ImGuiExtension.DisposableImGui"
  },
  "api/Stride.CommunityToolkit.ImGui.ImGuiSystem.html": {
    "href": "api/Stride.CommunityToolkit.ImGui.ImGuiSystem.html",
    "title": "Class ImGuiSystem | Stride Community Toolkit",
    "summary": "Class ImGuiSystem Namespace Stride.CommunityToolkit.ImGui Assembly Stride.CommunityToolkit.ImGui.dll public class ImGuiSystem : GameSystemBase, IDisposable, ICollectorHolder, IGameSystemBase, IComponent, IReferencable, IUpdateable, IDrawable, IContentable Inheritance object DisposeBase ComponentBase GameSystemBase ImGuiSystem Implements IDisposable ICollectorHolder IGameSystemBase IComponent IReferencable IUpdateable IDrawable IContentable Inherited Members GameSystemBase.BeginDraw() GameSystemBase.Draw(GameTime) GameSystemBase.Initialize() GameSystemBase.InitGraphicsDeviceService() GameSystemBase.OnDrawOrderChanged(object, EventArgs) GameSystemBase.OnUpdateOrderChanged(object, EventArgs) GameSystemBase.LoadContent() GameSystemBase.UnloadContent() GameSystemBase.Game GameSystemBase.Services GameSystemBase.Content GameSystemBase.GraphicsDevice GameSystemBase.Visible GameSystemBase.DrawOrder GameSystemBase.Enabled GameSystemBase.UpdateOrder GameSystemBase.DrawOrderChanged GameSystemBase.VisibleChanged GameSystemBase.EnabledChanged GameSystemBase.UpdateOrderChanged ComponentBase.Tags ComponentBase.OnNameChanged() ComponentBase.ToString() ComponentBase.Name DisposeBase.Dispose() DisposeBase.OnAddReference() DisposeBase.OnReleaseReference() DisposeBase.IsDisposed Constructors ImGuiSystem(IServiceRegistry, GraphicsDeviceManager, InputManager) public ImGuiSystem(IServiceRegistry registry, GraphicsDeviceManager graphicsDeviceManager, InputManager inputManager = null) Parameters registry IServiceRegistry graphicsDeviceManager GraphicsDeviceManager inputManager InputManager Fields ImGuiContext public readonly ImGuiContextPtr ImGuiContext Field Value ImGuiContextPtr Properties Scale public float Scale { get; set; } Property Value float Methods Destroy() Disposes of object resources. protected override void Destroy() EndDraw() Ends the drawing of a frame. This method is preceeded by calls to Draw and BeginDraw. public override void EndDraw() Update(GameTime) This method is called when this game component is updated. public override void Update(GameTime gameTime) Parameters gameTime GameTime The current timing."
  },
  "api/Stride.CommunityToolkit.ImGui.Inspector.Filter.html": {
    "href": "api/Stride.CommunityToolkit.ImGui.Inspector.Filter.html",
    "title": "Enum Inspector.Filter | Stride Community Toolkit",
    "summary": "Enum Inspector.Filter Namespace Stride.CommunityToolkit.ImGui Assembly Stride.CommunityToolkit.ImGui.dll [Flags] public enum Inspector.Filter : uint Fields Fields = 1 Inherited = 128 Instance = 64 NonPublic = 16 Properties = 2 Public = 8 Static = 32 SubTypes = 4"
  },
  "api/Stride.CommunityToolkit.ImGui.Inspector.ValueHandler.html": {
    "href": "api/Stride.CommunityToolkit.ImGui.Inspector.ValueHandler.html",
    "title": "Delegate Inspector.ValueHandler | Stride Community Toolkit",
    "summary": "Delegate Inspector.ValueHandler Namespace Stride.CommunityToolkit.ImGui Assembly Stride.CommunityToolkit.ImGui.dll A UI handler function to draw and modify values public delegate bool Inspector.ValueHandler(string label, ref object value) Parameters label string A UI handler function to draw and modify values value object A UI handler function to draw and modify values Returns bool A UI handler function to draw and modify values"
  },
  "api/Stride.CommunityToolkit.ImGui.Inspector.html": {
    "href": "api/Stride.CommunityToolkit.ImGui.Inspector.html",
    "title": "Class Inspector | Stride Community Toolkit",
    "summary": "Class Inspector Namespace Stride.CommunityToolkit.ImGui Assembly Stride.CommunityToolkit.ImGui.dll public class Inspector : BaseWindow, IDisposable, ICollectorHolder, IGameSystemBase, IComponent, IReferencable, IUpdateable, IDrawable, IContentable Inheritance object DisposeBase ComponentBase GameSystemBase GameSystem BaseWindow Inspector Implements IDisposable ICollectorHolder IGameSystemBase IComponent IReferencable IUpdateable IDrawable IContentable Inherited Members BaseWindow.Scale BaseWindow.Open BaseWindow.Id BaseWindow.WindowFlags BaseWindow.WindowPos BaseWindow.WindowSize BaseWindow.Update(GameTime) BaseWindow.Destroy() GameSystem.Game GameSystemBase.BeginDraw() GameSystemBase.Draw(GameTime) GameSystemBase.EndDraw() GameSystemBase.Initialize() GameSystemBase.InitGraphicsDeviceService() GameSystemBase.OnDrawOrderChanged(object, EventArgs) GameSystemBase.OnUpdateOrderChanged(object, EventArgs) GameSystemBase.LoadContent() GameSystemBase.UnloadContent() GameSystemBase.Services GameSystemBase.Content GameSystemBase.GraphicsDevice GameSystemBase.Visible GameSystemBase.DrawOrder GameSystemBase.Enabled GameSystemBase.UpdateOrder GameSystemBase.DrawOrderChanged GameSystemBase.VisibleChanged GameSystemBase.EnabledChanged GameSystemBase.UpdateOrderChanged ComponentBase.Tags ComponentBase.OnNameChanged() ComponentBase.ToString() ComponentBase.Name DisposeBase.Dispose() DisposeBase.OnAddReference() DisposeBase.OnReleaseReference() DisposeBase.IsDisposed Constructors Inspector(IServiceRegistry) public Inspector(IServiceRegistry services) Parameters services IServiceRegistry Fields EnumerableView Show specialized interface to handle IEnumerable types public bool EnumerableView Field Value bool Locked Is this interface returned by FindFreeInspector(IServiceRegistry) public bool Locked Field Value bool TypeAsStatic For Target of type Type, return the content of 'static type.' instead of 'typeof(type).' public bool TypeAsStatic Field Value bool ValueDrawingHandlers Add your drawing functions to explicitly override drawing for objects of the given type public static ConcurrentDictionary<Type, Inspector.ValueHandler> ValueDrawingHandlers Field Value ConcurrentDictionary<Type, Inspector.ValueHandler> Properties MemberFilter Members shown within the interface public Inspector.Filter MemberFilter { get; set; } Property Value Inspector.Filter Target The object to inspect public object Target { get; set; } Property Value object Methods FindFreeInspector(IServiceRegistry) public static Inspector FindFreeInspector(IServiceRegistry services) Parameters services IServiceRegistry Returns Inspector OnDestroy() protected override void OnDestroy() OnDraw(bool) protected override void OnDraw(bool collapsed) Parameters collapsed bool"
  },
  "api/Stride.CommunityToolkit.ImGui.LightweightTimer.html": {
    "href": "api/Stride.CommunityToolkit.ImGui.LightweightTimer.html",
    "title": "Struct LightweightTimer | Stride Community Toolkit",
    "summary": "Struct LightweightTimer Namespace Stride.CommunityToolkit.ImGui Assembly Stride.CommunityToolkit.ImGui.dll public struct LightweightTimer Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() Properties Elapsed public TimeSpan Elapsed { get; } Property Value TimeSpan InitTime public TimeSpan InitTime { get; } Property Value TimeSpan Methods Restart() Use this function and its return value when inside a loop instead of Elapsed as it guarantees that no time will be discarded public TimeSpan Restart() Returns TimeSpan Start() public void Start() StartNew() public static LightweightTimer StartNew() Returns LightweightTimer"
  },
  "api/Stride.CommunityToolkit.ImGui.PerfMonitor.PerfSampler.html": {
    "href": "api/Stride.CommunityToolkit.ImGui.PerfMonitor.PerfSampler.html",
    "title": "Struct PerfMonitor.PerfSampler | Stride Community Toolkit",
    "summary": "Struct PerfMonitor.PerfSampler Namespace Stride.CommunityToolkit.ImGui Assembly Stride.CommunityToolkit.ImGui.dll Put this within a using statement to log performance of the code within it. Creates a new PerfMonitor.SampleInstance for the attached PerfMonitor once PerfSampler(string, PerfMonitor, int) and Dispose() have been called. The duration sent to the PerfMonitor will be the one between those calls. public readonly struct PerfMonitor.PerfSampler : IDisposable Implements IDisposable Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() Constructors PerfSampler(string, PerfMonitor, int) public PerfSampler(string id, PerfMonitor monitor, int customDepthParam = -1) Parameters id string monitor PerfMonitor customDepthParam int Methods Dispose() Dispose of it to log it to the PerfMonitor public void Dispose()"
  },
  "api/Stride.CommunityToolkit.ImGui.PerfMonitor.html": {
    "href": "api/Stride.CommunityToolkit.ImGui.PerfMonitor.html",
    "title": "Class PerfMonitor | Stride Community Toolkit",
    "summary": "Class PerfMonitor Namespace Stride.CommunityToolkit.ImGui Assembly Stride.CommunityToolkit.ImGui.dll public class PerfMonitor : BaseWindow, IDisposable, ICollectorHolder, IGameSystemBase, IComponent, IReferencable, IUpdateable, IDrawable, IContentable Inheritance object DisposeBase ComponentBase GameSystemBase GameSystem BaseWindow PerfMonitor Implements IDisposable ICollectorHolder IGameSystemBase IComponent IReferencable IUpdateable IDrawable IContentable Inherited Members BaseWindow.Scale BaseWindow.Open BaseWindow.Id BaseWindow.Destroy() GameSystem.Game GameSystemBase.BeginDraw() GameSystemBase.Draw(GameTime) GameSystemBase.Initialize() GameSystemBase.InitGraphicsDeviceService() GameSystemBase.OnDrawOrderChanged(object, EventArgs) GameSystemBase.OnUpdateOrderChanged(object, EventArgs) GameSystemBase.LoadContent() GameSystemBase.UnloadContent() GameSystemBase.Services GameSystemBase.Content GameSystemBase.GraphicsDevice GameSystemBase.Visible GameSystemBase.DrawOrder GameSystemBase.Enabled GameSystemBase.UpdateOrder GameSystemBase.DrawOrderChanged GameSystemBase.VisibleChanged GameSystemBase.EnabledChanged GameSystemBase.UpdateOrderChanged ComponentBase.Tags ComponentBase.OnNameChanged() ComponentBase.ToString() ComponentBase.Name DisposeBase.Dispose() DisposeBase.OnAddReference() DisposeBase.OnReleaseReference() DisposeBase.IsDisposed Constructors PerfMonitor(IServiceRegistry) public PerfMonitor(IServiceRegistry services) Parameters services IServiceRegistry Fields FrameHeight public float FrameHeight Field Value float GraphHeight public float GraphHeight Field Value float MonitorSampleAlloc public bool MonitorSampleAlloc Field Value bool PauseEval public bool PauseEval Field Value bool PauseOnLargeDelta public bool PauseOnLargeDelta Field Value bool Properties WindowFlags protected override ImGuiWindowFlags WindowFlags { get; } Property Value ImGuiWindowFlags WindowPos protected override Vector2? WindowPos { get; } Property Value Vector2? WindowSize protected override Vector2? WindowSize { get; } Property Value Vector2? Methods EndDraw() Ends the drawing of a frame. This method is preceeded by calls to Draw and BeginDraw. public override void EndDraw() OnDestroy() protected override void OnDestroy() OnDraw(bool) protected override void OnDraw(bool collapsed) Parameters collapsed bool Sample(bool, int, string, string) Place within a using statement to monitor the code within it. Creates a string each call which will produces unneeded garbage, see Sample(string, bool) for alloc less version. public PerfMonitor.PerfSampler Sample(bool sample = true, int line = 0, string member = null, string filePath = null) Parameters sample bool line int member string filePath string Returns PerfMonitor.PerfSampler Sample(string, bool) Place within a using statement to monitor the code within it public PerfMonitor.PerfSampler Sample(string id, bool sample = true) Parameters id string sample bool Returns PerfMonitor.PerfSampler SetGraphSize(int, bool) public void SetGraphSize(int newSize, bool force = false) Parameters newSize int force bool Update(GameTime) This method is called when this game component is updated. public override void Update(GameTime gameTime) Parameters gameTime GameTime The current timing."
  },
  "api/Stride.CommunityToolkit.ImGui.XMLDocumentation.CachedDocumentation.html": {
    "href": "api/Stride.CommunityToolkit.ImGui.XMLDocumentation.CachedDocumentation.html",
    "title": "Class XMLDocumentation.CachedDocumentation | Stride Community Toolkit",
    "summary": "Class XMLDocumentation.CachedDocumentation Namespace Stride.CommunityToolkit.ImGui Assembly Stride.CommunityToolkit.ImGui.dll public class XMLDocumentation.CachedDocumentation Inheritance object XMLDocumentation.CachedDocumentation Constructors CachedDocumentation(XmlElement) public CachedDocumentation(XmlElement elem) Parameters elem XmlElement Properties CleanSummary public string CleanSummary { get; } Property Value string Element public XmlElement Element { get; } Property Value XmlElement"
  },
  "api/Stride.CommunityToolkit.ImGui.XMLDocumentation.html": {
    "href": "api/Stride.CommunityToolkit.ImGui.XMLDocumentation.html",
    "title": "Class XMLDocumentation | Stride Community Toolkit",
    "summary": "Class XMLDocumentation Namespace Stride.CommunityToolkit.ImGui Assembly Stride.CommunityToolkit.ImGui.dll Utility class to provide documentation for various types where available with the assembly public static class XMLDocumentation Inheritance object XMLDocumentation Methods TryGetDocumentation(MemberInfo, out XmlElement) Returns false if the documentation file wasn't found public static bool TryGetDocumentation(MemberInfo member, out XmlElement elementOut) Parameters member MemberInfo elementOut XmlElement Returns bool TryGetSummary(MemberInfo, out string) Returns false if the documentation file wasn't found public static bool TryGetSummary(MemberInfo member, out string summary) Parameters member MemberInfo summary string Returns bool"
  },
  "api/Stride.CommunityToolkit.ImGui.html": {
    "href": "api/Stride.CommunityToolkit.ImGui.html",
    "title": "Namespace Stride.CommunityToolkit.ImGui | Stride Community Toolkit",
    "summary": "Namespace Stride.CommunityToolkit.ImGui Classes BaseWindow HierarchyView ImGuiExtension ImGuiSystem Inspector PerfMonitor XMLDocumentation Utility class to provide documentation for various types where available with the assembly XMLDocumentation.CachedDocumentation Structs ImGuiExtension.DisposableImGui ImGuiExtension.DisposableImGuiIndent LightweightTimer PerfMonitor.PerfSampler Put this within a using statement to log performance of the code within it. Creates a new PerfMonitor.SampleInstance for the attached PerfMonitor once PerfSampler(string, PerfMonitor, int) and Dispose() have been called. The duration sent to the PerfMonitor will be the one between those calls. Enums ImGuiExtension.DisposableTypes Inspector.Filter Delegates Inspector.ValueHandler A UI handler function to draw and modify values"
  },
  "api/Stride.CommunityToolkit.Mathematics.Easing.html": {
    "href": "api/Stride.CommunityToolkit.Mathematics.Easing.html",
    "title": "Class Easing | Stride Community Toolkit",
    "summary": "Class Easing Namespace Stride.CommunityToolkit.Mathematics Assembly Stride.CommunityToolkit.dll A collection of easing functions. public static class Easing Inheritance object Easing Methods BackEaseIn(double) public static double BackEaseIn(double amount) Parameters amount double Returns double Remarks Modeled after the overshooting cubic y = x^3-xsin(xpi) BackEaseIn(float) public static float BackEaseIn(float amount) Parameters amount float Returns float Remarks Modeled after the overshooting cubic y = x^3-xsin(xpi) BackEaseInOut(double) public static double BackEaseInOut(double amount) Parameters amount double Returns double Remarks Modeled after the piecewise overshooting cubic function: y = (1/2)((2x)^3-(2x)sin(2xpi)) ; [0, 0.5) y = (1/2)*(1-((1-x)^3-(1-x)*sin((1-x)*pi))+1) ; [0.5, 1] BackEaseInOut(float) public static float BackEaseInOut(float amount) Parameters amount float Returns float Remarks Modeled after the piecewise overshooting cubic function: y = (1/2)((2x)^3-(2x)sin(2xpi)) ; [0, 0.5] y = (1/2)*(1-((1-x)^3-(1-x)*sin((1-x)*pi))+1) ; [0.5, 1] BackEaseOut(double) public static double BackEaseOut(double amount) Parameters amount double Returns double Remarks Modeled after overshooting cubic y = 1-((1-x)^3-(1-x)*sin((1-x)*pi)) BackEaseOut(float) public static float BackEaseOut(float amount) Parameters amount float Returns float Remarks Modeled after overshooting cubic y = 1-((1-x)^3-(1-x)*sin((1-x)*pi)) BounceEaseIn(double) public static double BounceEaseIn(double amount) Parameters amount double Returns double BounceEaseIn(float) public static float BounceEaseIn(float amount) Parameters amount float Returns float BounceEaseInOut(double) public static double BounceEaseInOut(double amount) Parameters amount double Returns double BounceEaseInOut(float) public static float BounceEaseInOut(float amount) Parameters amount float Returns float BounceEaseOut(double) public static double BounceEaseOut(double amount) Parameters amount double Returns double BounceEaseOut(float) public static float BounceEaseOut(float amount) Parameters amount float Returns float CircularEaseIn(double) public static double CircularEaseIn(double amount) Parameters amount double Returns double Remarks Modeled after shifted quadrant IV of unit circle CircularEaseIn(float) public static float CircularEaseIn(float amount) Parameters amount float Returns float Remarks Modeled after shifted quadrant IV of unit circle CircularEaseInOut(double) public static double CircularEaseInOut(double amount) Parameters amount double Returns double Remarks Modeled after the piecewise circular function y = (1/2)(1 - Math.Sqrt(1 - 4x^2)) ; [0, 0.5] y = (1/2)(Math.Sqrt(-(2x - 3)*(2x - 1)) + 1) ; [0.5, 1] CircularEaseInOut(float) public static float CircularEaseInOut(float amount) Parameters amount float Returns float Remarks Modeled after the piecewise circular function y = (1/2)(1 - Math.Sqrt(1 - 4x^2)) ; [0, 0.5] y = (1/2)(Math.Sqrt(-(2x - 3)*(2x - 1)) + 1) ; [0.5, 1] CircularEaseOut(double) public static double CircularEaseOut(double amount) Parameters amount double Returns double Remarks Modeled after shifted quadrant II of unit circle CircularEaseOut(float) public static float CircularEaseOut(float amount) Parameters amount float Returns float Remarks Modeled after shifted quadrant II of unit circle CubicEaseIn(double) public static double CubicEaseIn(double amount) Parameters amount double Returns double Remarks Modeled after the cubic y = x^3 CubicEaseIn(float) public static float CubicEaseIn(float amount) Parameters amount float Returns float Remarks Modeled after the cubic y = x^3 CubicEaseInOut(double) public static double CubicEaseInOut(double amount) Parameters amount double Returns double Remarks Modeled after the piecewise cubic y = (1/2)((2x)^3) ; [0, 0.5] y = (1/2)((2x-2)^3 + 2) ; [0.5, 1] CubicEaseInOut(float) public static float CubicEaseInOut(float amount) Parameters amount float Returns float Remarks Modeled after the piecewise cubic y = (1/2)((2x)^3) ; [0, 0.5] y = (1/2)((2x-2)^3 + 2) ; [0.5, 1] CubicEaseOut(double) public static double CubicEaseOut(double amount) Parameters amount double Returns double Remarks Modeled after the cubic y = (x - 1)^3 + 1 CubicEaseOut(float) public static float CubicEaseOut(float amount) Parameters amount float Returns float Remarks Modeled after the cubic y = (x - 1)^3 + 1 Ease(double, EasingFunction) Performs easing using the specified function. public static double Ease(double amount, EasingFunction function) Parameters amount double The amount. function EasingFunction The easing function to use. Returns double The amount eased using the specified function. Ease(float, EasingFunction) Performs easing using the specified function. public static float Ease(float amount, EasingFunction function) Parameters amount float The amount. function EasingFunction The easing function to use. Returns float The amount eased using the specified function. ElasticEaseIn(double) public static double ElasticEaseIn(double amount) Parameters amount double Returns double Remarks Modeled after the damped sine wave y = sin(13pi/2*x)*Math.Pow(2, 10 * (x - 1)) ElasticEaseIn(float) public static float ElasticEaseIn(float amount) Parameters amount float Returns float Remarks Modeled after the damped sine wave y = sin(13pi/2*x)*Math.Pow(2, 10 * (x - 1)) ElasticEaseInOut(double) public static double ElasticEaseInOut(double amount) Parameters amount double Returns double Remarks Modeled after the piecewise exponentially-damped sine wave: y = (1/2)sin(13pi/2(2x))Math.Pow(2, 10 * ((2x) - 1)) ; [0,0.5] y = (1/2)(sin(-13pi/2*((2x-1)+1))Math.Pow(2,-10(2x-1)) + 2) ; [0.5, 1] ElasticEaseInOut(float) public static float ElasticEaseInOut(float amount) Parameters amount float Returns float Remarks Modeled after the piecewise exponentially-damped sine wave: y = (1/2)sin(13pi/2(2x))Math.Pow(2, 10 * ((2x) - 1)) ; [0,0.5] y = (1/2)(sin(-13pi/2*((2x-1)+1))Math.Pow(2,-10(2x-1)) + 2) ; [0.5, 1] ElasticEaseOut(double) public static double ElasticEaseOut(double amount) Parameters amount double Returns double Remarks Modeled after the damped sine wave y = sin(-13pi/2*(x + 1))*Math.Pow(2, -10x) + 1 ElasticEaseOut(float) public static float ElasticEaseOut(float amount) Parameters amount float Returns float Remarks Modeled after the damped sine wave y = sin(-13pi/2*(x + 1))*Math.Pow(2, -10x) + 1 ExponentialEaseIn(double) public static double ExponentialEaseIn(double amount) Parameters amount double Returns double Remarks Modeled after the exponential function y = 2^(10(x - 1)) ExponentialEaseIn(float) public static float ExponentialEaseIn(float amount) Parameters amount float Returns float Remarks Modeled after the exponential function y = 2^(10(x - 1)) ExponentialEaseInOut(double) public static double ExponentialEaseInOut(double amount) Parameters amount double Returns double Remarks Modeled after the piecewise exponential y = (1/2)2^(10(2x - 1)) ; [0,0.5) y = -(1/2)*2^(-10(2x - 1))) + 1 ; [0.5,1] ExponentialEaseInOut(float) public static float ExponentialEaseInOut(float amount) Parameters amount float Returns float Remarks Modeled after the piecewise exponential y = (1/2)2^(10(2x - 1)) ; [0,0.5] y = -(1/2)*2^(-10(2x - 1))) + 1 ; [0.5,1] ExponentialEaseOut(double) public static double ExponentialEaseOut(double amount) Parameters amount double Returns double Remarks Modeled after the exponential function y = -2^(-10x) + 1 ExponentialEaseOut(float) public static float ExponentialEaseOut(float amount) Parameters amount float Returns float Remarks Modeled after the exponential function y = -2^(-10x) + 1 Linear(double) Performs a linear easing. public static double Linear(double amount) Parameters amount double The amount. Returns double The amount eased. Remarks Modeled after the line y = x Linear(float) Performs a linear easing. public static float Linear(float amount) Parameters amount float The amount. Returns float The amount eased. Remarks Modeled after the line y = x QuadraticEaseIn(double) public static double QuadraticEaseIn(double amount) Parameters amount double Returns double Remarks Modeled after the parabola y = x^2 QuadraticEaseIn(float) public static float QuadraticEaseIn(float amount) Parameters amount float Returns float Remarks Modeled after the parabola y = x^2 QuadraticEaseInOut(double) public static double QuadraticEaseInOut(double amount) Parameters amount double Returns double Remarks Modeled after the piecewise quadratic y = (1/2)((2x)^2) ; [0, 0.5] y = -(1/2)((2x-1)*(2x-3) - 1) ; [0.5, 1] QuadraticEaseInOut(float) public static float QuadraticEaseInOut(float amount) Parameters amount float Returns float Remarks Modeled after the piecewise quadratic y = (1/2)((2x)^2) ; [0, 0.5] y = -(1/2)((2x-1)*(2x-3) - 1) ; [0.5, 1] QuadraticEaseOut(double) public static double QuadraticEaseOut(double amount) Parameters amount double Returns double Remarks Modeled after the parabola y = -x^2 + 2x QuadraticEaseOut(float) public static float QuadraticEaseOut(float amount) Parameters amount float Returns float Remarks Modeled after the parabola y = -x^2 + 2x QuarticEaseIn(double) public static double QuarticEaseIn(double amount) Parameters amount double Returns double Remarks Modeled after the quartic x^4 QuarticEaseIn(float) public static float QuarticEaseIn(float amount) Parameters amount float Returns float Remarks Modeled after the quartic x^4 QuarticEaseInOut(double) public static double QuarticEaseInOut(double amount) Parameters amount double Returns double Remarks Modeled after the piecewise quartic y = (1/2)((2x)^4) ; [0, 0.5] y = -(1/2)((2x-2)^4 - 2) ; [0.5, 1] QuarticEaseInOut(float) public static float QuarticEaseInOut(float amount) Parameters amount float Returns float Remarks Modeled after the piecewise quartic y = (1/2)((2x)^4) ; [0, 0.5] y = -(1/2)((2x-2)^4 - 2) ; [0.5, 1] QuarticEaseOut(double) public static double QuarticEaseOut(double amount) Parameters amount double Returns double Remarks Modeled after the quartic y = 1 - (x - 1)^4 QuarticEaseOut(float) public static float QuarticEaseOut(float amount) Parameters amount float Returns float Remarks Modeled after the quartic y = 1 - (x - 1)^4 QuinticEaseIn(double) public static double QuinticEaseIn(double amount) Parameters amount double Returns double Remarks Modeled after the quintic y = x^5 QuinticEaseIn(float) public static float QuinticEaseIn(float amount) Parameters amount float Returns float Remarks Modeled after the quintic y = x^5 QuinticEaseInOut(double) public static double QuinticEaseInOut(double amount) Parameters amount double Returns double Remarks Modeled after the piecewise quintic y = (1/2)((2x)^5) ; [0, 0.5] y = (1/2)((2x-2)^5 + 2) ; [0.5, 1] QuinticEaseInOut(float) public static float QuinticEaseInOut(float amount) Parameters amount float Returns float Remarks Modeled after the piecewise quintic y = (1/2)((2x)^5) ; [0, 0.5] y = (1/2)((2x-2)^5 + 2) ; [0.5, 1] QuinticEaseOut(double) public static double QuinticEaseOut(double amount) Parameters amount double Returns double Remarks Modeled after the quintic y = (x - 1)^5 + 1 QuinticEaseOut(float) public static float QuinticEaseOut(float amount) Parameters amount float Returns float Remarks Modeled after the quintic y = (x - 1)^5 + 1 SineEaseIn(double) public static double SineEaseIn(double amount) Parameters amount double Returns double Remarks Modeled after quarter-cycle of sine wave SineEaseIn(float) public static float SineEaseIn(float amount) Parameters amount float Returns float Remarks Modeled after quarter-cycle of sine wave SineEaseInOut(double) public static double SineEaseInOut(double amount) Parameters amount double Returns double Remarks Modeled after half sine wave SineEaseInOut(float) public static float SineEaseInOut(float amount) Parameters amount float Returns float Remarks Modeled after half sine wave SineEaseOut(double) public static double SineEaseOut(double amount) Parameters amount double Returns double Remarks Modeled after quarter-cycle of sine wave (different phase) SineEaseOut(float) public static float SineEaseOut(float amount) Parameters amount float Returns float Remarks Modeled after quarter-cycle of sine wave (different phase)"
  },
  "api/Stride.CommunityToolkit.Mathematics.EasingFunction.html": {
    "href": "api/Stride.CommunityToolkit.Mathematics.EasingFunction.html",
    "title": "Enum EasingFunction | Stride Community Toolkit",
    "summary": "Enum EasingFunction Namespace Stride.CommunityToolkit.Mathematics Assembly Stride.CommunityToolkit.dll The type of easing functions implemented in Easing public enum EasingFunction Fields BackEaseIn = 25 BackEaseInOut = 27 BackEaseOut = 26 BounceEaseIn = 28 BounceEaseInOut = 30 BounceEaseOut = 29 CircularEaseIn = 16 CircularEaseInOut = 18 CircularEaseOut = 17 CubicEaseIn = 4 CubicEaseInOut = 6 CubicEaseOut = 5 ElasticEaseIn = 22 ElasticEaseInOut = 24 ElasticEaseOut = 23 ExponentialEaseIn = 19 ExponentialEaseInOut = 21 ExponentialEaseOut = 20 Linear = 0 QuadraticEaseIn = 1 QuadraticEaseInOut = 3 QuadraticEaseOut = 2 QuarticEaseIn = 7 QuarticEaseInOut = 9 QuarticEaseOut = 8 QuinticEaseIn = 10 QuinticEaseInOut = 12 QuinticEaseOut = 11 SineEaseIn = 13 SineEaseInOut = 15 SineEaseOut = 14"
  },
  "api/Stride.CommunityToolkit.Mathematics.MathUtilEx.html": {
    "href": "api/Stride.CommunityToolkit.Mathematics.MathUtilEx.html",
    "title": "Class MathUtilEx | Stride Community Toolkit",
    "summary": "Class MathUtilEx Namespace Stride.CommunityToolkit.Mathematics Assembly Stride.CommunityToolkit.dll Some more common utility methods for math operations. public static class MathUtilEx Inheritance object MathUtilEx Methods CeilingToInt(float) Gets the smallest integer greater than or equal to the amount. public static int CeilingToInt(this float value) Parameters value float The value. Returns int The smallest integer greater than or equal to the amount. Clamp01(float) Clamps the value between 0 and 1. public static float Clamp01(float value) Parameters value float The Value. Returns float Value clamped between 0 and 1. FloorToInt(float) Gets largest integer less than or equal to the amount. public static int FloorToInt(this float value) Parameters value float The value. Returns int The largest integer less than or equal to the amount. Interpolate(Color, Color, float, EasingFunction) Performs an interpolation between two colors using an easing function. public static Color Interpolate(Color start, Color end, float amount, EasingFunction easingFunction) Parameters start Color Start color. end Color End color. amount float Value between 0 and 1 indicating the weight of end. easingFunction EasingFunction The function used to ease the interpolation. Returns Color The interpolation of the two colors. Remarks Passing amount a value of 0 will cause start to be returned; a value of 1 will cause end to be returned. Interpolate(ref Color, ref Color, float, EasingFunction, out Color) Performs an interpolation between two colors using an easing function. public static void Interpolate(ref Color start, ref Color end, float amount, EasingFunction easingFunction, out Color result) Parameters start Color Start color. end Color End color. amount float Value between 0 and 1 indicating the weight of end. easingFunction EasingFunction The function used to ease the interpolation. result Color When the method completes, contains the interpolation of the two colors. Remarks Passing amount a value of 0 will cause start to be returned; a value of 1 will cause end to be returned. Interpolate(Vector2, Vector2, float, EasingFunction) Performs an interpolation between two vectors using an easing function. public static Vector2 Interpolate(Vector2 start, Vector2 end, float amount, EasingFunction easingFunction) Parameters start Vector2 Start vector. end Vector2 End vector. amount float Value between 0 and 1 indicating the weight of end. easingFunction EasingFunction The function used to ease the interpolation. Returns Vector2 The interpolation of the two vectors. Remarks Passing amount a value of 0 will cause start to be returned; a value of 1 will cause end to be returned. Interpolate(ref Vector2, ref Vector2, float, EasingFunction, out Vector2) Performs an interpolation between two vectors using an easing function. public static void Interpolate(ref Vector2 start, ref Vector2 end, float amount, EasingFunction easingFunction, out Vector2 result) Parameters start Vector2 Start vector. end Vector2 End vector. amount float Value between 0 and 1 indicating the weight of end. easingFunction EasingFunction The function used to ease the interpolation. result Vector2 When the method completes, contains the interpolation of the two vectors. Remarks Passing amount a value of 0 will cause start to be returned; a value of 1 will cause end to be returned. Interpolate(Vector3, Vector3, float, EasingFunction) Performs an interpolation between two vectors using an easing function. public static Vector3 Interpolate(Vector3 start, Vector3 end, float amount, EasingFunction easingFunction) Parameters start Vector3 Start vector. end Vector3 End vector. amount float Value between 0 and 1 indicating the weight of end. easingFunction EasingFunction The function used to ease the interpolation. Returns Vector3 The interpolation of the two vectors. Remarks Passing amount a value of 0 will cause start to be returned; a value of 1 will cause end to be returned. Interpolate(ref Vector3, ref Vector3, float, EasingFunction, out Vector3) Performs an interpolation between two vectors using an easing function. public static void Interpolate(ref Vector3 start, ref Vector3 end, float amount, EasingFunction easingFunction, out Vector3 result) Parameters start Vector3 Start vector. end Vector3 End vector. amount float Value between 0 and 1 indicating the weight of end. easingFunction EasingFunction The function used to ease the interpolation. result Vector3 When the method completes, contains the interpolation of the two vectors. Remarks Passing amount a value of 0 will cause start to be returned; a value of 1 will cause end to be returned. Interpolate(Vector4, Vector4, float, EasingFunction) Performs an interpolation between two vectors using an easing function. public static Vector4 Interpolate(Vector4 start, Vector4 end, float amount, EasingFunction easingFunction) Parameters start Vector4 Start vector. end Vector4 End vector. amount float Value between 0 and 1 indicating the weight of end. easingFunction EasingFunction The function used to ease the interpolation. Returns Vector4 The interpolation of the two vectors. Remarks Passing amount a value of 0 will cause start to be returned; a value of 1 will cause end to be returned. Interpolate(ref Vector4, ref Vector4, float, EasingFunction, out Vector4) Performs an interpolation between two vectors using an easing function. public static void Interpolate(ref Vector4 start, ref Vector4 end, float amount, EasingFunction easingFunction, out Vector4 result) Parameters start Vector4 Start vector. end Vector4 End vector. amount float Value between 0 and 1 indicating the weight of end. easingFunction EasingFunction The function used to ease the interpolation. result Vector4 When the method completes, contains the interpolation of the two vectors. Remarks Passing amount a value of 0 will cause start to be returned; a value of 1 will cause end to be returned. Interpolate(float, float, float, EasingFunction) Performs an interpolation between two values using an easing function. public static float Interpolate(float start, float end, float amount, EasingFunction easingFunction) Parameters start float Start value. end float End value. amount float Value between 0 and 1 indicating the weight of end. easingFunction EasingFunction The function used to ease the interpolation. Returns float Remarks Passing amount a value of 0 will cause start to be returned; a value of 1 will cause end to be returned. LookRotation(Vector3, Vector3, Vector3) Creates a rotation with the specified forward and upwards directions. public static Quaternion LookRotation(Vector3 eye, Vector3 target, Vector3 up) Parameters eye Vector3 The postion of the observer. i.e. camera target Vector3 The location of the object to look-at. up Vector3 The vector that defines which direction is up. Returns Quaternion The created quaternion rotation Examples var cameraRotation = Quaternion.LookRotation(cameraPosition, targetPosition, Vector3.UnitY); LookRotation(ref Vector3, ref Vector3, ref Vector3, out Quaternion) Creates a rotation with the specified forward and upwards directions. public static void LookRotation(ref Vector3 eye, ref Vector3 target, ref Vector3 up, out Quaternion result) Parameters eye Vector3 The postion of the observer. i.e. camera target Vector3 The location of the object to look-at. up Vector3 The vector that defines which direction is up. result Quaternion The created quaternion rotation Orthonormalize(ref Vector3, ref Vector3) Orthonormalizes 2 vectors. public static void Orthonormalize(ref Vector3 normal, ref Vector3 tangent) Parameters normal Vector3 The normal vector. tangent Vector3 The tangent vector. Remarks Makes vectors normalized and orthogonal to each other. Normalizes normal. Normalizes tangent and makes sure it is orthogonal to normal. RoundToInt(float) Gets the integer value nearest to the amount. public static int RoundToInt(this float value) Parameters value float The value. Returns int The integer value nearest to the amount. ToQuaternion(Vector3) Convert rotation Euler angles to a Quaternion. public static Quaternion ToQuaternion(this Vector3 rotationEulerXYZ) Parameters rotationEulerXYZ Vector3 The euler rotation, with XYZ order. Returns Quaternion Resulting quaternion rotation ToQuaternion(ref Vector3, out Quaternion) Convert rotation Euler angles to a Quaternion. public static void ToQuaternion(ref Vector3 rotationEulerXYZ, out Quaternion result) Parameters rotationEulerXYZ Vector3 The euler rotation, with XYZ order. result Quaternion Resulting quaternion rotation ToRotationEulerXYZ(Quaternion) Convert Quaternion to rotation Euler angles. public static Vector3 ToRotationEulerXYZ(this Quaternion rotation) Parameters rotation Quaternion The rotation. Returns Vector3 Reulting euler rotation, with XYZ order. ToRotationEulerXYZ(ref Quaternion, out Vector3) Convert Quaternion to rotation Euler angles. public static void ToRotationEulerXYZ(ref Quaternion rotation, out Vector3 result) Parameters rotation Quaternion The rotation. result Vector3 Reulting euler rotation, with XYZ order."
  },
  "api/Stride.CommunityToolkit.Mathematics.RandomExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Mathematics.RandomExtensions.html",
    "title": "Class RandomExtensions | Stride Community Toolkit",
    "summary": "Class RandomExtensions Namespace Stride.CommunityToolkit.Mathematics Assembly Stride.CommunityToolkit.dll Extensions for Random. public static class RandomExtensions Inheritance object RandomExtensions Methods NextColor(Random) Generates a random color. public static Color NextColor(this Random random) Parameters random Random An instance of Random. Returns Color A random color. Aplha is set to 255. Exceptions ArgumentNullException If the random argument is null. NextDirection2D(Random) Generates a random normalized 2D direction vector. public static Vector2 NextDirection2D(this Random random) Parameters random Random An instance of Random. Returns Vector2 Exceptions ArgumentNullException If the random argument is null. NextDirection3D(Random) Generates a random normalized 3D direction vector. public static Vector3 NextDirection3D(this Random random) Parameters random Random An instance of Random. Returns Vector3 Exceptions ArgumentNullException If the random argument is null. NextPoint(Random, BoundingBox) Generates a random point in 3D space within the specified region. public static Vector3 NextPoint(this Random random, BoundingBox region) Parameters random Random An instance of Random. region BoundingBox A 3D region in which point is generated. Returns Vector3 Exceptions ArgumentNullException If the random argument is null. NextPoint(Random, RectangleF) Generates a random point in 2D space within the specified region. public static Vector2 NextPoint(this Random random, RectangleF region) Parameters random Random An instance of Random. region RectangleF A 2D region in which point is generated. Returns Vector2 A random point in 2D space within the specified region. Exceptions ArgumentNullException If the random argument is null. NextSingle(Random) Generates a random float. public static float NextSingle(this Random random) Parameters random Random An instance of Random. Returns float A random float. Exceptions ArgumentNullException If the random argument is null. PointInACircle(Random, float) Generates a random point in a circle of a given radius. public static Vector2 PointInACircle(this Random random, float radius = 1) Parameters random Random An instance of Random. radius float Radius of circle. Default 1.0f. Returns Vector2 A random point in a circle of a given radius. Exceptions ArgumentNullException If the random argument is null."
  },
  "api/Stride.CommunityToolkit.Mathematics.html": {
    "href": "api/Stride.CommunityToolkit.Mathematics.html",
    "title": "Namespace Stride.CommunityToolkit.Mathematics | Stride Community Toolkit",
    "summary": "Namespace Stride.CommunityToolkit.Mathematics Classes Easing A collection of easing functions. MathUtilEx Some more common utility methods for math operations. RandomExtensions Extensions for Random. Enums EasingFunction The type of easing functions implemented in Easing"
  },
  "api/Stride.CommunityToolkit.Physics.HeightmapExtensions.FloatRGBAConverter.html": {
    "href": "api/Stride.CommunityToolkit.Physics.HeightmapExtensions.FloatRGBAConverter.html",
    "title": "Struct HeightmapExtensions.FloatRGBAConverter | Stride Community Toolkit",
    "summary": "Struct HeightmapExtensions.FloatRGBAConverter Namespace Stride.CommunityToolkit.Physics Assembly Stride.CommunityToolkit.dll Float from bytes and back, like the Union structure from c++ public struct HeightmapExtensions.FloatRGBAConverter Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() Constructors FloatRGBAConverter(byte, byte, byte, byte) public FloatRGBAConverter(byte r, byte g, byte b, byte a) Parameters r byte g byte b byte a byte FloatRGBAConverter(float) public FloatRGBAConverter(float @float) Parameters float float Fields A public byte A Field Value byte B public byte B Field Value byte Float public float Float Field Value float G public byte G Field Value byte R public byte R Field Value byte"
  },
  "api/Stride.CommunityToolkit.Physics.HeightmapExtensions.VertexTypePosTexNormColor.html": {
    "href": "api/Stride.CommunityToolkit.Physics.HeightmapExtensions.VertexTypePosTexNormColor.html",
    "title": "Struct HeightmapExtensions.VertexTypePosTexNormColor | Stride Community Toolkit",
    "summary": "Struct HeightmapExtensions.VertexTypePosTexNormColor Namespace Stride.CommunityToolkit.Physics Assembly Stride.CommunityToolkit.dll Custom vertex type so that we can generate tangents for supporting normal maps public struct HeightmapExtensions.VertexTypePosTexNormColor : IEquatable<HeightmapExtensions.VertexTypePosTexNormColor>, IVertex Implements IEquatable<HeightmapExtensions.VertexTypePosTexNormColor> IVertex Constructors VertexTypePosTexNormColor(Vector3, Vector3, Vector3, Vector2, Vector4) public VertexTypePosTexNormColor(Vector3 position, Vector3 normal, Vector3 tangent, Vector2 texCoord1, Vector4 color1) Parameters position Vector3 normal Vector3 tangent Vector3 texCoord1 Vector2 color1 Vector4 Fields Color public Vector4 Color Field Value Vector4 Layout public static readonly VertexDeclaration Layout Field Value VertexDeclaration Normal public Vector3 Normal Field Value Vector3 Position public Vector3 Position Field Value Vector3 Size public static readonly int Size Field Value int Tangent public Vector3 Tangent Field Value Vector3 TexCoord public Vector2 TexCoord Field Value Vector2 Methods Equals(VertexTypePosTexNormColor) Indicates whether the current object is equal to another object of the same type. public bool Equals(HeightmapExtensions.VertexTypePosTexNormColor other) Parameters other HeightmapExtensions.VertexTypePosTexNormColor An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(object?) Indicates whether this instance and a specified object are equal. public override bool Equals(object? obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. FlipWinding() Flip the vertex winding. public void FlipWinding() GetHashCode() Returns the hash code for this instance. public override int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. GetLayout() Gets the layout of the vertex. public VertexDeclaration GetLayout() Returns VertexDeclaration ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name. Operators operator ==(VertexTypePosTexNormColor, VertexTypePosTexNormColor) public static bool operator ==(HeightmapExtensions.VertexTypePosTexNormColor left, HeightmapExtensions.VertexTypePosTexNormColor right) Parameters left HeightmapExtensions.VertexTypePosTexNormColor right HeightmapExtensions.VertexTypePosTexNormColor Returns bool operator !=(VertexTypePosTexNormColor, VertexTypePosTexNormColor) public static bool operator !=(HeightmapExtensions.VertexTypePosTexNormColor left, HeightmapExtensions.VertexTypePosTexNormColor right) Parameters left HeightmapExtensions.VertexTypePosTexNormColor right HeightmapExtensions.VertexTypePosTexNormColor Returns bool"
  },
  "api/Stride.CommunityToolkit.Physics.HeightmapExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Physics.HeightmapExtensions.html",
    "title": "Class HeightmapExtensions | Stride Community Toolkit",
    "summary": "Class HeightmapExtensions Namespace Stride.CommunityToolkit.Physics Assembly Stride.CommunityToolkit.dll public static class HeightmapExtensions Inheritance object HeightmapExtensions Fields HeightMultiplier Used to distinguish between Grey scale heightmaps HeightMultiplier=255.0f (yields a byte 0-255) or float heightmaps HeightMultiplier=10000.0f (based on a short -32,768 to 32,767, sum yields 65,535 levels for much smoother maps). public const float HeightMultiplier = 255 Field Value float Methods AsStrideColor(short) public static Color AsStrideColor(this short val) Parameters val short Returns Color GetHeightAt(Heightmap, int, int) public static float GetHeightAt(this Heightmap heightmap, int x, int y) Parameters heightmap Heightmap x int y int Returns float GetHeightIndex(Heightmap, int, int) public static int GetHeightIndex(this Heightmap heightmap, int x, int y) Parameters heightmap Heightmap x int y int Returns int GetNormal(Heightmap, int, int) public static Vector3 GetNormal(this Heightmap heightmap, int x, int y) Parameters heightmap Heightmap x int y int Returns Vector3 GetTangent(Heightmap, int, int) public static Vector3 GetTangent(this Heightmap heightmap, int x, int z) Parameters heightmap Heightmap x int z int Returns Vector3 IntersectsRay(Heightmap, Ray, out Vector3, float, float) public static bool IntersectsRay(this Heightmap heightmap, Ray ray, out Vector3 point, float m_QuadSideWidthX = 1, float m_QuadSideWidthZ = 1) Parameters heightmap Heightmap ray Ray point Vector3 m_QuadSideWidthX float m_QuadSideWidthZ float Returns bool IsValidCoordinate(Heightmap, int, int) public static bool IsValidCoordinate(this Heightmap heightmap, int x, int y) Parameters heightmap Heightmap x int y int Returns bool ToFloats(Heightmap) public static float[] ToFloats(this Heightmap heightmap) Parameters heightmap Heightmap Returns float[] ToMesh(Heightmap, GraphicsDevice, float, float, float, out Vector3[], int) Creates the terrain mesh from a given heightmap. Tessellation divides the quad numbers. public static Mesh ToMesh(this Heightmap heightmap, GraphicsDevice graphicsDevice, float m_QuadSideWidthX, float m_QuadSideWidthZ, float TEXTURE_REPEAT, out Vector3[] terrainPoints, int tessellation) Parameters heightmap Heightmap graphicsDevice GraphicsDevice m_QuadSideWidthX float m_QuadSideWidthZ float TEXTURE_REPEAT float terrainPoints Vector3[] tessellation int Returns Mesh ToTexture(Heightmap, GraphicsDevice, CommandList) public static Texture ToTexture(this Heightmap heightmap, GraphicsDevice graphicsDevice, CommandList commandList) Parameters heightmap Heightmap graphicsDevice GraphicsDevice commandList CommandList Returns Texture ToWorldPoints(Heightmap, float, float) public static Vector3[] ToWorldPoints(this Heightmap heightmap, float m_QuadSideWidthX, float m_QuadSideWidthZ) Parameters heightmap Heightmap m_QuadSideWidthX float m_QuadSideWidthZ float Returns Vector3[]"
  },
  "api/Stride.CommunityToolkit.Physics.html": {
    "href": "api/Stride.CommunityToolkit.Physics.html",
    "title": "Namespace Stride.CommunityToolkit.Physics | Stride Community Toolkit",
    "summary": "Namespace Stride.CommunityToolkit.Physics Classes HeightmapExtensions Structs HeightmapExtensions.FloatRGBAConverter Float from bytes and back, like the Union structure from c++ HeightmapExtensions.VertexTypePosTexNormColor Custom vertex type so that we can generate tangents for supporting normal maps"
  },
  "api/Stride.CommunityToolkit.Rendering.Compositing.EntityDebugSceneRenderer.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.Compositing.EntityDebugSceneRenderer.html",
    "title": "Class EntityDebugSceneRenderer | Stride Community Toolkit",
    "summary": "Class EntityDebugSceneRenderer Namespace Stride.CommunityToolkit.Rendering.Compositing Assembly Stride.CommunityToolkit.dll Renders debug information (such as entity names and positions) for all entities in a scene. public class EntityDebugSceneRenderer : SceneRendererBase, IComponent, IReferencable, ICollectorHolder, ISceneRenderer, IRenderCollector, IGraphicsRenderer, IGraphicsRendererBase, IGraphicsRendererCore, IDisposable Inheritance object DisposeBase ComponentBase RendererCoreBase SceneRendererBase EntityDebugSceneRenderer Implements IComponent IReferencable ICollectorHolder ISceneRenderer IRenderCollector IGraphicsRenderer IGraphicsRendererBase IGraphicsRendererCore IDisposable Inherited Members SceneRendererBase.Collect(RenderContext) SceneRendererBase.Draw(RenderDrawContext) SceneRendererBase.CollectCore(RenderContext) SceneRendererBase.Id RendererCoreBase.Initialize(RenderContext) RendererCoreBase.Unload() RendererCoreBase.PreDrawCore(RenderDrawContext) RendererCoreBase.PostDrawCore(RenderDrawContext) RendererCoreBase.NewScopedBuffer(BufferDescription, PixelFormat) RendererCoreBase.NewScopedTypedBuffer(int, PixelFormat, bool, GraphicsResourceUsage) RendererCoreBase.PushScopedResource<T>(T) RendererCoreBase.CheckIsInDrawCore() RendererCoreBase.Destroy() RendererCoreBase.ToLoadAndUnload<T>(T) RendererCoreBase.PreDrawCoreInternal(RenderDrawContext) RendererCoreBase.EnsureContext(RenderContext) RendererCoreBase.PostDrawCoreInternal(RenderDrawContext) RendererCoreBase.Enabled RendererCoreBase.Profiling RendererCoreBase.GPUProfilingKey RendererCoreBase.CPUProfilingKey RendererCoreBase.Context RendererCoreBase.Services RendererCoreBase.Content RendererCoreBase.GraphicsDevice RendererCoreBase.EffectSystem RendererCoreBase.Initialized ComponentBase.Tags ComponentBase.OnNameChanged() ComponentBase.ToString() ComponentBase.Name DisposeBase.Dispose() DisposeBase.OnAddReference() DisposeBase.OnReleaseReference() DisposeBase.IsDisposed Remarks This class is designed to display debug information such as entity names and positions on the screen using 2D text rendering over the 3D scene. It also allows optional customization, such as font size, color, and background. Constructors EntityDebugSceneRenderer() Initializes a new instance of the EntityDebugSceneRenderer class with default rendering options. public EntityDebugSceneRenderer() EntityDebugSceneRenderer(EntityDebugSceneRendererOptions?) Initializes a new instance of the EntityDebugSceneRenderer class with the specified rendering options. public EntityDebugSceneRenderer(EntityDebugSceneRendererOptions? options = null) Parameters options EntityDebugSceneRendererOptions The options to customize the appearance of the debug text. If null, default options are used. Methods DrawCore(RenderContext, RenderDrawContext) Draws debug information (such as entity names and positions) for all entities in the current scene. protected override void DrawCore(RenderContext context, RenderDrawContext drawContext) Parameters context RenderContext The current rendering context, which provides information such as the scene and camera. drawContext RenderDrawContext The context used to draw graphical elements. InitializeCore() Initializes core resources needed by the renderer, such as the font and sprite batch. protected override void InitializeCore()"
  },
  "api/Stride.CommunityToolkit.Rendering.Compositing.EntityDebugSceneRendererOptions.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.Compositing.EntityDebugSceneRendererOptions.html",
    "title": "Class EntityDebugSceneRendererOptions | Stride Community Toolkit",
    "summary": "Class EntityDebugSceneRendererOptions Namespace Stride.CommunityToolkit.Rendering.Compositing Assembly Stride.CommunityToolkit.dll Options for rendering debug information for entities in the scene. public class EntityDebugSceneRendererOptions Inheritance object EntityDebugSceneRendererOptions Constructors EntityDebugSceneRendererOptions() Initializes a new instance of EntityDebugSceneRendererOptions with default settings. public EntityDebugSceneRendererOptions() EntityDebugSceneRendererOptions(int, Color) Initializes a new instance of EntityDebugSceneRendererOptions with specified font size and color. public EntityDebugSceneRendererOptions(int fontSize, Color fontColor) Parameters fontSize int The size of the debug font text. fontColor Color The color of the debug font text. Properties FontColor Gets or sets the font color for the debug text. Default is black. public Color FontColor { get; set; } Property Value Color FontSize Gets or sets the font size for the debug text. Default is 12. public int FontSize { get; set; } Property Value int Offset Gets or sets the offset for positioning the debug text relative to the entity. Default offset is (0, -25). public Vector2 Offset { get; set; } Property Value Vector2 ShowEntityName Gets or sets a value indicating whether to show the entity's name. Default is true. public bool ShowEntityName { get; set; } Property Value bool ShowEntityPosition Gets or sets a value indicating whether to show the entity's position. public bool ShowEntityPosition { get; set; } Property Value bool ShowFontBackground Gets or sets a value indicating whether to display a background behind the text. public bool ShowFontBackground { get; set; } Property Value bool Methods CreateDefault() Provides default settings for rendering entity debug information. public static EntityDebugSceneRendererOptions CreateDefault() Returns EntityDebugSceneRendererOptions A new instance of EntityDebugSceneRendererOptions with default values."
  },
  "api/Stride.CommunityToolkit.Rendering.Compositing.GraphicsCompositorExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.Compositing.GraphicsCompositorExtensions.html",
    "title": "Class GraphicsCompositorExtensions | Stride Community Toolkit",
    "summary": "Class GraphicsCompositorExtensions Namespace Stride.CommunityToolkit.Rendering.Compositing Assembly Stride.CommunityToolkit.dll Provides extension methods for the GraphicsCompositor class to enhance its functionality. These methods allow for the addition of UI stages, scene renderers, and debug render features, as well as utility methods for working with render stages. public static class GraphicsCompositorExtensions Inheritance object GraphicsCompositorExtensions Methods AddCleanUIStage(GraphicsCompositor) Adds a UI render stage and white/clean text effect to the given GraphicsCompositor. This alters the GraphicsCompositor's PostProcessingEffects, RenderStage, and RenderFeature. public static GraphicsCompositor AddCleanUIStage(this GraphicsCompositor graphicsCompositor) Parameters graphicsCompositor GraphicsCompositor The GraphicsCompositor to modify. Returns GraphicsCompositor Returns the modified GraphicsCompositor instance, allowing for method chaining. Examples game.AddGraphicsCompositor().AddCleanUIStage(); AddEntityDebugRenderer(GraphicsCompositor, EntityDebugSceneRendererOptions?) Adds an EntityDebugSceneRenderer to the GraphicsCompositor for rendering entity debug information. public static GraphicsCompositor AddEntityDebugRenderer(this GraphicsCompositor graphicsCompositor, EntityDebugSceneRendererOptions? options = null) Parameters graphicsCompositor GraphicsCompositor The GraphicsCompositor to which the entity debug renderer will be added. options EntityDebugSceneRendererOptions Optional settings to customize the appearance of the debug renderer. If not provided, default options will be used. Returns GraphicsCompositor The modified GraphicsCompositor instance with the entity debug renderer added. Examples The following example demonstrates how to add an entity debug renderer with default settings: graphicsCompositor.EntityDebugSceneRenderer(); You can also specify custom options: var options = new EntityDebugRendererOptions { FontSize = 16, FontColor = Color.Red }; graphicsCompositor.EntityDebugSceneRenderer(options); Remarks This method adds a custom EntityDebugSceneRenderer to the graphics compositor, allowing the display of debug information such as entity names and positions in a 3D scene. The renderer can be customized using the options parameter, which allows the user to define font size, color, and other settings. AddParticleStagesAndFeatures(GraphicsCompositor) public static void AddParticleStagesAndFeatures(this GraphicsCompositor graphicsCompositor) Parameters graphicsCompositor GraphicsCompositor AddRootRenderFeature(GraphicsCompositor, RootRenderFeature) public static void AddRootRenderFeature(this GraphicsCompositor graphicsCompositor, RootRenderFeature renderFeature) Parameters graphicsCompositor GraphicsCompositor renderFeature RootRenderFeature AddSceneRenderer(GraphicsCompositor, SceneRendererBase) Adds a new scene renderer to the given GraphicsCompositor's game. If the game is already a collection of scene renderers, the new scene renderer is added to that collection. Otherwise, a new scene renderer collection is created to house both the existing game and the new scene renderer. public static GraphicsCompositor AddSceneRenderer(this GraphicsCompositor graphicsCompositor, SceneRendererBase sceneRenderer) Parameters graphicsCompositor GraphicsCompositor The GraphicsCompositor to which the scene renderer will be added. sceneRenderer SceneRendererBase The new SceneRendererBase instance that will be added to the GraphicsCompositor's game. Returns GraphicsCompositor Returns the modified GraphicsCompositor instance, allowing for method chaining. Remarks This method will either add the scene renderer to an existing SceneRendererCollection or create a new one to house both the existing game and the new scene renderer. In either case, the GraphicsCompositor's game will end up with the new scene renderer added. TryGetRenderStage(GraphicsCompositor, string, out RenderStage?) Attempts to retrieve a render stage from the specified GraphicsCompositor based on the provided effect name. public static bool TryGetRenderStage(this GraphicsCompositor graphicsCompositor, string effectName, out RenderStage? renderStage) Parameters graphicsCompositor GraphicsCompositor The GraphicsCompositor containing the render stages. effectName string The name of the render stage to search for. renderStage RenderStage When this method returns, contains the RenderStage if the render stage was found; otherwise, null. This parameter is passed uninitialized. Returns bool true if the render stage is found; otherwise, false."
  },
  "api/Stride.CommunityToolkit.Rendering.Compositing.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.Compositing.html",
    "title": "Namespace Stride.CommunityToolkit.Rendering.Compositing | Stride Community Toolkit",
    "summary": "Namespace Stride.CommunityToolkit.Rendering.Compositing Classes EntityDebugSceneRenderer Renders debug information (such as entity names and positions) for all entities in a scene. EntityDebugSceneRendererOptions Options for rendering debug information for entities in the scene. GraphicsCompositorExtensions Provides extension methods for the GraphicsCompositor class to enhance its functionality. These methods allow for the addition of UI stages, scene renderers, and debug render features, as well as utility methods for working with render stages."
  },
  "api/Stride.CommunityToolkit.Rendering.Gizmos.AxialGizmo.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.Gizmos.AxialGizmo.html",
    "title": "Class AxialGizmo | Stride Community Toolkit",
    "summary": "Class AxialGizmo Namespace Stride.CommunityToolkit.Rendering.Gizmos Assembly Stride.CommunityToolkit.dll Represents a base class for creating an Axial Gizmo, which visually represents 3D axes in the scene. The Gizmo consists of three axes (X, Y, Z), each represented by a different color (Red, Green, Blue). This class provides the foundational functionality for rendering and configuring the visual aspects of the Gizmo. public abstract class AxialGizmo Inheritance object AxialGizmo Derived TranslationGizmo Constructors AxialGizmo(GraphicsDevice, Color?, Color?, Color?) Initializes a new instance of the AxialGizmo class with optional custom axis colors. protected AxialGizmo(GraphicsDevice graphicsDevice, Color? redColor = null, Color? greenColor = null, Color? blueColor = null) Parameters graphicsDevice GraphicsDevice The graphics device used to render the Gizmo. redColor Color? Optional custom color for the X-axis (Red). If null, a default red color is used. greenColor Color? Optional custom color for the Y-axis (Green). If null, a default green color is used. blueColor Color? Optional custom color for the Z-axis (Blue). If null, a default blue color is used. Fields GizmoDefaultSize The default size of the Gizmo when rendered on the screen, measured in pixels. This controls how large the Gizmo appears relative to the screen. protected const float GizmoDefaultSize = 133 Field Value float GizmoExtremitySize The size of the object placed at the extremities of the Gizmo's axes (e.g., arrowheads or markers). protected const float GizmoExtremitySize = 0.15 Field Value float GizmoOriginScale The scale factor of the object placed at the origin of the Gizmo, compared to the objects at the extremities. Typically, the object at the origin is larger to make it more noticeable. protected const float GizmoOriginScale = 1.33 Field Value float GizmoPlaneLength The size of the Gizmo's small planes, which are used for transformations along specific axes or planes. protected const float GizmoPlaneLength = 0.25 Field Value float GizmoTessellation Defines the tessellation level of the Gizmo, which affects how smoothly the object is rendered. A higher value results in smoother rendering at the cost of performance. protected const int GizmoTessellation = 64 Field Value int Properties BlueUniformMaterial Gets the material for the Z-axis (Blue) of the Gizmo. protected Material? BlueUniformMaterial { get; } Property Value Material DefaultOriginMaterial Gets the default material for the Gizmo's origin, typically represented in white. protected Material? DefaultOriginMaterial { get; } Property Value Material GraphicsDevice Gets the graphics device used for rendering the Gizmo. protected GraphicsDevice GraphicsDevice { get; } Property Value GraphicsDevice GreenUniformMaterial Gets the material for the Y-axis (Green) of the Gizmo. protected Material? GreenUniformMaterial { get; } Property Value Material RedUniformMaterial Gets the material for the X-axis (Red) of the Gizmo. protected Material? RedUniformMaterial { get; } Property Value Material RenderGroup Gets or sets the render group of the Gizmo. This determines which render group the Gizmo will belong to. public RenderGroup RenderGroup { get; protected set; } Property Value RenderGroup Methods Create() Creates the base components of the Gizmo, such as the default origin and axis materials. This method should be called in derived classes to initialize the Gizmo's materials. protected virtual Entity? Create() Returns Entity The Entity representing the Gizmo, or null if no entity is created. Exceptions InvalidOperationException Thrown if the GraphicsDevice is not initialized. CreateEmissiveColorMaterial(Color) Creates a material with an emissive color to visually represent the Gizmo's axes. protected Material CreateEmissiveColorMaterial(Color color) Parameters color Color The color of the material. Returns Material A Material instance with the specified emissive color. GetBlueColor() Retrieves the color for the Z-axis (Blue). Returns the default blue color if none is specified. protected Color GetBlueColor() Returns Color The color for the Z-axis. GetGreenColor() Retrieves the color for the Y-axis (Green). Returns the default green color if none is specified. protected Color GetGreenColor() Returns Color The color for the Y-axis. GetRedColor() Retrieves the color for the X-axis (Red). Returns the default red color if none is specified. protected Color GetRedColor() Returns Color The color for the X-axis."
  },
  "api/Stride.CommunityToolkit.Rendering.Gizmos.GizmoEmissiveColorMaterial.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.Gizmos.GizmoEmissiveColorMaterial.html",
    "title": "Class GizmoEmissiveColorMaterial | Stride Community Toolkit",
    "summary": "Class GizmoEmissiveColorMaterial Namespace Stride.CommunityToolkit.Rendering.Gizmos Assembly Stride.CommunityToolkit.dll A utility class for creating and updating materials with emissive color properties for gizmos. public static class GizmoEmissiveColorMaterial Inheritance object GizmoEmissiveColorMaterial Methods Create(GraphicsDevice, Color, float) Creates a new material with emissive color and diffuse properties based on the specified color and intensity. public static Material Create(GraphicsDevice device, Color color, float intensity = 1) Parameters device GraphicsDevice The GraphicsDevice used to create the material. color Color The Color to apply to the material. intensity float The intensity of the emissive color. Defaults to 1f. Returns Material A new Material with the specified emissive color and intensity."
  },
  "api/Stride.CommunityToolkit.Rendering.Gizmos.GizmoUniformColorMaterial.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.Gizmos.GizmoUniformColorMaterial.html",
    "title": "Class GizmoUniformColorMaterial | Stride Community Toolkit",
    "summary": "Class GizmoUniformColorMaterial Namespace Stride.CommunityToolkit.Rendering.Gizmos Assembly Stride.CommunityToolkit.dll A utility class for creating and updating materials with uniform color properties for gizmos. public static class GizmoUniformColorMaterial Inheritance object GizmoUniformColorMaterial Methods Create(GraphicsDevice, Color) Creates a new material with uniform diffuse color properties based on the specified color. public static Material Create(GraphicsDevice device, Color color) Parameters device GraphicsDevice The GraphicsDevice used to create the material. color Color The Color to apply to the material. Returns Material A new Material with the specified uniform diffuse color. Remarks If the color contains transparency (alpha < 255), transparency is enabled for the material."
  },
  "api/Stride.CommunityToolkit.Rendering.Gizmos.Letter3D.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.Gizmos.Letter3D.html",
    "title": "Class Letter3D | Stride Community Toolkit",
    "summary": "Class Letter3D Namespace Stride.CommunityToolkit.Rendering.Gizmos Assembly Stride.CommunityToolkit.dll public class Letter3D Inheritance object Letter3D Constructors Letter3D(GraphicsDevice, bool) public Letter3D(GraphicsDevice graphicsDevice, bool rotateAxisNames) Parameters graphicsDevice GraphicsDevice rotateAxisNames bool Methods CreateLetterX() public Entity CreateLetterX() Returns Entity CreateLetterY() public Entity CreateLetterY() Returns Entity CreateLetterZ() public Entity CreateLetterZ() Returns Entity"
  },
  "api/Stride.CommunityToolkit.Rendering.Gizmos.LightDirectionalGizmo.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.Gizmos.LightDirectionalGizmo.html",
    "title": "Class LightDirectionalGizmo | Stride Community Toolkit",
    "summary": "Class LightDirectionalGizmo Namespace Stride.CommunityToolkit.Rendering.Gizmos Assembly Stride.CommunityToolkit.dll Represents a directional light gizmo used to visually represent light direction in a 3D scene. public class LightDirectionalGizmo Inheritance object LightDirectionalGizmo Constructors LightDirectionalGizmo(GraphicsDevice, Color?) Initializes a new instance of the LightDirectionalGizmo class with the specified graphics device and optional color. public LightDirectionalGizmo(GraphicsDevice graphicsDevice, Color? color = null) Parameters graphicsDevice GraphicsDevice The graphics device used to render the gizmo. color Color? An optional color to apply to the gizmo. If null, white is used. Exceptions ArgumentNullException Thrown if the graphicsDevice is null. Fields GizmoTessellation The tessellation value for the gizmo, which defines the level of detail for its geometry. protected const int GizmoTessellation = 64 Field Value int Methods Create(Entity) Creates the directional light gizmo and attaches it to the specified root entity. public Entity Create(Entity root) Parameters root Entity The root entity to which the light gizmo is attached. Returns Entity The root entity with the light gizmo added."
  },
  "api/Stride.CommunityToolkit.Rendering.Gizmos.TranslationGizmo.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.Gizmos.TranslationGizmo.html",
    "title": "Class TranslationGizmo | Stride Community Toolkit",
    "summary": "Class TranslationGizmo Namespace Stride.CommunityToolkit.Rendering.Gizmos Assembly Stride.CommunityToolkit.dll Represents a visual translation gizmo used for moving objects in a 3D scene. public class TranslationGizmo : AxialGizmo Inheritance object AxialGizmo TranslationGizmo Inherited Members AxialGizmo.RenderGroup AxialGizmo.GraphicsDevice AxialGizmo.GizmoTessellation AxialGizmo.GizmoExtremitySize AxialGizmo.GizmoOriginScale AxialGizmo.GizmoPlaneLength AxialGizmo.GizmoDefaultSize AxialGizmo.DefaultOriginMaterial AxialGizmo.RedUniformMaterial AxialGizmo.GreenUniformMaterial AxialGizmo.BlueUniformMaterial AxialGizmo.Create() AxialGizmo.CreateEmissiveColorMaterial(Color) AxialGizmo.GetRedColor() AxialGizmo.GetGreenColor() AxialGizmo.GetBlueColor() Remarks This class creates a visual aid for object manipulation, consisting of axis arrows and planes, which can be used to indicate or manipulate movement along specific axes or planes. It is designed as an extension and can be added to any entity in a scene for visual feedback. Constructors TranslationGizmo(GraphicsDevice) Initializes a new instance of the TranslationGizmo class with the specified graphics device. public TranslationGizmo(GraphicsDevice graphicsDevice) Parameters graphicsDevice GraphicsDevice The graphics device used to render the gizmo. TranslationGizmo(GraphicsDevice, Color?, Color?, Color?) Initializes a new instance of the TranslationGizmo class with the specified graphics device and optional colors for each axis. public TranslationGizmo(GraphicsDevice graphicsDevice, Color? xColor = null, Color? yColor = null, Color? zColor = null) Parameters graphicsDevice GraphicsDevice The graphics device used to render the gizmo. xColor Color? Optional color for the X-axis. yColor Color? Optional color for the Y-axis. zColor Color? Optional color for the Z-axis. Methods Create(Entity, bool, bool) Creates the translation gizmo entities and adds them to the specified parent entity. public void Create(Entity entity, bool showAxisName = false, bool rotateAxisNames = true) Parameters entity Entity The entity to which the gizmo will be added. showAxisName bool Determines whether the axis names should be displayed. rotateAxisNames bool Determines whether the axis names should be rotated to match the axes' orientation. Create(Scene) Creates and returns a new translation gizmo entity, adding it to the specified scene. public Entity Create(Scene scene) Parameters scene Scene The scene to which the gizmo will be added. Returns Entity The created translation gizmo entity. CreateUniformColorMaterial(Color) Creates a uniform color material for the gizmo. protected Material CreateUniformColorMaterial(Color color) Parameters color Color The color of the material. Returns Material The created material. GetAxisDefaultMaterial(int) Retrieves the default material for the specified axis. protected Material? GetAxisDefaultMaterial(int axisIndex) Parameters axisIndex int The index of the axis (0 for X, 1 for Y, 2 for Z). Returns Material The material for the specified axis."
  },
  "api/Stride.CommunityToolkit.Rendering.Gizmos.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.Gizmos.html",
    "title": "Namespace Stride.CommunityToolkit.Rendering.Gizmos | Stride Community Toolkit",
    "summary": "Namespace Stride.CommunityToolkit.Rendering.Gizmos Classes AxialGizmo Represents a base class for creating an Axial Gizmo, which visually represents 3D axes in the scene. The Gizmo consists of three axes (X, Y, Z), each represented by a different color (Red, Green, Blue). This class provides the foundational functionality for rendering and configuring the visual aspects of the Gizmo. GizmoEmissiveColorMaterial A utility class for creating and updating materials with emissive color properties for gizmos. GizmoUniformColorMaterial A utility class for creating and updating materials with uniform color properties for gizmos. Letter3D LightDirectionalGizmo Represents a directional light gizmo used to visually represent light direction in a 3D scene. TranslationGizmo Represents a visual translation gizmo used for moving objects in a 3D scene."
  },
  "api/Stride.CommunityToolkit.Rendering.MaterialExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.MaterialExtensions.html",
    "title": "Class MaterialExtensions | Stride Community Toolkit",
    "summary": "Class MaterialExtensions Namespace Stride.CommunityToolkit.Rendering Assembly Stride.CommunityToolkit.dll Extension methods for Material. public static class MaterialExtensions Inheritance object MaterialExtensions Methods Clone(Material) Clone the Material. public static Material Clone(this Material material) Parameters material Material The material to clone. Returns Material The cloned material. Exceptions ArgumentNullException If material is null."
  },
  "api/Stride.CommunityToolkit.Rendering.ProceduralModels.Primitive2DModelType.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.ProceduralModels.Primitive2DModelType.html",
    "title": "Enum Primitive2DModelType | Stride Community Toolkit",
    "summary": "Enum Primitive2DModelType Namespace Stride.CommunityToolkit.Rendering.ProceduralModels Assembly Stride.CommunityToolkit.dll Specifies the types of 2D primitive models that can be created. public enum Primitive2DModelType Fields Capsule = 0 A capsule shape, which is a rectangle with semi-circular ends. Circle = 1 A circle shape with a customizable radius. Polygon = 2 A polygon shape with a customizable number of sides. Quad = 3 A quadrilateral shape, which can represent any four-sided polygon. Rectangle = 4 A rectangular shape with customizable width and height. Square = 5 A square shape with equal width and height. Triangle = 6 A triangular shape with three sides."
  },
  "api/Stride.CommunityToolkit.Rendering.ProceduralModels.PrimitiveModelType.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.ProceduralModels.PrimitiveModelType.html",
    "title": "Enum PrimitiveModelType | Stride Community Toolkit",
    "summary": "Enum PrimitiveModelType Namespace Stride.CommunityToolkit.Rendering.ProceduralModels Assembly Stride.CommunityToolkit.dll Specifies the type of primitive model to be created. Available options: Sphere, Cube, Cylinder, Torus, Plane, InfinitePlane, Teapot, Cone, Capsule. Source Stride.Assets.Presentation.Preview. public enum PrimitiveModelType Fields Capsule = 0 Represents a capsule primitive model. Cone = 1 Represents a cone primitive model. Cube = 2 Represents a cube primitive model. Cylinder = 3 Represents a cylinder primitive model. InfinitePlane = 4 Represents an infinite plane primitive model. Plane = 5 Represents a plane primitive model. RectangularPrism = 6 Represents a rectangular prism primitive model. Sphere = 7 Represents a sphere primitive model. Teapot = 8 Represents a teapot primitive model. Torus = 9 Represents a torus primitive model. TriangularPrism = 10 Represents a triangular prism primitive model. Remarks This enumeration provides a variety of basic geometric shapes that can be utilized for creating 3D models in the game."
  },
  "api/Stride.CommunityToolkit.Rendering.ProceduralModels.Procedural2DModelBuilder.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.ProceduralModels.Procedural2DModelBuilder.html",
    "title": "Class Procedural2DModelBuilder | Stride Community Toolkit",
    "summary": "Class Procedural2DModelBuilder Namespace Stride.CommunityToolkit.Rendering.ProceduralModels Assembly Stride.CommunityToolkit.dll A helper class for generating 2D procedural models based on a specified primitive model type and size. public static class Procedural2DModelBuilder Inheritance object Procedural2DModelBuilder Methods Build(Primitive2DModelType, Vector2?, float) Generates a 2D procedural model based on the specified primitive model type, size, and depth. public static PrimitiveProceduralModelBase Build(Primitive2DModelType type, Vector2? size = null, float depth = 0) Parameters type Primitive2DModelType The type of 2D primitive model to create (e.g., Circle, Square, Triangle). size Vector2? The size parameters for the model as a Vector2, where X and Y represent the dimensions. If null, default dimensions for the model type will be used. depth float The depth of the 2D model, which affects its thickness in 3D space. Returns PrimitiveProceduralModelBase A PrimitiveProceduralModelBase object representing the generated 2D model. The dimensions of the model will be determined by the provided size and depth, or default dimensions if size is null. Remarks This method creates different types of 2D procedural models (such as Rectangle, Circle, etc.) with the specified size and depth. The depth adds a third dimension to the 2D shape, turning it into a 3D object (e.g., a 2D rectangle becomes a 3D rectangular prism). Exceptions InvalidOperationException Thrown when an unsupported type is specified."
  },
  "api/Stride.CommunityToolkit.Rendering.ProceduralModels.Procedural3DModelBuilder.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.ProceduralModels.Procedural3DModelBuilder.html",
    "title": "Class Procedural3DModelBuilder | Stride Community Toolkit",
    "summary": "Class Procedural3DModelBuilder Namespace Stride.CommunityToolkit.Rendering.ProceduralModels Assembly Stride.CommunityToolkit.dll A helper class for generating 3D procedural models based on a specified primitive model type and size. public static class Procedural3DModelBuilder Inheritance object Procedural3DModelBuilder Methods Build(PrimitiveModelType, Vector3?) Generates a 3D procedural model based on the specified primitive model type and size. public static PrimitiveProceduralModelBase Build(PrimitiveModelType type, Vector3? size = null) Parameters type PrimitiveModelType The type of 3D primitive model to create (e.g., Cube, Sphere, Capsule). size Vector3? The size parameters for the model as a Vector3, where X, Y, and Z represent the dimensions. If null, default dimensions for the model type will be used. Returns PrimitiveProceduralModelBase A PrimitiveProceduralModelBase object representing the generated 3D model. The dimensions of the model will be determined by the provided size or default dimensions if size is null. Remarks This method allows for the creation of different types of primitive 3D models (such as Cube, Sphere, etc.) with the specified size. If no size is provided, default dimensions for each model type will be used. Exceptions InvalidOperationException Thrown when an unsupported type is specified."
  },
  "api/Stride.CommunityToolkit.Rendering.ProceduralModels.SquareProceduralModel.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.ProceduralModels.SquareProceduralModel.html",
    "title": "Class SquareProceduralModel | Stride Community Toolkit",
    "summary": "Class SquareProceduralModel Namespace Stride.CommunityToolkit.Rendering.ProceduralModels Assembly Stride.CommunityToolkit.dll public class SquareProceduralModel : PrimitiveProceduralModelBase, IProceduralModel Inheritance object PrimitiveProceduralModelBase SquareProceduralModel Implements IProceduralModel Inherited Members PrimitiveProceduralModelBase.Scale PrimitiveProceduralModelBase.SetMaterial(string, Material) PrimitiveProceduralModelBase.Generate(IServiceRegistry) PrimitiveProceduralModelBase.Generate(IServiceRegistry, Model) PrimitiveProceduralModelBase.UvScale PrimitiveProceduralModelBase.LocalOffset PrimitiveProceduralModelBase.NumberOfTextureCoordinates PrimitiveProceduralModelBase.MaterialInstance PrimitiveProceduralModelBase.MaterialInstances Properties Size public Vector2 Size { get; set; } Property Value Vector2 Methods CreatePrimitiveMeshData() protected override GeometricMeshData<VertexPositionNormalTexture> CreatePrimitiveMeshData() Returns GeometricMeshData<VertexPositionNormalTexture> New(Vector2, float, float, bool) public static GeometricMeshData<VertexPositionNormalTexture> New(Vector2 size, float uScale = 1, float vScale = 1, bool toLeftHanded = false) Parameters size Vector2 uScale float vScale float toLeftHanded bool Returns GeometricMeshData<VertexPositionNormalTexture>"
  },
  "api/Stride.CommunityToolkit.Rendering.ProceduralModels.TriangleProceduralModel.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.ProceduralModels.TriangleProceduralModel.html",
    "title": "Class TriangleProceduralModel | Stride Community Toolkit",
    "summary": "Class TriangleProceduralModel Namespace Stride.CommunityToolkit.Rendering.ProceduralModels Assembly Stride.CommunityToolkit.dll public class TriangleProceduralModel : PrimitiveProceduralModelBase, IProceduralModel Inheritance object PrimitiveProceduralModelBase TriangleProceduralModel Implements IProceduralModel Inherited Members PrimitiveProceduralModelBase.Scale PrimitiveProceduralModelBase.SetMaterial(string, Material) PrimitiveProceduralModelBase.Generate(IServiceRegistry) PrimitiveProceduralModelBase.Generate(IServiceRegistry, Model) PrimitiveProceduralModelBase.UvScale PrimitiveProceduralModelBase.LocalOffset PrimitiveProceduralModelBase.NumberOfTextureCoordinates PrimitiveProceduralModelBase.MaterialInstance PrimitiveProceduralModelBase.MaterialInstances Properties Size public Vector2 Size { get; set; } Property Value Vector2 Methods CreatePrimitiveMeshData() protected override GeometricMeshData<VertexPositionNormalTexture> CreatePrimitiveMeshData() Returns GeometricMeshData<VertexPositionNormalTexture> New(Vector2, float, float, bool) public static GeometricMeshData<VertexPositionNormalTexture> New(Vector2 size, float uScale = 1, float vScale = 1, bool toLeftHanded = false) Parameters size Vector2 uScale float vScale float toLeftHanded bool Returns GeometricMeshData<VertexPositionNormalTexture>"
  },
  "api/Stride.CommunityToolkit.Rendering.ProceduralModels.TriangularPrismProceduralModel.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.ProceduralModels.TriangularPrismProceduralModel.html",
    "title": "Class TriangularPrismProceduralModel | Stride Community Toolkit",
    "summary": "Class TriangularPrismProceduralModel Namespace Stride.CommunityToolkit.Rendering.ProceduralModels Assembly Stride.CommunityToolkit.dll A triangular prism with a triangular face visible from the side. public class TriangularPrismProceduralModel : PrimitiveProceduralModelBase, IProceduralModel Inheritance object PrimitiveProceduralModelBase TriangularPrismProceduralModel Implements IProceduralModel Inherited Members PrimitiveProceduralModelBase.Scale PrimitiveProceduralModelBase.SetMaterial(string, Material) PrimitiveProceduralModelBase.Generate(IServiceRegistry) PrimitiveProceduralModelBase.Generate(IServiceRegistry, Model) PrimitiveProceduralModelBase.UvScale PrimitiveProceduralModelBase.LocalOffset PrimitiveProceduralModelBase.NumberOfTextureCoordinates PrimitiveProceduralModelBase.MaterialInstance PrimitiveProceduralModelBase.MaterialInstances Properties Size public Vector3 Size { get; set; } Property Value Vector3 Methods CreatePrimitiveMeshData() protected override GeometricMeshData<VertexPositionNormalTexture> CreatePrimitiveMeshData() Returns GeometricMeshData<VertexPositionNormalTexture> New(Vector3, float, float, bool) Creates a triangular prism. public static GeometricMeshData<VertexPositionNormalTexture> New(Vector3 size, float uScale = 1, float vScale = 1, bool toLeftHanded = false) Parameters size Vector3 uScale float vScale float toLeftHanded bool Returns GeometricMeshData<VertexPositionNormalTexture> A triangular prism."
  },
  "api/Stride.CommunityToolkit.Rendering.ProceduralModels.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.ProceduralModels.html",
    "title": "Namespace Stride.CommunityToolkit.Rendering.ProceduralModels | Stride Community Toolkit",
    "summary": "Namespace Stride.CommunityToolkit.Rendering.ProceduralModels Classes Procedural2DModelBuilder A helper class for generating 2D procedural models based on a specified primitive model type and size. Procedural3DModelBuilder A helper class for generating 3D procedural models based on a specified primitive model type and size. SquareProceduralModel TriangleProceduralModel TriangularPrismProceduralModel A triangular prism with a triangular face visible from the side. Enums Primitive2DModelType Specifies the types of 2D primitive models that can be created. PrimitiveModelType Specifies the type of primitive model to be created. Available options: Sphere, Cube, Cylinder, Torus, Plane, InfinitePlane, Teapot, Cone, Capsule. Source Stride.Assets.Presentation.Preview."
  },
  "api/Stride.CommunityToolkit.Rendering.Utilities.IndexingType.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.Utilities.IndexingType.html",
    "title": "Enum IndexingType | Stride Community Toolkit",
    "summary": "Enum IndexingType Namespace Stride.CommunityToolkit.Rendering.Utilities Assembly Stride.CommunityToolkit.dll public enum IndexingType Fields Int16 = 2 Use a short for vertex indices Int32 = 4 Use a int for vertex indices None = 0 Do not use vertex indexing"
  },
  "api/Stride.CommunityToolkit.Rendering.Utilities.MeshBuilder.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.Utilities.MeshBuilder.html",
    "title": "Class MeshBuilder | Stride Community Toolkit",
    "summary": "Class MeshBuilder Namespace Stride.CommunityToolkit.Rendering.Utilities Assembly Stride.CommunityToolkit.dll A utility class for building meshes by defining vertex elements with different data types and primitives types. public class MeshBuilder : IDisposable Inheritance object MeshBuilder Implements IDisposable Properties IndexCount The current index count public int IndexCount { get; } Property Value int IndexType The selected index type (default: None) public IndexingType IndexType { get; init; } Property Value IndexingType PrimitiveType The selected primitive type (default: TriangleList) public PrimitiveType PrimitiveType { get; init; } Property Value PrimitiveType VertexCount The current vertex count public int VertexCount { get; } Property Value int VertexElements The vertex elements including offsets public IReadOnlyList<VertexElementWithOffset> VertexElements { get; } Property Value IReadOnlyList<VertexElementWithOffset> Methods AddIndex(int) Adds a new vertex index public void AddIndex(int vertexIndex) Parameters vertexIndex int The vertex index Exceptions ArgumentOutOfRangeException The vertex index was outside the range of the currently added vertices ArgumentOutOfRangeException The vertex index was outside the range of the selected indexing mode InvalidOperationException The mesh builder isn't configured to use indices AddVertex() Adds a new vertex public int AddVertex() Returns int The vertex index (Can be used in GetElement<T>(int, int) and SetElement<T>(int, int, T)) Clear() Clears all buffers and elements configured in this instance public void Clear() Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() GetElement<T>(int) Gets the value for the specified element index public T GetElement<T>(int elementIndex) where T : unmanaged Parameters elementIndex int The element index Returns T The element at the element index Type Parameters T The element type to retrieve Remarks This overload always target's the last vertex index and is a convenience version of GetElement<T>(int, int) Exceptions ArgumentOutOfRangeException The vertex index was outside the range of the currently added vertices ArgumentOutOfRangeException The element index was outside the range of the currently added elements ArgumentException The size of T does not match the type used when defining this element GetElement<T>(int, int) Gets the value for the specified element index public T GetElement<T>(int vertexIndex, int elementIndex) where T : unmanaged Parameters vertexIndex int The vertex index elementIndex int The element index Returns T The element at the element index Type Parameters T The element type to retrieve Exceptions ArgumentOutOfRangeException The vertex index was outside the range of the currently added vertices ArgumentOutOfRangeException The element index was outside the range of the currently added elements ArgumentException The size of T does not match the type used when defining this element SetElement<T>(int, int, T) Sets the value for the specified element index public void SetElement<T>(int vertexIndex, int elementIndex, T value) where T : unmanaged Parameters vertexIndex int The vertex index elementIndex int The element index value T The value to set Type Parameters T The element type to retrieve Exceptions ArgumentOutOfRangeException The vertex index was outside the range of the currently added vertices ArgumentOutOfRangeException The element index was outside the range of the currently added elements ArgumentException The size of T does not match the type used when defining this element SetElement<T>(int, T) Sets the value for the specified element index public void SetElement<T>(int elementIndex, T value) where T : unmanaged Parameters elementIndex int The element index value T The value to set Type Parameters T The element type to retrieve Remarks This overload always target's the last vertex index and is a convenience version of SetElement<T>(int, int, T) Exceptions ArgumentOutOfRangeException The vertex index was outside the range of the currently added vertices ArgumentOutOfRangeException The element index was outside the range of the currently added elements ArgumentException The size of T does not match the type used when defining this element ToMeshDraw(GraphicsDevice, bool) Creates a new mesh draw instance public MeshDraw ToMeshDraw(GraphicsDevice device, bool clear = true) Parameters device GraphicsDevice The graphics device clear bool Determines if the mesh builder should be reset after this call Returns MeshDraw A mesh draw instance Exceptions InvalidOperationException The primitive type was not set to a valid value WithBiTangent<T>(int, string, PixelFormat) Registers a new vertex element public int WithBiTangent<T>(int semanticIndex = 0, string semanticName = \"BITANGENT\", PixelFormat pixelFormat = PixelFormat.None) where T : unmanaged Parameters semanticIndex int The semantic index semanticName string The semantic name pixelFormat PixelFormat The pixel format (use None to auto-detect) Returns int The element index used in GetElement<T>(int) and SetElement<T>(int, T) Type Parameters T The type of the position element WithColor<T>(int, string, PixelFormat) Registers a new vertex element public int WithColor<T>(int semanticIndex = 0, string semanticName = \"COLOR\", PixelFormat pixelFormat = PixelFormat.None) where T : unmanaged Parameters semanticIndex int The semantic index semanticName string The semantic name pixelFormat PixelFormat The pixel format (use None to auto-detect) Returns int The element index used in GetElement<T>(int) and SetElement<T>(int, T) Type Parameters T The type of the position element WithElement<T>(int, string, PixelFormat) Registers a new vertex element public int WithElement<T>(int semanticIndex, string semanticName, PixelFormat pixelFormat = PixelFormat.None) where T : unmanaged Parameters semanticIndex int The semantic index semanticName string The semantic name pixelFormat PixelFormat The pixel format (use None to auto-detect) Returns int The element index used in GetElement<T>(int) and SetElement<T>(int, T) Type Parameters T The type of the position element WithIndexType(IndexingType) Changes the selected indexing type. public void WithIndexType(IndexingType indexingType) Parameters indexingType IndexingType The selected indexing type Exceptions InvalidOperationException If vertices were already added changing the indexing type is no longer allowed WithNormal<T>(int, string, PixelFormat) Registers a new vertex element public int WithNormal<T>(int semanticIndex = 0, string semanticName = \"NORMAL\", PixelFormat pixelFormat = PixelFormat.None) where T : unmanaged Parameters semanticIndex int The semantic index semanticName string The semantic name pixelFormat PixelFormat The pixel format (use None to auto-detect) Returns int The element index used in GetElement<T>(int) and SetElement<T>(int, T) Type Parameters T The type of the position element WithPositionTransformed<T>(int, string, PixelFormat) Registers a new vertex element public int WithPositionTransformed<T>(int semanticIndex = 0, string semanticName = \"SV_POSITION\", PixelFormat pixelFormat = PixelFormat.None) where T : unmanaged Parameters semanticIndex int The semantic index semanticName string The semantic name pixelFormat PixelFormat The pixel format (use None to auto-detect) Returns int The element index used in GetElement<T>(int) and SetElement<T>(int, T) Type Parameters T The type of the position element WithPosition<T>(int, string, PixelFormat) Registers a new vertex element public int WithPosition<T>(int semanticIndex = 0, string semanticName = \"POSITION\", PixelFormat pixelFormat = PixelFormat.None) where T : unmanaged Parameters semanticIndex int The semantic index semanticName string The semantic name pixelFormat PixelFormat The pixel format (use None to auto-detect) Returns int The element index used in GetElement<T>(int) and SetElement<T>(int, T) Type Parameters T The type of the position element WithPrimitiveType(PrimitiveType) Changes the selected primitive type. public void WithPrimitiveType(PrimitiveType primitiveType) Parameters primitiveType PrimitiveType The selected primitive type Exceptions InvalidOperationException If vertices were already added changing the primitive type is no longer allowed WithTangent<T>(int, string, PixelFormat) Registers a new vertex element public int WithTangent<T>(int semanticIndex = 0, string semanticName = \"TANGENT\", PixelFormat pixelFormat = PixelFormat.None) where T : unmanaged Parameters semanticIndex int The semantic index semanticName string The semantic name pixelFormat PixelFormat The pixel format (use None to auto-detect) Returns int The element index used in GetElement<T>(int) and SetElement<T>(int, T) Type Parameters T The type of the position element WithTextureCoordinate<T>(int, string, PixelFormat) Registers a new vertex element public int WithTextureCoordinate<T>(int semanticIndex = 0, string semanticName = \"TEXCOORD\", PixelFormat pixelFormat = PixelFormat.None) where T : unmanaged Parameters semanticIndex int The semantic index semanticName string The semantic name pixelFormat PixelFormat The pixel format (use None to auto-detect) Returns int The element index used in GetElement<T>(int) and SetElement<T>(int, T) Type Parameters T The type of the position element"
  },
  "api/Stride.CommunityToolkit.Rendering.Utilities.TextureCanvas.Anchor.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.Utilities.TextureCanvas.Anchor.html",
    "title": "Enum TextureCanvas.Anchor | Stride Community Toolkit",
    "summary": "Enum TextureCanvas.Anchor Namespace Stride.CommunityToolkit.Rendering.Utilities Assembly Stride.CommunityToolkit.dll Anchor positions when drawing to a TextureCanvas public enum TextureCanvas.Anchor Fields Bottom = 7 Adjust the position so the bottom-edge center of the source and target rect are aligned. BottomLeft = 6 Adjust the position so the bottom-left corner of the source and target rect are aligned. BottomRight = 8 Adjust the position so the bottom-right corner of the source and target rect are aligned. Center = 4 Adjust the position so the center of the source and target rect are aligned. Left = 3 Adjust the position so the left-edge center of the source and target rect are aligned. Right = 5 Adjust the position so the right-edge center of the source and target rect are aligned. Top = 1 Adjust the position so the top-edge center of the source and target rect are aligned. TopLeft = 0 Adjust the position so the top-left corner of the source and target rect are aligned. TopRight = 2 Adjust the position so the top-right corner of the source and target rect are aligned."
  },
  "api/Stride.CommunityToolkit.Rendering.Utilities.TextureCanvas.Stretch.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.Utilities.TextureCanvas.Stretch.html",
    "title": "Enum TextureCanvas.Stretch | Stride Community Toolkit",
    "summary": "Enum TextureCanvas.Stretch Namespace Stride.CommunityToolkit.Rendering.Utilities Assembly Stride.CommunityToolkit.dll Stretch modes when textures to a TextureCanvas public enum TextureCanvas.Stretch Fields Contain = 2 The texture is resized to fit in the destination dimensions while it preserves its native aspect ratio. Cover = 3 The texture is resized to fill the destination dimensions while it preserves its native aspect ratio. If the aspect ratio of the destination rectangle differs from the source, the source texture is clipped to fit in the destination dimensions. None = 0 The texture preserves its original size. Overflowing content is cropped. Stretch = 1 The texture is resized to fill the destination dimensions. The aspect ratio is not preserved."
  },
  "api/Stride.CommunityToolkit.Rendering.Utilities.TextureCanvas.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.Utilities.TextureCanvas.html",
    "title": "Class TextureCanvas | Stride Community Toolkit",
    "summary": "Class TextureCanvas Namespace Stride.CommunityToolkit.Rendering.Utilities Assembly Stride.CommunityToolkit.dll Provides functionality for drawing and manipulating textures on a canvas. This class supports various operations such as drawing rectangles, drawing textures, applying filters, transforming colors, and resampling textures. It is designed to work with the Stride graphics framework and provides methods for loading and storing texture data. public class TextureCanvas : IDisposable Inheritance object TextureCanvas Implements IDisposable Constructors TextureCanvas(RenderContext, Size2?, PixelFormat) Initializes a new instance of the TextureCanvas class. public TextureCanvas(RenderContext renderContext, Size2? size, PixelFormat pixelFormat = PixelFormat.R8G8B8A8_UNorm) Parameters renderContext RenderContext size Size2? pixelFormat PixelFormat Properties ByteSize Calculates the texture size in bytes public int ByteSize { get; } Property Value int PixelFormat Gets or sets the current pixel format public PixelFormat PixelFormat { get; set; } Property Value PixelFormat Remarks Setting a different pixel format may cause a resample of the already drawn back buffer or call the setter before you start drawing. You may consider using Resample(Size2, PixelFormat, SamplingPattern) if you also want to change the size in a single operation. Size Gets or sets the current texture size public Size2 Size { get; set; } Property Value Size2 Remarks Setting a different size may cause a resample of the already drawn back buffer or call the setter before you start drawing. You may consider using Resample(Size2, PixelFormat, SamplingPattern) if you also want to change the pixel format in a single operation. Methods Apply(ImageEffect, params Texture?[]?) Applies an image effect to the buffer texture public void Apply(ImageEffect effect, params Texture?[]? inputs) Parameters effect ImageEffect The image effect to apply inputs Texture[] The input textures Remarks Null, Empty arrays or array entries with null as a value will be replaced by the current drawing buffer The output will always be replaced by the TextureCanvas as a single output. BrightFilter(float, float, Color3?) Applies a BrightFilter effect. public void BrightFilter(float threshold = 0.2, float steepness = 1, Color3? colorMultiplier = null) Parameters threshold float The threshold relative to the white point steepness float the smooth-step steepness for bright pass filtering. colorMultiplier Color3? Modulates bright areas with the provided color. It affects the color of sub-sequent bloom, light-streak effects Clear() Clears the current drawing context and releases internal texture buffers public void Clear() CoCMapBlur(int) Applies a CoCMapBlur effect. public void CoCMapBlur(int radius = 4) Parameters radius int The radius. Colorize(Color4) Applies a color multiply effect. public void Colorize(Color4 colorMultiplier) Parameters colorMultiplier Color4 The color multiplier Combine(Texture?[]?, float[]?, Color3[]?) Applies a ColorCombiner effect. public void Combine(Texture?[]? textures = null, float[]? factors = null, Color3[]? colorMultipliers = null) Parameters textures Texture[] The textures combine (use null to use the current drawing buffer as a texture input) factors float[] The factors used to multiply the colors. colorMultipliers Color3[] The color multiplier of each texture. Default is White Remarks Null, Empty arrays or array entries with null as a value will be replaced by the current drawing buffer Dispose() Releases all resources used by the TextureCanvas object. public void Dispose() DrawRect(Rectangle, Stretch, Anchor, SamplingPattern) Draws a rectangle on the canvas. public void DrawRect(Rectangle destinationRect, TextureCanvas.Stretch stretch = Stretch.Stretch, TextureCanvas.Anchor anchor = Anchor.TopLeft, SamplingPattern samplingPattern = SamplingPattern.Linear) Parameters destinationRect Rectangle The destination rectangle where the rectangle will be drawn. stretch TextureCanvas.Stretch The stretch mode to apply to the rectangle. anchor TextureCanvas.Anchor The anchor point for the rectangle. samplingPattern SamplingPattern The sampling pattern to use for drawing. DrawTexture(Texture, Rectangle, Rectangle, Color4?, Stretch, Anchor, SamplingPattern) Draws a texture to the TextureCanvas public void DrawTexture(Texture sourceTexture, Rectangle sourceRect, Rectangle destinationRect, Color4? colorMultiplier = null, TextureCanvas.Stretch stretch = Stretch.Stretch, TextureCanvas.Anchor anchor = Anchor.TopLeft, SamplingPattern samplingPattern = SamplingPattern.Linear) Parameters sourceTexture Texture The source texture to draw sourceRect Rectangle The sub rectangle of the source texture to draw destinationRect Rectangle The sub rectangle of the target texture colorMultiplier Color4? The color multiplier. Default is White stretch TextureCanvas.Stretch The stretch mode anchor TextureCanvas.Anchor The anchor mode samplingPattern SamplingPattern The sampling pattern DrawTexture(Texture, Rectangle, Color4?, Stretch, Anchor, SamplingPattern) Draws a texture to the TextureCanvas public void DrawTexture(Texture sourceTexture, Rectangle destinationRect, Color4? colorMultiplier = null, TextureCanvas.Stretch stretch = Stretch.Stretch, TextureCanvas.Anchor anchor = Anchor.TopLeft, SamplingPattern samplingPattern = SamplingPattern.Linear) Parameters sourceTexture Texture The source texture to draw destinationRect Rectangle The sub rectangle of the target texture in percentages colorMultiplier Color4? The color multiplier. Default is White stretch TextureCanvas.Stretch The stretch mode anchor TextureCanvas.Anchor The anchor mode samplingPattern SamplingPattern The sampling pattern DrawTexture(Texture, RectangleF, RectangleF, Color4?, Stretch, Anchor, SamplingPattern) Draws a texture to the TextureCanvas using rectangles with percentage values public void DrawTexture(Texture sourceTexture, RectangleF relativeSourceRect, RectangleF relativeDestinationRect, Color4? colorMultiplier = null, TextureCanvas.Stretch stretch = Stretch.Stretch, TextureCanvas.Anchor anchor = Anchor.TopLeft, SamplingPattern samplingPattern = SamplingPattern.Linear) Parameters sourceTexture Texture The source texture to draw relativeSourceRect RectangleF The sub rectangle of the source texture to draw in percentages relativeDestinationRect RectangleF The sub rectangle of the target texture in percentages colorMultiplier Color4? The color multiplier. Default is White stretch TextureCanvas.Stretch The stretch mode anchor TextureCanvas.Anchor The anchor mode samplingPattern SamplingPattern The sampling pattern DrawTexture(Texture, RectangleF, Color4?, Stretch, Anchor, SamplingPattern) Draws a texture to the TextureCanvas using a rectangle with percentage values public void DrawTexture(Texture sourceTexture, RectangleF relativeDestinationRect, Color4? colorMultiplier = null, TextureCanvas.Stretch stretch = Stretch.Stretch, TextureCanvas.Anchor anchor = Anchor.TopLeft, SamplingPattern samplingPattern = SamplingPattern.Linear) Parameters sourceTexture Texture The source texture to draw relativeDestinationRect RectangleF The sub rectangle of the target texture in percentages colorMultiplier Color4? The color multiplier. Default is White stretch TextureCanvas.Stretch The stretch mode anchor TextureCanvas.Anchor The anchor mode samplingPattern SamplingPattern The sampling pattern DrawTexture(Texture, Color4?, Stretch, Anchor, SamplingPattern) Draws a texture to the drawing context public void DrawTexture(Texture sourceTexture, Color4? colorMultiplier = null, TextureCanvas.Stretch stretch = Stretch.Stretch, TextureCanvas.Anchor anchor = Anchor.TopLeft, SamplingPattern samplingPattern = SamplingPattern.Linear) Parameters sourceTexture Texture The source texture to draw colorMultiplier Color4? The color multiplier. Default is White stretch TextureCanvas.Stretch The stretch mode anchor TextureCanvas.Anchor The anchor mode samplingPattern SamplingPattern The sampling pattern GaussianBlur(int, float) Applies a GaussianBlur effect. public void GaussianBlur(int radius = 4, float sigmaRatio = 2) Parameters radius int The radius. sigmaRatio float The sigma ratio. The sigma ratio is used to calculate the sigma based on the radius: The actual formula is sigma = radius / SigmaRatio. The default value is 2.0f. GetData() Copies the current texture data to a byte array public byte[] GetData() Returns byte[] GetData(byte[]) Copies the current texture data to a byte array public void GetData(byte[] data) Parameters data byte[] The data array to store the data Load(byte[]) Replaces the current TextureCanvas with a texture loaded from a byte[] public void Load(byte[] data) Parameters data byte[] The byte[] containing file data Remarks This method also replaces the current size and pixel format. Use Resample(Size2, PixelFormat, SamplingPattern) to change it afterwards. Load(Stream) Replaces the current TextureCanvas with a texture loaded from a Stream public void Load(Stream stream) Parameters stream Stream The Stream containing file data Remarks This method also replaces the current size and pixel format. Use Resample(Size2, PixelFormat, SamplingPattern) to change it afterwards. Load(string) Replaces the current TextureCanvas with a texture loaded from the local file system public void Load(string path) Parameters path string The file path Remarks This method also replaces the current size and pixel format. Use Resample(Size2, PixelFormat, SamplingPattern) to change it afterwards. Recolorize(Color4?) Applies a grey scale effect by copying the red channel to blue and green and optionally also recolors the resulting image. public void Recolorize(Color4? colorMultiplier = null) Parameters colorMultiplier Color4? The color multiplier. Default is White Resample(Size2, PixelFormat, SamplingPattern) Resamples the texture in a different size or pixel format public void Resample(Size2 size, PixelFormat pixelFormat, SamplingPattern samplingPattern = SamplingPattern.Linear) Parameters size Size2 The new size pixelFormat PixelFormat The new pixel format samplingPattern SamplingPattern The sampling pattern SetData(byte[], int, int, PixelFormat) Replaces the current TextureCanvas with a texture loaded from a byte[] containing pixel data public void SetData(byte[] data, int width, int height, PixelFormat pixelFormat) Parameters data byte[] The byte[] containing pixel data width int The width of the new texture height int The height of the new texture pixelFormat PixelFormat The pixel format of the new texture Remarks This method also replaces the current size and pixel format. Use Resample(Size2, PixelFormat, SamplingPattern) to change it afterwards. Store(Stream, ImageFileType) Stores the current texture to a Stream in the selected file format public void Store(Stream stream, ImageFileType fileType) Parameters stream Stream The target stream fileType ImageFileType The file type to write Store(string, ImageFileType?) Stores the current texture to a file in the local file system. public void Store(string path, ImageFileType? fileType = null) Parameters path string The target file path fileType ImageFileType? The file type to write or null for automatic inference based on the file extension ToTexture(TextureFlags) Copies the current texture data to a new texture public Texture ToTexture(TextureFlags flags = TextureFlags.ShaderResource) Parameters flags TextureFlags Returns Texture Transform(IEnumerable<ColorTransform>?, IEnumerable<ColorTransform>?, IEnumerable<ColorTransform>?) Applies a ColorTransformGroup effect. public void Transform(IEnumerable<ColorTransform>? transforms = null, IEnumerable<ColorTransform>? preTransforms = null, IEnumerable<ColorTransform>? postTransforms = null) Parameters transforms IEnumerable<ColorTransform> The color transforms to apply preTransforms IEnumerable<ColorTransform> The color pre-transforms to apply postTransforms IEnumerable<ColorTransform> The color post-transforms to apply"
  },
  "api/Stride.CommunityToolkit.Rendering.Utilities.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.Utilities.html",
    "title": "Namespace Stride.CommunityToolkit.Rendering.Utilities | Stride Community Toolkit",
    "summary": "Namespace Stride.CommunityToolkit.Rendering.Utilities Classes MeshBuilder A utility class for building meshes by defining vertex elements with different data types and primitives types. TextureCanvas Provides functionality for drawing and manipulating textures on a canvas. This class supports various operations such as drawing rectangles, drawing textures, applying filters, transforming colors, and resampling textures. It is designed to work with the Stride graphics framework and provides methods for loading and storing texture data. Enums IndexingType TextureCanvas.Anchor Anchor positions when drawing to a TextureCanvas TextureCanvas.Stretch Stretch modes when textures to a TextureCanvas"
  },
  "api/Stride.CommunityToolkit.Rendering.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.html",
    "title": "Namespace Stride.CommunityToolkit.Rendering | Stride Community Toolkit",
    "summary": "Namespace Stride.CommunityToolkit.Rendering Classes MaterialExtensions Extension methods for Material."
  },
  "api/Stride.CommunityToolkit.Scripts.Basic2DCameraController.html": {
    "href": "api/Stride.CommunityToolkit.Scripts.Basic2DCameraController.html",
    "title": "Class Basic2DCameraController | Stride Community Toolkit",
    "summary": "Class Basic2DCameraController Namespace Stride.CommunityToolkit.Scripts Assembly Stride.CommunityToolkit.dll Provides an interactive 2D camera controller for navigating 2D scenes in Stride. This controller supports movement in the XY-plane using keyboard inputs (W, A, S, D, arrow keys), zooming in and out with the mouse wheel, and moving the camera based on mouse position near screen edges. Additional features include a speed boost when holding shift and the ability to reset the camera to a default position and zoom level using the 'H' key. public class Basic2DCameraController : SyncScript, IIdentifiable, ICollectorHolder Inheritance object EntityComponent ScriptComponent StartupScript SyncScript Basic2DCameraController Implements IIdentifiable ICollectorHolder Inherited Members ScriptComponent.LiveScriptingMask ScriptComponent.ScriptGlobalProfilingKey ScriptComponent.PriorityUpdated() ScriptComponent.Cancel() ScriptComponent.ProfilingKey ScriptComponent.Audio ScriptComponent.SpriteAnimation ScriptComponent.Services ScriptComponent.Game ScriptComponent.Content ScriptComponent.GameProfiler ScriptComponent.GraphicsDevice ScriptComponent.Input ScriptComponent.Script ScriptComponent.SceneSystem ScriptComponent.EffectSystem ScriptComponent.DebugText ScriptComponent.Streaming ScriptComponent.Log ScriptComponent.Priority ScriptComponent.IsLiveReloading ScriptComponent.Collector EntityComponent.Entity EntityComponent.Id EntityComponent.EnsureEntity Extension Methods ScriptComponentExtensions.DeltaTime(ScriptComponent) ScriptComponentExtensions.GetFirstGCCamera(ScriptComponent) ScriptComponentExtensions.GetGCCamera(ScriptComponent) ScriptComponentExtensions.GetGCCamera(ScriptComponent, string) Remarks The camera moves at a default speed which can be increased with shift keys. Zooming is performed by changing the OrthographicSize of the camera. The camera can be moved towards the edges of the screen when the mouse cursor is close to them. The 'H' key resets the camera to its default position and orthographic size. Default settings: FarClipPlane=1000, NearClipPlane=0.1f, OrthographicSize=10. Methods Start() Called before the script enters it's update loop. public override void Start() Update() Called every frame. public override void Update()"
  },
  "api/Stride.CommunityToolkit.Scripts.Basic3DCameraController.html": {
    "href": "api/Stride.CommunityToolkit.Scripts.Basic3DCameraController.html",
    "title": "Class Basic3DCameraController | Stride Community Toolkit",
    "summary": "Class Basic3DCameraController Namespace Stride.CommunityToolkit.Scripts Assembly Stride.CommunityToolkit.dll A script that allows to move and rotate an entity through keyboard, mouse and touch input to provide basic camera navigation. public class Basic3DCameraController : SyncScript, IIdentifiable, ICollectorHolder Inheritance object EntityComponent ScriptComponent StartupScript SyncScript Basic3DCameraController Implements IIdentifiable ICollectorHolder Inherited Members ScriptComponent.LiveScriptingMask ScriptComponent.ScriptGlobalProfilingKey ScriptComponent.PriorityUpdated() ScriptComponent.Cancel() ScriptComponent.ProfilingKey ScriptComponent.Audio ScriptComponent.SpriteAnimation ScriptComponent.Services ScriptComponent.Game ScriptComponent.Content ScriptComponent.GameProfiler ScriptComponent.GraphicsDevice ScriptComponent.Input ScriptComponent.Script ScriptComponent.SceneSystem ScriptComponent.EffectSystem ScriptComponent.DebugText ScriptComponent.Streaming ScriptComponent.Log ScriptComponent.Priority ScriptComponent.IsLiveReloading ScriptComponent.Collector EntityComponent.Entity EntityComponent.Id EntityComponent.EnsureEntity Extension Methods ScriptComponentExtensions.DeltaTime(ScriptComponent) ScriptComponentExtensions.GetFirstGCCamera(ScriptComponent) ScriptComponentExtensions.GetGCCamera(ScriptComponent) ScriptComponentExtensions.GetGCCamera(ScriptComponent, string) Remarks The entity can be moved using W, A, S, D, Q and E, arrow keys, a gamepad's left stick or dragging/scaling using multi-touch. Rotation is achieved using the Numpad, the mouse while holding the right mouse button, a gamepad's right stick, or dragging using single-touch. This functionality is inspired by Stride.Assets.Presentation, Assets->Scripts->Camera Properties Gamepad public bool Gamepad { get; set; } Property Value bool KeyboardMovementSpeed public Vector3 KeyboardMovementSpeed { get; set; } Property Value Vector3 KeyboardRotationSpeed public Vector2 KeyboardRotationSpeed { get; set; } Property Value Vector2 MouseRotationSpeed public Vector2 MouseRotationSpeed { get; set; } Property Value Vector2 SpeedFactor public float SpeedFactor { get; set; } Property Value float TouchMovementSpeed public Vector3 TouchMovementSpeed { get; set; } Property Value Vector3 TouchRotationSpeed public Vector2 TouchRotationSpeed { get; set; } Property Value Vector2 Methods Start() Called before the script enters it's update loop. public override void Start() Update() Called every frame. public override void Update()"
  },
  "api/Stride.CommunityToolkit.Scripts.GameProfiler.html": {
    "href": "api/Stride.CommunityToolkit.Scripts.GameProfiler.html",
    "title": "Class GameProfiler | Stride Community Toolkit",
    "summary": "Class GameProfiler Namespace Stride.CommunityToolkit.Scripts Assembly Stride.CommunityToolkit.dll Provides in-game profiling functionality, allowing the monitoring and analysis of game performance in real time. This script facilitates the toggling of profiling, setting display preferences, and navigating through profiling data. public class GameProfiler : AsyncScript, IIdentifiable, ICollectorHolder Inheritance object EntityComponent ScriptComponent AsyncScript GameProfiler Implements IIdentifiable ICollectorHolder Inherited Members AsyncScript.PriorityUpdated() AsyncScript.CancellationToken ScriptComponent.LiveScriptingMask ScriptComponent.ScriptGlobalProfilingKey ScriptComponent.Cancel() ScriptComponent.ProfilingKey ScriptComponent.Audio ScriptComponent.SpriteAnimation ScriptComponent.Services ScriptComponent.Game ScriptComponent.Content ScriptComponent.GameProfiler ScriptComponent.GraphicsDevice ScriptComponent.Input ScriptComponent.Script ScriptComponent.SceneSystem ScriptComponent.EffectSystem ScriptComponent.DebugText ScriptComponent.Streaming ScriptComponent.Log ScriptComponent.Priority ScriptComponent.IsLiveReloading ScriptComponent.Collector EntityComponent.Entity EntityComponent.Id EntityComponent.EnsureEntity Extension Methods ScriptComponentExtensions.DeltaTime(ScriptComponent) ScriptComponentExtensions.GetFirstGCCamera(ScriptComponent) ScriptComponentExtensions.GetGCCamera(ScriptComponent) ScriptComponentExtensions.GetGCCamera(ScriptComponent, string) Remarks This class provides keyboard shortcuts for toggling the profiler on/off with Shift + Ctrl + P, changing the filtering mode with F1, altering the sorting mode with F2, navigating result pages with F3 and F4, and adjusting the refresh interval with the plus and minus keys. Properties Enabled Enables or disable the game profiling public bool Enabled { get; set; } Property Value bool FilteringMode Gets or sets the type of the profiling to display: CPU or GPU [Display(0, \"Filter\", null)] public GameProfilingResults FilteringMode { get; set; } Property Value GameProfilingResults RefreshTime The time between two refreshes of the profiling information in milliseconds. [Display(2, \"Refresh interval (ms)\", null)] public double RefreshTime { get; set; } Property Value double ResultPage Gets or sets the current profiling result page to display. [Display(3, \"Display page\", null)] public uint ResultPage { get; set; } Property Value uint SortingMode Gets or set the sorting mode of the profiling entries [Display(1, \"Sort by\", null)] public GameProfilingSorting SortingMode { get; set; } Property Value GameProfilingSorting TextColor The color of the text displayed during profiling [Display(4, \"Text color\", null)] public Color TextColor { get; set; } Property Value Color Methods Execute() Called once, as a microthread public override Task Execute() Returns Task"
  },
  "api/Stride.CommunityToolkit.Scripts.GizmoBillboardLetterScript.html": {
    "href": "api/Stride.CommunityToolkit.Scripts.GizmoBillboardLetterScript.html",
    "title": "Class GizmoBillboardLetterScript | Stride Community Toolkit",
    "summary": "Class GizmoBillboardLetterScript Namespace Stride.CommunityToolkit.Scripts Assembly Stride.CommunityToolkit.dll public class GizmoBillboardLetterScript : SyncScript, IIdentifiable, ICollectorHolder Inheritance object EntityComponent ScriptComponent StartupScript SyncScript GizmoBillboardLetterScript Implements IIdentifiable ICollectorHolder Inherited Members StartupScript.Start() ScriptComponent.LiveScriptingMask ScriptComponent.ScriptGlobalProfilingKey ScriptComponent.PriorityUpdated() ScriptComponent.Cancel() ScriptComponent.ProfilingKey ScriptComponent.Audio ScriptComponent.SpriteAnimation ScriptComponent.Services ScriptComponent.Game ScriptComponent.Content ScriptComponent.GameProfiler ScriptComponent.GraphicsDevice ScriptComponent.Input ScriptComponent.Script ScriptComponent.SceneSystem ScriptComponent.EffectSystem ScriptComponent.DebugText ScriptComponent.Streaming ScriptComponent.Log ScriptComponent.Priority ScriptComponent.IsLiveReloading ScriptComponent.Collector EntityComponent.Entity EntityComponent.Id EntityComponent.EnsureEntity Extension Methods ScriptComponentExtensions.DeltaTime(ScriptComponent) ScriptComponentExtensions.GetFirstGCCamera(ScriptComponent) ScriptComponentExtensions.GetGCCamera(ScriptComponent) ScriptComponentExtensions.GetGCCamera(ScriptComponent, string) Properties DefaultRotation public int DefaultRotation { get; set; } Property Value int Methods GetGCCamera() public CameraComponent? GetGCCamera() Returns CameraComponent Update() Called every frame. public override void Update() UpdateLetterRotation(Vector3) public void UpdateLetterRotation(Vector3 cameraPosition) Parameters cameraPosition Vector3"
  },
  "api/Stride.CommunityToolkit.Scripts.RaySegment.html": {
    "href": "api/Stride.CommunityToolkit.Scripts.RaySegment.html",
    "title": "Struct RaySegment | Stride Community Toolkit",
    "summary": "Struct RaySegment Namespace Stride.CommunityToolkit.Scripts Assembly Stride.CommunityToolkit.dll Represents a three dimensional line based on a 2 points in space. [DataContract] public struct RaySegment : IEquatable<RaySegment>, IFormattable Implements IEquatable<RaySegment> IFormattable Constructors RaySegment(Vector3, Vector3) Initializes a new instance of the RaySegment struct. public RaySegment(Vector3 start, Vector3 end) Parameters start Vector3 The position in three dimensional space where the ray starts. end Vector3 The position in three dimensional space where the ray ends. Properties End The position in three dimensional space where the ray ends. public Vector3 End { readonly get; init; } Property Value Vector3 Length Length of RaySegment public float Length { get; } Property Value float Start The position in three dimensional space where the ray starts. public Vector3 Start { readonly get; init; } Property Value Vector3 Methods Equals(RaySegment) Determines whether the specified Vector4 is equal to this instance. public bool Equals(RaySegment value) Parameters value RaySegment The Vector4 to compare with this instance. Returns bool true if the specified Vector4 is equal to this instance; otherwise, false. Equals(object?) Determines whether the specified Object is equal to this instance. public override bool Equals(object? value) Parameters value object The Object to compare with this instance. Returns bool true if the specified Object is equal to this instance; otherwise, false. GetHashCode() Returns a hash code for this instance. public override int GetHashCode() Returns int A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. ToString() Returns a string that represents this instance. public override string ToString() Returns string A string that represents this instance. ToString(IFormatProvider) Returns a string that represents this instance. public string ToString(IFormatProvider formatProvider) Parameters formatProvider IFormatProvider The format provider. Returns string A string that represents this instance. ToString(string) Returns a string that represents this instance. public string ToString(string format) Parameters format string The format. Returns string A string that represents this instance. ToString(string?, IFormatProvider?) Returns a string that represents this instance. public string ToString(string? format, IFormatProvider? formatProvider) Parameters format string The format. formatProvider IFormatProvider The format provider. Returns string A string that represents this instance. Operators operator ==(RaySegment, RaySegment) Tests for equality between two objects. public static bool operator ==(RaySegment left, RaySegment right) Parameters left RaySegment The first value to compare. right RaySegment The second value to compare. Returns bool true if left has the same value as right; otherwise, false. explicit operator Ray(RaySegment) Performs an explicit conversion from RaySegment to Ray. public static explicit operator Ray(RaySegment raySegment) Parameters raySegment RaySegment The RaySegment to convert Returns Ray The result of the conversion. operator !=(RaySegment, RaySegment) Tests for inequality between two objects. public static bool operator !=(RaySegment left, RaySegment right) Parameters left RaySegment The first value to compare. right RaySegment The second value to compare. Returns bool true if left has a different value than right; otherwise, false."
  },
  "api/Stride.CommunityToolkit.Scripts.Utilities.DebugTextPrinter.html": {
    "href": "api/Stride.CommunityToolkit.Scripts.Utilities.DebugTextPrinter.html",
    "title": "Class DebugTextPrinter | Stride Community Toolkit",
    "summary": "Class DebugTextPrinter Namespace Stride.CommunityToolkit.Scripts.Utilities Assembly Stride.CommunityToolkit.dll A utility class for printing debug text to the screen at various positions. Manages the layout of text, allowing it to be displayed in different areas of the screen and handling multi-line printing. public class DebugTextPrinter Inheritance object DebugTextPrinter Properties DebugTextSystem Gets or sets the debug text system responsible for rendering text to the screen. public required DebugTextSystem DebugTextSystem { get; init; } Property Value DebugTextSystem Instructions Gets or sets the list of text elements (instructions) to be printed on the screen. public List<TextElement> Instructions { get; init; } Property Value List<TextElement> ScreenSize Gets or sets the screen size, which defines the boundaries for placing text on the screen. public Int2 ScreenSize { get; init; } Property Value Int2 TextSize Gets or sets the size of the text elements, typically defining the dimensions of each line of text. public Int2 TextSize { get; init; } Property Value Int2 Methods ChangeStartPosition() Changes the starting position for printing text, rotating through predefined screen positions (TopRight, BottomRight, BottomLeft, TopLeft). public void ChangeStartPosition() Initialize() Initializes the screen position by setting the starting position based on the current display position. public void Initialize() Initialize(DisplayPosition) Initializes the screen position by setting the starting position based on the specified display position. public void Initialize(DisplayPosition startPosition) Parameters startPosition DisplayPosition Print() Prints all text elements in the Instructions list, rendering them line by line on the screen. public void Print() Print(List<TextElement>) Prints the specified list of text elements, rendering them line by line on the screen. public void Print(List<TextElement> textElements) Parameters textElements List<TextElement>"
  },
  "api/Stride.CommunityToolkit.Scripts.Utilities.DisplayPosition.html": {
    "href": "api/Stride.CommunityToolkit.Scripts.Utilities.DisplayPosition.html",
    "title": "Enum DisplayPosition | Stride Community Toolkit",
    "summary": "Enum DisplayPosition Namespace Stride.CommunityToolkit.Scripts.Utilities Assembly Stride.CommunityToolkit.dll Represents the possible positions on the screen where text or other UI elements can be displayed. public enum DisplayPosition Fields BottomLeft = 2 Displays the element in the bottom-left corner of the screen. BottomRight = 3 Displays the element in the bottom-right corner of the screen. TopLeft = 0 Displays the element in the top-left corner of the screen. TopRight = 1 Displays the element in the top-right corner of the screen."
  },
  "api/Stride.CommunityToolkit.Scripts.Utilities.TextElement.html": {
    "href": "api/Stride.CommunityToolkit.Scripts.Utilities.TextElement.html",
    "title": "Class TextElement | Stride Community Toolkit",
    "summary": "Class TextElement Namespace Stride.CommunityToolkit.Scripts.Utilities Assembly Stride.CommunityToolkit.dll Represents a text element with optional color information. public record TextElement : IEquatable<TextElement> Inheritance object TextElement Implements IEquatable<TextElement> Constructors TextElement(string, Color?) Represents a text element with optional color information. public TextElement(string Text, Color? Color = null) Parameters Text string The text content to be displayed. Color Color? The optional color for the text. If null, a default color will be used. Properties Color The optional color for the text. If null, a default color will be used. public Color? Color { get; init; } Property Value Color? Text The text content to be displayed. public string Text { get; init; } Property Value string"
  },
  "api/Stride.CommunityToolkit.Scripts.Utilities.html": {
    "href": "api/Stride.CommunityToolkit.Scripts.Utilities.html",
    "title": "Namespace Stride.CommunityToolkit.Scripts.Utilities | Stride Community Toolkit",
    "summary": "Namespace Stride.CommunityToolkit.Scripts.Utilities Classes DebugTextPrinter A utility class for printing debug text to the screen at various positions. Manages the layout of text, allowing it to be displayed in different areas of the screen and handling multi-line printing. TextElement Represents a text element with optional color information. Enums DisplayPosition Represents the possible positions on the screen where text or other UI elements can be displayed."
  },
  "api/Stride.CommunityToolkit.Scripts.html": {
    "href": "api/Stride.CommunityToolkit.Scripts.html",
    "title": "Namespace Stride.CommunityToolkit.Scripts | Stride Community Toolkit",
    "summary": "Namespace Stride.CommunityToolkit.Scripts Classes Basic2DCameraController Provides an interactive 2D camera controller for navigating 2D scenes in Stride. This controller supports movement in the XY-plane using keyboard inputs (W, A, S, D, arrow keys), zooming in and out with the mouse wheel, and moving the camera based on mouse position near screen edges. Additional features include a speed boost when holding shift and the ability to reset the camera to a default position and zoom level using the 'H' key. Basic3DCameraController A script that allows to move and rotate an entity through keyboard, mouse and touch input to provide basic camera navigation. GameProfiler Provides in-game profiling functionality, allowing the monitoring and analysis of game performance in real time. This script facilitates the toggling of profiling, setting display preferences, and navigating through profiling data. GizmoBillboardLetterScript Structs RaySegment Represents a three dimensional line based on a 2 points in space."
  },
  "api/Stride.CommunityToolkit.Skyboxes.GameExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Skyboxes.GameExtensions.html",
    "title": "Class GameExtensions | Stride Community Toolkit",
    "summary": "Class GameExtensions Namespace Stride.CommunityToolkit.Skyboxes Assembly Stride.CommunityToolkit.Skyboxes.dll Provides extension methods for the Game class to enhance functionality such as adding skyboxes and other game elements. public static class GameExtensions Inheritance object GameExtensions Remarks These methods allow for easy integration of common game elements into a Stride game project, reducing the need for manual setup. Methods AddSkybox(Game, string?) Adds a skybox to the specified game scene, providing a background texture to create a more immersive environment. public static Entity AddSkybox(this Game game, string? entityName = \"Skybox\") Parameters game Game The Game instance to which the skybox will be added. entityName string The optional name for the skybox entity. If null, a default name (\"Skybox\") will be used. Returns Entity The created Entity representing the skybox. Examples This example demonstrates how to add a skybox to a game: game.AddSkybox(); Remarks The skybox texture is loaded from the Resources folder and is used to generate a skybox using the SkyboxGenerator. The skybox entity is created with both a BackgroundComponent and a LightComponent, configured for the skybox. The entity is added to the root scene of the game and placed at the default position (0.0f, 2.0f, -2.0f)."
  },
  "api/Stride.CommunityToolkit.Skyboxes.SkyboxGenerator.html": {
    "href": "api/Stride.CommunityToolkit.Skyboxes.SkyboxGenerator.html",
    "title": "Class SkyboxGenerator | Stride Community Toolkit",
    "summary": "Class SkyboxGenerator Namespace Stride.CommunityToolkit.Skyboxes Assembly Stride.CommunityToolkit.Skyboxes.dll Provides functionality to generate a skybox with diffuse and specular lighting parameters from a given texture. public static class SkyboxGenerator Inheritance object SkyboxGenerator Remarks This class handles the conversion of a texture to a cubemap, performs spherical harmonics filtering for diffuse lighting, and prefilters the texture for specular lighting using GGX reflection. The original logic is from Stride.Assets.Skyboxes Methods Generate(Skybox, SkyboxGeneratorContext, Texture) Generates a skybox using the provided texture and context, applying both diffuse and specular lighting. public static Skybox Generate(Skybox skybox, SkyboxGeneratorContext context, Texture skyboxTexture) Parameters skybox Skybox The skybox instance to apply the generated parameters to. context SkyboxGeneratorContext The context required for rendering, which includes services and draw context. skyboxTexture Texture The texture used to generate the skybox cubemap. Returns Skybox The modified Skybox with diffuse and specular lighting applied. Remarks The method performs the following: Converts the provided texture into a cubemap with a computed resolution based on the texture width. Applies Lambertian spherical harmonics filtering for diffuse lighting. Performs GGX prefiltering for specular lighting and generates a cubemap for reflection purposes."
  },
  "api/Stride.CommunityToolkit.Skyboxes.SkyboxGeneratorContext.html": {
    "href": "api/Stride.CommunityToolkit.Skyboxes.SkyboxGeneratorContext.html",
    "title": "Class SkyboxGeneratorContext | Stride Community Toolkit",
    "summary": "Class SkyboxGeneratorContext Namespace Stride.CommunityToolkit.Skyboxes Assembly Stride.CommunityToolkit.Skyboxes.dll Provides context for generating a skybox by encapsulating relevant services and rendering contexts. public class SkyboxGeneratorContext : ShaderGeneratorContext, IDisposable, IComponent, IReferencable, ICollectorHolder Inheritance object DisposeBase ComponentBase ShaderGeneratorContext SkyboxGeneratorContext Implements IDisposable IComponent IReferencable ICollectorHolder Inherited Members ShaderGeneratorContext.GetParameterKey(ParameterKey) ShaderGeneratorContext.GenerateTextureFromColor(Color) ShaderGeneratorContext.GetTextureKey(Texture, ObjectParameterKey<Texture>, Color?) ShaderGeneratorContext.GetSamplerKey(SamplerStateDescription, GraphicsDevice) ShaderGeneratorContext.GetTextureKey(ComputeTextureBase, MaterialComputeColorKeys) ShaderGeneratorContext.GetSamplerKey(ComputeColorParameterSampler) ShaderGeneratorContext.ResetParameterKeys() ShaderGeneratorContext.PushOverrides(MaterialOverrides) ShaderGeneratorContext.PopOverrides() ShaderGeneratorContext.FindAsset ShaderGeneratorContext.GetAssetFriendlyName ShaderGeneratorContext.Log ShaderGeneratorContext.Content ShaderGeneratorContext.Parameters ShaderGeneratorContext.CurrentOverrides ShaderGeneratorContext.ColorSpace ShaderGeneratorContext.IsNotPixelStage ShaderGeneratorContext.OptimizeMaterials ComponentBase.Tags ComponentBase.Destroy() ComponentBase.OnNameChanged() ComponentBase.ToString() ComponentBase.Name DisposeBase.Dispose() DisposeBase.OnAddReference() DisposeBase.OnReleaseReference() DisposeBase.IsDisposed Remarks This class is a simplified version tailored for code-only usage, inspired by the more complex SkyboxGeneratorContext class in the Stride.Assets.Skyboxes namespace. Constructors SkyboxGeneratorContext(Game) Initializes a new instance of the SkyboxGeneratorContext class using the provided game instance. public SkyboxGeneratorContext(Game game) Parameters game Game The game instance used to access necessary services and contexts. Properties GraphicsDevice Gets the graphics device. public GraphicsDevice GraphicsDevice { get; } Property Value GraphicsDevice RenderContext Gets the render context. public RenderContext RenderContext { get; } Property Value RenderContext RenderDrawContext Gets the render draw context. public RenderDrawContext RenderDrawContext { get; } Property Value RenderDrawContext Services Gets the service registry. public IServiceRegistry Services { get; } Property Value IServiceRegistry"
  },
  "api/Stride.CommunityToolkit.Skyboxes.html": {
    "href": "api/Stride.CommunityToolkit.Skyboxes.html",
    "title": "Namespace Stride.CommunityToolkit.Skyboxes | Stride Community Toolkit",
    "summary": "Namespace Stride.CommunityToolkit.Skyboxes Classes GameExtensions Provides extension methods for the Game class to enhance functionality such as adding skyboxes and other game elements. SkyboxGenerator Provides functionality to generate a skybox with diffuse and specular lighting parameters from a given texture. SkyboxGeneratorContext Provides context for generating a skybox by encapsulating relevant services and rendering contexts."
  },
  "api/Stride.DebugRendering.LinePrimitiveShaderKeys.html": {
    "href": "api/Stride.DebugRendering.LinePrimitiveShaderKeys.html",
    "title": "Class LinePrimitiveShaderKeys | Stride Community Toolkit",
    "summary": "Class LinePrimitiveShaderKeys Namespace Stride.DebugRendering Assembly Stride.CommunityToolkit.DebugShapes.dll public static class LinePrimitiveShaderKeys Inheritance object LinePrimitiveShaderKeys Fields ViewProjection public static readonly ValueParameterKey<Matrix> ViewProjection Field Value ValueParameterKey<Matrix>"
  },
  "api/Stride.DebugRendering.PrimitiveShaderKeys.html": {
    "href": "api/Stride.DebugRendering.PrimitiveShaderKeys.html",
    "title": "Class PrimitiveShaderKeys | Stride Community Toolkit",
    "summary": "Class PrimitiveShaderKeys Namespace Stride.DebugRendering Assembly Stride.CommunityToolkit.DebugShapes.dll public static class PrimitiveShaderKeys Inheritance object PrimitiveShaderKeys Fields Colors public static readonly ObjectParameterKey<Buffer> Colors Field Value ObjectParameterKey<Buffer> InstanceOffset public static readonly ValueParameterKey<int> InstanceOffset Field Value ValueParameterKey<int> LineWidthMultiplier public static readonly ValueParameterKey<float> LineWidthMultiplier Field Value ValueParameterKey<float> Transforms public static readonly ObjectParameterKey<Buffer> Transforms Field Value ObjectParameterKey<Buffer> ViewProjection public static readonly ValueParameterKey<Matrix> ViewProjection Field Value ValueParameterKey<Matrix>"
  },
  "api/Stride.DebugRendering.html": {
    "href": "api/Stride.DebugRendering.html",
    "title": "Namespace Stride.DebugRendering | Stride Community Toolkit",
    "summary": "Namespace Stride.DebugRendering Classes LinePrimitiveShaderKeys PrimitiveShaderKeys"
  },
  "api/Stride.Rendering.ImGuiShaderKeys.html": {
    "href": "api/Stride.Rendering.ImGuiShaderKeys.html",
    "title": "Class ImGuiShaderKeys | Stride Community Toolkit",
    "summary": "Class ImGuiShaderKeys Namespace Stride.Rendering Assembly Stride.CommunityToolkit.ImGui.dll public static class ImGuiShaderKeys Inheritance object ImGuiShaderKeys Fields TexSampler public static readonly ObjectParameterKey<SamplerState> TexSampler Field Value ObjectParameterKey<SamplerState> proj public static readonly ValueParameterKey<Matrix> proj Field Value ValueParameterKey<Matrix> tex public static readonly ObjectParameterKey<Texture> tex Field Value ObjectParameterKey<Texture>"
  },
  "api/Stride.Rendering.html": {
    "href": "api/Stride.Rendering.html",
    "title": "Namespace Stride.Rendering | Stride Community Toolkit",
    "summary": "Namespace Stride.Rendering Classes ImGuiShaderKeys"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "Stride Community Toolkit API | Stride Community Toolkit API",
    "summary": "Stride Community Toolkit API Warning The toolkit is currently in development. Documentation is incomplete and may contain errors. We published it early for your convenience, ahead of the toolkit's completion. Welcome to the Stride Community Toolkit API documentation. These pages contain detailed information about the Stride scripting API, grouped by namespace. The API documentation covers methods, properties, and other relevant information to help you effectively use the Stride engine in your projects."
  },
  "contributing/documentation/index.html": {
    "href": "contributing/documentation/index.html",
    "title": "Documentation | Stride Community Toolkit Contributing",
    "summary": "Documentation We use DocFX to generate our documentation. Contributing to the documentation is straightforward: explore the existing docs, duplicate relevant pages, and update the content as needed. For more information on DocFX and Markdown syntax, refer to the official guide. If you're new to the process, we're happy to assist you in getting started. Installing DocFX To install the latest version of DocFX, use the following command: dotnet tool install -g docfx Building the Documentation Navigate to the docs folder in the project directory: stride-community-toolkit\\docs\\ Run the `run.bat`` file to build the documentation: run.bat Once the process completes, you can access the documentation in your browser at: http://localhost:8080/ Editing the Documentation All documentation files are located in the docs folder. You can edit these Markdown files to update or add content. After making changes, re-run the run.bat command to rebuild the documentation and preview your updates in your browser. Submitting Changes Ensure you’re satisfied with the results. Submit a pull request to the main branch for review."
  },
  "contributing/examples/index.html": {
    "href": "contributing/examples/index.html",
    "title": "Contribute Examples | Stride Community Toolkit Contributing",
    "summary": "Contribute Examples You can see all examples in the examples folder. If you would like your example be launchable from the console application, you can add it to the Stride.CommunityToolkit.Examples project which you can find here: Stride.CommunityToolkit.Examples. Make sure you create an anchor class named NamespaceAnchor.cs if your example contains only Programs.cs, so the namespace can be accessible from Stride.CommunityToolkit.Examples. namespace ExampleXY_YourExampleNamespace; /// <summary> /// This empty class is here to make the namespace available in the nameof() operator in the main examples project. /// </summary> internal static class NamespaceAnchor; Add your example project to Stride.CommunityToolkit.Examples project. Update Providers/ExampleProvider.cs Run Stride.CommunityToolkit.Examples You should see your example listed in the console application. Stride Community Toolkit Examples [1] Basic Example - Capsule with rigid body [2] Basic Example - Capsule with rigid body in F# [3] Basic Example - Capsule with rigid body in Visual Basic [4] Basic Example - Give me a cube [5] Basic Example - Stride UI - Canvas - Capsule with rigid body and Window [6] Basic Example - Stride UI - Grid - Save and load game state [7] Basic Example - Procedural Geometry [8] Basic Example - Particles [9] Advance Example - Myra UI - Draggable Window, GetService() [10] Advance Example - Image Processing [11] Advance Example - Root Renderer Shader [12] Other - CubeClicker [13] Other - Debug Shapes [14] Other - Renderer [Q] Quit Enter choice and press ENTER to continue Update the Stride.CommunityToolkit.Docs/includes/manual/examples/basic-examples-outro.md file with the new example. Update the Stride.CommunityToolkit.Docs/includes/manual/basic-examples.md or advance-examples.md or other-examples.md file with the new example."
  },
  "contributing/index.html": {
    "href": "contributing/index.html",
    "title": "Contributing | Stride Community Toolkit Contributing",
    "summary": "Contributing Welcome Contributors Thank you for your interest in contributing to the Stride Community Toolkit. This guide will help you get started by providing guidelines, best practices, and resources for making meaningful contributions to the project. Whether you're fixing bugs, adding new features, or enhancing the documentation, your efforts are greatly appreciated and help make this toolkit better for everyone. Tip Interested in contributing to the Stride Engine itself? Check out the official Stride Engine Contribution Guide. Ways to Contribute Since the toolkit is currently in preview, we don't have extensive contribution instructions. However, you can follow these general guidelines to get started: Submit Pull Requests (PRs): You're welcome to make PRs directly to the GitHub repository. This is the quickest way to contribute. Report or Solve Issues: Create a new issue on our GitHub Issues page or work on an existing one. Start a Discussion: Use the GitHub Discussions page to share ideas, ask questions, or collaborate on future toolkit features. Join the Community on Discord: For real-time discussions, join our Discord server and participate in the #toolkit channel here. Additional Resources Here are some helpful links to get you started: Stride Community Toolkit GitHub Repository: Explore the code, issues, and pull requests. Stride Game Engine GitHub Repository: Learn more about the main Stride Engine project. Stride Documentation: Find official guides, APIs, and tutorials. We appreciate your time and effort in helping improve the Stride Community Toolkit. Your contributions make a difference, whether you're fixing a small bug, suggesting a new feature, or enhancing the documentation \uD83D\uDE42."
  },
  "contributing/major-release-workflow.html": {
    "href": "contributing/major-release-workflow.html",
    "title": "Major Release Workflow | Stride Community Toolkit Contributing",
    "summary": "Major Release Workflow Preparing for a major release, such as upgrading from .NET 8 to .NET 9, involves updating several key areas to ensure a seamless transition. This guide outlines the necessary steps to update the toolkit and associated documentation. Steps for Major Release: Update Documentation References: Update .NET references on the Home page (index.md). Update .NET references in manual\\gettings-started.md. Update .NET references in manual\\code-only\\create-project.md. Update Project Files: Update the TargetFramework in all .csproj files. Update the TargetFramework in docs\\docfx.json. Update the version in docs\\docfx.json, under build:globalMetadata:_appFooter. Update CI/CD Workflows: Update the dotnet-version in: .github\\workflows\\dotnet.yml. .github\\workflows\\dotnet-nuget.yml. Test Examples: Test all examples to ensure they function as expected with the new framework version. By following these steps, you ensure the toolkit is fully updated, well-documented, and thoroughly tested for each major release, providing users with a reliable and smooth experience."
  },
  "contributing/toolkit/index.html": {
    "href": "contributing/toolkit/index.html",
    "title": "Contribute Code | Stride Community Toolkit Contributing",
    "summary": "Contribute Code If you are a developer and you want to help building Stride Community Toolkit, than you can do so in various ways. Check Our Issue Tracker If you are just getting started with toolkit, issues marked with 'good first issue' can be a good entry point. Please take a look at our issue tracker for other issues. Notify Users Once you start working on an issue, leave a message on the appropriate issue or create one if none exists to: You can always check on Github or Discord if you need to get started somewhere or if you need a general sense of approaching an issue. Make sure that no one else is working on that same issue Lay out your plans and discuss it with collaborators and users to make sure it is properly architectured and would fit well in the project Coding Style Please use and follow Stride's .editorconfig when making changes to files. Submitting Changes Push your changes to a specific branch in your fork. Use that branch to create and fill out a pull request to the official repository. Contributing to Stride Engine If you are interested in contributing to the Stride Engine, please visit the Stride Engine Contribution page."
  },
  "contributing/toolkit/library-project.html": {
    "href": "contributing/toolkit/library-project.html",
    "title": "Creating a New Library Project | Stride Community Toolkit Contributing",
    "summary": "Creating a New Library Project Steps to Create a New NuGet Library Create the Project: Add a new project in the src folder, following the naming convention: Stride.CommunityToolkit.<LibraryName>. Refer to the existing libraries to ensure consistency with the folder/subfolder structure. Configure the Project File: Update the .csproj file with the correct package metadata. Review existing library project files to ensure all necessary properties (e.g., Title, Description, Import) are included. Update Documentation: Add the new library's name and description to docs/includes/libraries.md. This will display the library on: The home page. The Getting Started page. Generate API Documentation: Update docs/docfx.json to include the new .csproj location, ensuring that the API documentation is generated for the new library. Update CI/CD Workflows: Add the new project to: .github\\workflows\\dotnet.yml (PROJECTS). .github\\workflows\\dotnet-nuget.yml (env and # Stride.CommunityToolkit.<LibraryName> section). Optional: Add Example Projects: If adding example projects, follow the existing folder structure pattern in the examples directory. Optional: Add Guidance Content: If you plan to include guidance or tutorials for the new library: Add new pages to the docs/manual folder. Update the toc.yml file to include links to the new content. Tip Don't hesitate to reach out to the maintainers for assistance. Whether it's improving the process, code, clarifying steps, or helping with code, we're here to help!"
  },
  "index.html": {
    "href": "index.html",
    "title": "Stride Community Toolkit Documentation | Stride Community Toolkit",
    "summary": "Stride Community Toolkit Documentation Warning The toolkit is currently in development. Documentation is incomplete and may contain errors. We published it early for your convenience, ahead of the toolkit's completion. \uD83D\uDC4B Introduction The Stride Community Toolkit is a set of C# helpers and extensions designed to enhance your experience with the Stride Game Engine. It simplifies and streamlines routine development tasks \uD83D\uDEE0️, making it easier to build applications for Stride using .NET 8 \uD83C\uDF89. Tip Experienced developers might prefer exploring the toolkit's source code directly. These extensions are convenience wrappers, offering a foundation for advanced users to build custom solutions. \uD83D\uDCE6 Libraries The toolkit includes the following libraries, each designed to extend and enhance your Stride development experience: Stride.CommunityToolkit The core library, providing general-purpose extensions for both regular Stride projects and code-only approaches. Stride.CommunityToolkit.Bepu Adds support for BEPU Physics, a pure C# 3D real time physics simulation library. Stride.CommunityToolkit.Bullet Adds support for Bullet Physics. Note that we no longer plan to support or expand its features as our focus shifts to Bepu Physics. Stride.CommunityToolkit.DebugShapes Provides easy-to-use Debug shapes to be able to visualize and debug your Stride scenes Stride.CommunityToolkit.ImGui Includes extensions for Dear ImGui, a fast, simple-to-use graphical user interface (GUI) library, accessed via the C# wrapper Hexa.NET.ImGui. Ideal for creating debugging tools, editor windows, and in-game UI elements. Stride.CommunityToolkit.Skyboxes Enhances code-only projects by adding skybox functionality. Stride.CommunityToolkit.Windows This library contains Windows-specific dependencies required for code-only approach (RuntimeIdentifier and package reference Stride.Core.Assets.CompilerApp). \uD83D\uDD27 Installation The toolkit, available as a \uD83D\uDCE6 NuGet package, can be integrated into new or existing Stride Game C# projects. For more information on how to get started, please refer to the Getting Started page. \uD83D\uDE80 Fast-Paced Development This toolkit serves as our preferred solution for rapid \uD83C\uDFC3 prototyping and accelerated game development. Unlike the more stable Stride Game Engine, the Stride Community Toolkit aims for faster development momentum. As such, you should expect that breaking changes are likely to occur. This approach allows us to quickly iterate and integrate new features and improvements. We believe this pace serves the needs of developers who are looking for cutting-edge tools and are comfortable with a more dynamic environment. \uD83D\uDEE0️ Toolkit Repository The Stride Community Toolkit is an open-source, MIT-licensed project hosted on GitHub and supported by the community. Access the source code or contribute \uD83E\uDD1D to the toolkit on its GitHub Repository. \uD83C\uDFAE Stride Game Engine Repository Access the source code or contribute \uD83E\uDD1D to the Stride Game Engine on its GitHub Repository. Explore a comprehensive guide on the Stride Docs website. \uD83D\uDCC3 Documentation & Resources Explore a range of resources to help you get the most out of the toolkit: Manual: Detailed guidance and best practices for using the toolkit Tutorials: Step-by-step tutorials to help you learn various features of the toolkit Release Notes: Stay updated with the latest changes and improvements API Reference: In-depth API documentation for a deep dive into the toolkit's capabilities These resources provide comprehensive information and support for developers at all levels, from beginners to advanced users. \uD83D\uDC65 Contributors We would like to thank our contributors for expanding the toolkit's capabilities: dfkeenan: Previous toolkit implementation DockFrankenstein: Script System Extensions Doprez: Extensions, docs DotLogix: Utility MeshBuilder, TextureCanvas and docs Idomeneas1970: Heightmap extensions IXLLEGACYIXL: Extensions Johan Gustafsson: Extensions Martin Blackman: Examples Vaclav Elias: Code-only approach implementation, toolkit docs"
  },
  "manual/animation-extensions/index.html": {
    "href": "manual/animation-extensions/index.html",
    "title": "AnimationComponentExtensions.cs | Stride Community Toolkit Manual",
    "summary": "AnimationComponentExtensions.cs PlayAnimation() - Plays the specified animation on the animation component if it is not already playing"
  },
  "manual/camera-extensions/index.html": {
    "href": "manual/camera-extensions/index.html",
    "title": "CameraComponentExtensions.cs | Stride Community Toolkit Manual",
    "summary": "CameraComponentExtensions.cs These extensions provide powerful and convenient ways to interact with the camera, transforming coordinates between different spaces, performing raycasting, and handling user inputs for dynamic camera control. Bepu Physics: Raycast() - Performs a raycasting operation from the specified CameraComponent's position through the specified screen position in world coordinates, and returns information about the hit result RaycastMouse() - Performs a raycasting operation from the specified CameraComponent's position through the mouse cursor position in screen coordinates, and returns information about the hit result Bullet Physics: Bullet Physics - Raycast(ScriptComponent component, ..), Raycast(Simulation simulation, ..) - Performs a raycasting operation from the specified CameraComponent's position through the specified screen position in world coordinates, and returns information about the hit result Bullet Physics - RaycastMouse(ScriptComponent component, ..), RaycastMouse(Simulation simulation, ..) - Performs a raycasting operation from the specified CameraComponent's position through the mouse cursor position in screen coordinates, and returns information about the hit result Physics independent extension methods: GetPickRay() - Calculates a ray from the camera through a point on the screen in world space LogicDirectionToWorldDirection() - Converts a 2D logical direction into a 3D world direction relative to the camera's orientation LogicDirectionToWorldDirection() - Converts a 2D logical direction into a 3D world direction relative to the camera's orientation, using a specified up vector ScreenPointToRay() - Calculates the near and far vectors for a ray that starts at the camera and passes through a given screen point ScreenToWorldPoint() - Converts the screen position to a point in world coordinates ScreenToWorldRaySegment() - Converts the screen position to a RaySegment in world coordinates ScreenToWorldRaySegment() - Converts the screen position to a RaySegment in world coordinates WorldToClip() - Converts the world position to clip space coordinates relative to camera WorldToScreenPoint() - Converts the world position to screen space coordinates relative to camera Each of these methods is designed to offer streamlined, high-level operations that simplify camera manipulation tasks, allowing you to focus on creating immersive and dynamic 3D environments."
  },
  "manual/code-only/create-project.html": {
    "href": "manual/code-only/create-project.html",
    "title": "Create Project | Stride Community Toolkit Manual",
    "summary": "Create Project Command Line and Visual Studio Code Instructions The following instructions will guide you through creating a new Stride project using the command line. If you prefer to use Visual Studio Code, you can follow the same steps in the Visual Studio Code Terminal. Note These instructions are intended for Windows users. While we have successfully build and run code-only projects on Linux, the setup process is currently more complex. We are working on simplifying the process and will provide instructions in the future. Prerequisites: Ensure you have all the prerequisites installed. Refer to the Prerequisites section for more information. Create a Console App: Follow the Microsoft tutorial to learn more about creating a new console application. Use the following command: dotnet new console --framework net8.0 --name YourProjectName Add NuGet Package: Execute the following command to add the necessary NuGet package. dotnet add package Stride.CommunityToolkit.Windows --prerelease Add NuGet Package: Execute the following command to add the Physics package. dotnet add package Stride.CommunityToolkit.Bepu --prerelease Update Program.cs: Paste the example code provided below into your Program.cs file. Build the Project (Optional): The dotnet build command is used to compile your Stride project, generating executable files and checking for any errors in your code. This step is optional as the subsequent dotnet run command will automatically build the project if it hasn't been built already. To manually build the project, execute the following command: dotnet build Run the Project: The dotnet run command will build (if necessary) and execute your project. Run the following command to start your Stride project: dotnet run Enjoy Stride: If everything is set up correctly, you should now be able to run and enjoy your Stride project. Visual Studio 2022 and Rider Instructions Create a C# Console Application: Open Visual Studio 2022 or Rider and create a new C# Console Application targeting .NET 8. Add NuGet Package: Search for and add the Stride.CommunityToolkit.Windows NuGet package, ensuring you opt for the pre-release version. This package will add all the necessary Stride NuGet packages. Add NuGet Package: Search for and add the Stride.CommunityToolkit.Bepu NuGet package, ensuring you opt for the pre-release version. This package will add the Bepu Physics library to your project. Update Program.cs: Paste the example code (provided below) into your Program.cs file. Run the Project: Build and run your project using the IDE's run functionality. Enjoy Stride: If everything is set up correctly, you should now be able to run and enjoy your Stride project. Example Code The provided C# code example demonstrates the basic usage of the Stride Game Engine. using Stride.CommunityToolkit.Bepu; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Rendering.ProceduralModels; using Stride.Core.Mathematics; using Stride.Engine; using var game = new Game(); game.Run(start: Start); void Start(Scene rootScene) { game.SetupBase3DScene(); var entity = game.Create3DPrimitive(PrimitiveModelType.Capsule); entity.Transform.Position = new Vector3(0, 8, 0); entity.Scene = rootScene; } using var game = new Game(); creates a new instance of the Game class. The game.Run(start: Start); line starts the game, and it specifies that the Start method should be called when the game begins. void Start(Scene rootScene) is the method that is called when the game starts. It takes in a Scene object, which represents the game scene that is currently being played. Inside the Start method, game.SetupBase3DScene(); sets up a basic 3D scene. var entity = game.Create3DPrimitive(PrimitiveModelType.Capsule); creates a new primitive entity of type Capsule, and assigns it to the entity variable. entity.Transform.Position = new Vector3(0, 8, 0); sets the position of the entity in the 3D space. The position is set to (0, 8, 0), which means the capsule is placed 8 units above the ground. entity.Scene = rootScene; adds the entity to the root scene of the game. This step is crucial because assigning the entity to the scene ensures it is rendered and visible in the game. Without this assignment, the entity would not be part of the scene graph, and therefore, it would not appear in the game. The Create3DPrimitive() method creates a Capsule with rigid body physics. Since the capsule is placed 8 units above the ground, it will fall due to gravity. Tip It's important to remove the capsule from memory once it's no longer visible in the scene to free up resources and ensure the CPU isn't unnecessarily calculating physics for it. Additional Examples Explore more examples listed in the menu on the left, categorized by programming language and level of complexity. These examples provide a deeper understanding of how to work with a code-only project in Stride, showcasing various functionalities and implementations. The examples are organized under the following sections: C# Basic Examples: Basic examples demonstrating fundamental concepts using C#. C# Advanced Examples: Advanced scenarios and implementations using C#. F# Basic Examples: Fundamental concepts demonstrated using F#. VB Basic Examples: Fundamental concepts demonstrated using Visual Basic. To view an example, click on its name in the menu, and you will be navigated to a page with a detailed explanation and code snippets."
  },
  "manual/code-only/examples/advance-examples.html": {
    "href": "manual/code-only/examples/advance-examples.html",
    "title": "Code Only Advance Examples | Stride Community Toolkit Manual",
    "summary": "Code Only Advance Examples This page provides a brief overview of the advance examples available for code-only projects in Stride. You can explore each example in detail. Each linked example page contains detailed code snippets and explanations. Examples Overview Simple Constraint: Shows how to create a simple constraint between two entities. Various Constraints: Shows how to create various constraints between entities, including distance limit, distance servo, ball socket, and point-on-line servo. Myra UI - Draggable Window, GetService(): Illustrates using Myra UI to create a draggable window, display a health bar, and access registered services. Stride UI - Draggable Window: Illustrates using Stride UI to create a draggable window. Image Processing: Shows how to apply image processing effects to a texture. Root Renderer Shader: Shows how to create a custom shader for the root renderer. Interactive Console Application For those who prefer a more interactive approach, we provide a console application that allows you to run these examples directly. This console app, available in the Stride.CommunityToolkit.Examples project, offers an interactive menu for selecting and running the examples. Here's a glimpse of the interactive menu provided by the console application: Stride Community Toolkit Examples [1] Basic Example - Capsule with rigid body [2] Basic Example - Capsule with rigid body in F# [3] Basic Example - Capsule with rigid body in Visual Basic [4] Basic Example - Mesh Line [5] Basic Example - Material [6] Basic Example - Give me a cube [7] Basic Example - Stride UI - Canvas - Capsule with rigid body and Window [8] Basic Example - Stride UI - Grid - Save and load game state [9] Basic Example - Procedural Geometry [10] Basic Example - Cylinder Mesh [11] Basic Example - Partial Torus [12] Basic Example - Partial Torus in F# [13] Basic Example - Particles [14] Basic Example - Raycast [15] Basic Example - CollisionGroup [16] Basic Example - CollisionLayer [17] Advance Example - Simple Constraint [18] Advance Example - Various Constraints [19] Advance Example - Myra UI - Draggable Window, GetService() [20] Advance Example - Stride UI - Draggable Window [21] Advance Example - Image Processing [22] Advance Example - Root Renderer Shader [23] Other - Debug Shapes [24] Other - Renderer [Q] Quit Enter choice and press ENTER to continue"
  },
  "manual/code-only/examples/basic-examples-fs.html": {
    "href": "manual/code-only/examples/basic-examples-fs.html",
    "title": "F# Code Only Basic Examples | Stride Community Toolkit Manual",
    "summary": "F# Code Only Basic Examples This page provides a brief overview of the basic examples available for code-only projects in Stride. You can explore each example in detail. Each linked example page contains detailed code snippets and explanations. Examples Overview Capsule with rigid body: Demonstrates how to create a 3D capsule entity and position it in a scene. Partial torus mesh: Shows how to create a partial torus mesh. Interactive Console Application For those who prefer a more interactive approach, we provide a console application that allows you to run these examples directly. This console app, available in the Stride.CommunityToolkit.Examples project, offers an interactive menu for selecting and running the examples. Here's a glimpse of the interactive menu provided by the console application: Stride Community Toolkit Examples [1] Basic Example - Capsule with rigid body [2] Basic Example - Capsule with rigid body in F# [3] Basic Example - Capsule with rigid body in Visual Basic [4] Basic Example - Mesh Line [5] Basic Example - Material [6] Basic Example - Give me a cube [7] Basic Example - Stride UI - Canvas - Capsule with rigid body and Window [8] Basic Example - Stride UI - Grid - Save and load game state [9] Basic Example - Procedural Geometry [10] Basic Example - Cylinder Mesh [11] Basic Example - Partial Torus [12] Basic Example - Partial Torus in F# [13] Basic Example - Particles [14] Basic Example - Raycast [15] Basic Example - CollisionGroup [16] Basic Example - CollisionLayer [17] Advance Example - Simple Constraint [18] Advance Example - Various Constraints [19] Advance Example - Myra UI - Draggable Window, GetService() [20] Advance Example - Stride UI - Draggable Window [21] Advance Example - Image Processing [22] Advance Example - Root Renderer Shader [23] Other - Debug Shapes [24] Other - Renderer [Q] Quit Enter choice and press ENTER to continue"
  },
  "manual/code-only/examples/basic-examples-vb.html": {
    "href": "manual/code-only/examples/basic-examples-vb.html",
    "title": "Visual Basic Code Only Basic Examples | Stride Community Toolkit Manual",
    "summary": "Visual Basic Code Only Basic Examples This page provides a brief overview of the basic examples available for code-only projects in Stride. You can explore each example in detail. Each linked example page contains detailed code snippets and explanations. Examples Overview Capsule with rigid body: Demonstrates how to create a 3D capsule entity and position it in a scene. Interactive Console Application For those who prefer a more interactive approach, we provide a console application that allows you to run these examples directly. This console app, available in the Stride.CommunityToolkit.Examples project, offers an interactive menu for selecting and running the examples. Here's a glimpse of the interactive menu provided by the console application: Stride Community Toolkit Examples [1] Basic Example - Capsule with rigid body [2] Basic Example - Capsule with rigid body in F# [3] Basic Example - Capsule with rigid body in Visual Basic [4] Basic Example - Mesh Line [5] Basic Example - Material [6] Basic Example - Give me a cube [7] Basic Example - Stride UI - Canvas - Capsule with rigid body and Window [8] Basic Example - Stride UI - Grid - Save and load game state [9] Basic Example - Procedural Geometry [10] Basic Example - Cylinder Mesh [11] Basic Example - Partial Torus [12] Basic Example - Partial Torus in F# [13] Basic Example - Particles [14] Basic Example - Raycast [15] Basic Example - CollisionGroup [16] Basic Example - CollisionLayer [17] Advance Example - Simple Constraint [18] Advance Example - Various Constraints [19] Advance Example - Myra UI - Draggable Window, GetService() [20] Advance Example - Stride UI - Draggable Window [21] Advance Example - Image Processing [22] Advance Example - Root Renderer Shader [23] Other - Debug Shapes [24] Other - Renderer [Q] Quit Enter choice and press ENTER to continue"
  },
  "manual/code-only/examples/basic-examples.html": {
    "href": "manual/code-only/examples/basic-examples.html",
    "title": "C# Code Only Basic Examples | Stride Community Toolkit Manual",
    "summary": "C# Code Only Basic Examples This page provides a brief overview of the basic examples available for code-only projects in Stride. You can explore each example in detail. Each linked example page contains detailed code snippets and explanations. Examples Overview Capsule with rigid body: Shows how to create a 3D capsule entity and position it in a scene. Give me a cube: Presents a variation of the above example by positioning a 3D cube in a scene. Mesh line: Shows how to create a mesh line. Stride UI - Capsule with rigid body and Window: Shows how to create a 3D capsule entity, position it in a scene, and create a simple window displaying a text message. Stride UI - Grid - Save and load game state: Shows how to create a simple game where clicking a cube increases the score and manages game state. Material: Shows how to create a material and apply it to a 3D entity. Procedural geometry: Shows how to create procedural geometry meshes—such as a triangle, plane, and circle—and add them to a scene. Cylinder mesh: Shows how to create a cylinder mesh. Partial torus mesh: Shows how to create a partial torus mesh. Particles: Shows how to create a particle system. Raycast: Shows how to implement raycasting and physics interactions. Collision Group: Shows how to create a scene with two players and an enemy entity and set up collision groups. Collision Layer: Shows how to create a scene with two players and an enemy entity and set up collision layers. Interactive Console Application For those who prefer a more interactive approach, we provide a console application that allows you to run these examples directly. This console app, available in the Stride.CommunityToolkit.Examples project, offers an interactive menu for selecting and running the examples. Here's a glimpse of the interactive menu provided by the console application: Stride Community Toolkit Examples [1] Basic Example - Capsule with rigid body [2] Basic Example - Capsule with rigid body in F# [3] Basic Example - Capsule with rigid body in Visual Basic [4] Basic Example - Mesh Line [5] Basic Example - Material [6] Basic Example - Give me a cube [7] Basic Example - Stride UI - Canvas - Capsule with rigid body and Window [8] Basic Example - Stride UI - Grid - Save and load game state [9] Basic Example - Procedural Geometry [10] Basic Example - Cylinder Mesh [11] Basic Example - Partial Torus [12] Basic Example - Partial Torus in F# [13] Basic Example - Particles [14] Basic Example - Raycast [15] Basic Example - CollisionGroup [16] Basic Example - CollisionLayer [17] Advance Example - Simple Constraint [18] Advance Example - Various Constraints [19] Advance Example - Myra UI - Draggable Window, GetService() [20] Advance Example - Stride UI - Draggable Window [21] Advance Example - Image Processing [22] Advance Example - Root Renderer Shader [23] Other - Debug Shapes [24] Other - Renderer [Q] Quit Enter choice and press ENTER to continue"
  },
  "manual/code-only/examples/capsule-with-rigid-body-fs.html": {
    "href": "manual/code-only/examples/capsule-with-rigid-body-fs.html",
    "title": "Capsule with rigid body in F# | Stride Community Toolkit Manual",
    "summary": "Capsule with rigid body in F# This code example demonstrates how to initialize a game, set up a basic 3D scene, add a skybox, create a 3D capsule entity, set its position, and add it to the scene using the extensions provided by the toolkit. The Create3DPrimitive() method, a part of the toolkit, automatically equips the capsule entity with a rigid body and a collider. This example serves as a simple starting point for building a game with Stride, leveraging the utilities provided by the toolkit to simplify common game development tasks. Note This example requires the additional NuGet packages Stride.CommunityToolkit.Skyboxes and Stride.CommunityToolkit.Bepu. Make sure to install both before running the code. View on GitHub. open Stride.CommunityToolkit.Bepu; open Stride.CommunityToolkit.Engine; open Stride.CommunityToolkit.Skyboxes; open Stride.CommunityToolkit.Rendering.ProceduralModels; open Stride.Core.Mathematics; open Stride.Engine; let game = new Game() let Start rootScene = game.SetupBase3DScene() game.AddSkybox() |> ignore game.AddProfiler() |> ignore let firstBox = game.Create3DPrimitive(PrimitiveModelType.Capsule); firstBox.Transform.Position <- new Vector3(0f, 2.5f, 0f) firstBox.Scene <- rootScene [<EntryPoint>] let main argv = game.Run(start = Start) 0 let game = new Game() Creates a new instance of the Game class, serving as the central part of the Stride engine for managing game loop, scenes, and entities. let Start rootScene = Defines a function named Start that takes a Scene object named rootScene as an argument. game.SetupBase3DScene() Sets up a basic 3D scene with a default camera, lighting. game.AddSkybox() Adds a skybox to the scene, providing a background image for the 3D environment. game.AddProfiler() |> ignore Adds a profiler to the game and discards the unneeded return value. let firstBox = game.Create3DPrimitive(PrimitiveModelType.Capsule); Creates a new 3D capsule primitive entity. firstBox.Transform.Position <- new Vector3(0f, 2.5f, 0f) Sets the 3D position of the created entity. firstBox.Scene <- rootScene Adds the entity to the rootScene. [<EntryPoint>] Specifies that the following main function is the entry point of the application. let main argv = Defines the main function, which will be the entry point for the application. game.Run(start = Start) Initiates the game loop by passing the Start function as the start delegate. 0 Indicates a successful program execution."
  },
  "manual/code-only/examples/capsule-with-rigid-body-vb.html": {
    "href": "manual/code-only/examples/capsule-with-rigid-body-vb.html",
    "title": "Capsule with rigid body in Visual Basic | Stride Community Toolkit Manual",
    "summary": "Capsule with rigid body in Visual Basic This code example demonstrates how to initialize a game, set up a basic 3D scene, add a skybox, create a 3D capsule entity, set its position, and add it to the scene using the extensions provided by the toolkit. The Create3DPrimitive() method, a part of the toolkit, automatically equips the capsule entity with a rigid body and a collider. This example serves as a simple starting point for building a game with Stride, leveraging the utilities provided by the toolkit to simplify common game development tasks. Note This example requires the additional NuGet packages Stride.CommunityToolkit.Skyboxes and Stride.CommunityToolkit.Bepu. Make sure to install both before running the code. View on GitHub. Imports Stride.CommunityToolkit.Bepu Imports Stride.CommunityToolkit.Engine Imports Stride.CommunityToolkit.Rendering.ProceduralModels Imports Stride.CommunityToolkit.Skyboxes Imports Stride.Core.Mathematics Imports Stride.Engine Imports GameExtensions = Stride.CommunityToolkit.Engine.GameExtensions Module Program Private ReadOnly game As New Game() Sub Main() GameExtensions.Run(game, Nothing, AddressOf StartGame) End Sub Private Sub StartGame(rootScene As Scene) game.SetupBase3DScene() game.AddSkybox() game.AddProfiler() Dim entity = game.Create3DPrimitive(PrimitiveModelType.Capsule) entity.Transform.Position = New Vector3(0, 8, 0) entity.Scene = rootScene End Sub End Module Private game As New Game() This line of code creates a new instance of the Game class. The Game class is central to the Stride engine, managing the overall game loop, scenes, and updates to the entities. GameExtensions.Run(game, Nothing, AddressOf StartGame) This line initiates the game loop. The Run method, from GameExtensions, is responsible for starting the game and it takes a reference to the StartGame method as a parameter. This method is called once when the game starts. The Nothing argument here is for an optional parameter that is not being used in this case. game.SetupBase3DScene() This line sets up a basic 3D scene. It's a helper method provided to quickly set up a scene with a default camera, lighting. game.AddSkybox() This line adds a skybox to the scene. A skybox is a cube that surrounds the entire scene and is textured with an image to create the illusion of a sky. game.AddProfiler() This line adds a profiler to the game. Dim entity = game.Create3DPrimitive(PrimitiveModelType.Capsule) Here, a new entity is created in the form of a 3D capsule primitive. The Create3DPrimitive method is a helper method provided to create basic 3D shapes. entity.Transform.Position = New Vector3(0, 8, 0) This line sets the position of the created entity in the 3D space. The Position property of the Transform component determines the location of the entity. entity.Scene = rootScene Finally, the entity is added to the rootScene. The Scene property of an entity determines which scene it belongs to."
  },
  "manual/code-only/examples/capsule-with-rigid-body.html": {
    "href": "manual/code-only/examples/capsule-with-rigid-body.html",
    "title": "Capsule with rigid body | Stride Community Toolkit Manual",
    "summary": "Capsule with rigid body This code example demonstrates how to initialize a game, set up a basic 3D scene, add a skybox, create a 3D capsule entity, set its position, and add it to the scene using the extensions provided by the toolkit. The Create3DPrimitive() method, a part of the toolkit, automatically equips the capsule entity with a rigid body and a collider. This example serves as a simple starting point for building a game with Stride, leveraging the utilities provided by the toolkit to simplify common game development tasks. Note This example requires the additional NuGet packages Stride.CommunityToolkit.Skyboxes and Stride.CommunityToolkit.Bepu. Make sure to install both before running the code. View on GitHub. using Stride.CommunityToolkit.Bepu; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Rendering.ProceduralModels; using Stride.CommunityToolkit.Skyboxes; using Stride.Core.Mathematics; using Stride.Engine; using var game = new Game(); game.Run(start: (Scene rootScene) => { game.SetupBase3DScene(); game.AddSkybox(); var entity = game.Create3DPrimitive(PrimitiveModelType.Capsule); entity.Transform.Position = new Vector3(0, 8, 0); entity.Scene = rootScene; }); using var game = new Game(); This line of code creates a new instance of the Game class. The Game class is the central part of the Stride engine, managing the overall game loop, the scenes, and the updates to the entities. The using keyword ensures that the Dispose() method is called on the game object when it goes out of scope, ensuring that any resources it uses are properly cleaned up game.Run(start: (Scene rootScene) => This line initiates the game loop. The Run method is responsible for starting the game, and it takes a delegate as a parameter. This delegate is a function that is called once when the game starts. The rootScene parameter represents the main scene of your game. game.SetupBase3DScene(); This line sets up a basic 3D scene. It's a helper method provided to quickly set up a scene with a default camera, lighting. game.AddSkybox(); This line adds a skybox to the scene. A skybox is a cube that surrounds the entire scene and is textured with an image to create the illusion of a sky. var entity = game.Create3DPrimitive(PrimitiveModelType.Capsule); Here, a new entity is created in the form of a 3D capsule primitive. The Create3DPrimitive method is another helper method provided to create basic 3D shapes. entity.Transform.Position = new Vector3(0, 8, 0); This line sets the position of the created entity in the 3D space. The Position property of the Transform component determines the location of the entity. entity.Scene = rootScene; Finally, the entity is added to the rootScene. The Scene property of an entity determines which scene it belongs to."
  },
  "manual/code-only/examples/collision-group.html": {
    "href": "manual/code-only/examples/collision-group.html",
    "title": "Collision Group | Stride Community Toolkit Manual",
    "summary": "Collision Group This example demonstrates how to create a simple scene with two players and an enemy entity and set up collision groups to control which objects can collide with each other. The Program.cs file shows how to: Define collision groups with specific IndexA values to control collision behaviors Create a 3D scene with colored cube entities representing players and an enemy Apply different collision group settings to each entity Demonstrate the rule where objects with IndexA value differences greater than 2 will collide In this example, three collision groups are created: Two player collision groups (green and purple cubes) with IndexA values of 0 and 2 One enemy collision group (red cube) with an IndexA value of 1 This configuration ensures that: The players will collide with each other because the difference between their IndexA values is 2 The enemy entity won't collide with either player because the difference between their IndexA values is 1 Note This example requires the additional NuGet packages Stride.CommunityToolkit.Skyboxes and Stride.CommunityToolkit.Bepu. Make sure to install both before running the code. View on GitHub. using Stride.BepuPhysics; using Stride.BepuPhysics.Definitions; using Stride.CommunityToolkit.Bepu; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Rendering.ProceduralModels; using Stride.CommunityToolkit.Skyboxes; using Stride.Core.Mathematics; using Stride.Engine; // This example demonstrates how to create a simple scene with two players and an enemy entity // and set up collision groups to control which objects can collide with each other. // Define collision groups to control which objects can collide with each other // Objects within the same group can't collide with each other, however, if IndexA is used, the objects collide with each other if the difference is more than 2 // In this example, the players will collide with each other because the difference between their IndexA values is 2 // The enemy entity (red box) won't collide with the players because the difference between their IndexA values is 1 var playerCollisionGroup1 = new CollisionGroup { Id = 1, IndexA = 0 }; var playerCollisionGroup2 = new CollisionGroup { Id = 1, IndexA = 2 }; var enemyCollisionGroup = new CollisionGroup { Id = 1, IndexA = 1 }; using var game = new Game(); game.Run(start: Start); // Sets up the initial scene with players and enemies void Start(Scene scene) { game.SetupBase3DScene(); game.AddSkybox(); // Create player entities CreateEntityWithGroup(\"Player1\", Color.MediumSeaGreen, new Vector3(0, 0.5f, 0), scene, playerCollisionGroup1); CreateEntityWithGroup(\"Player2\", Color.MediumPurple, new Vector3(0.5f, 4, 0.7f), scene, playerCollisionGroup2); // Create enemy entity CreateEntityWithGroup(\"Enemy\", Color.Red, new Vector3(-0.1f, 12, 0.5f), scene, enemyCollisionGroup); } void CreateEntityWithGroup(string name, Color color, Vector3 position, Scene scene, CollisionGroup collisionGroup) { var enemy = CreateEntity(name, color, position); var body = enemy.GetComponent<BodyComponent>(); body!.CollisionGroup = collisionGroup; enemy.Scene = scene; } Entity CreateEntity(string name, Color color, Vector3 position) { var entity = game.Create3DPrimitive(PrimitiveModelType.Cube, new() { EntityName = name, Material = game.CreateMaterial(color), }); entity.Transform.Position = position; return entity; }"
  },
  "manual/code-only/examples/collision-layer.html": {
    "href": "manual/code-only/examples/collision-layer.html",
    "title": "Collision Layer | Stride Community Toolkit Manual",
    "summary": "Collision Layer This example demonstrates how to implement and control collision detection between different types of entities using Stride's collision layer system. The code showcases: Creation and configuration of separate collision layers for players, enemies, and the ground Setting up a collision matrix to define interaction rules between different layers Implementation of selective collision detection where players can collide with each other and the ground, but not with enemies The example creates a scene with two player cubes (green and purple) that can interact with each other and the ground, plus a red enemy cube that passes through players while still colliding with the ground. This pattern is useful for implementing gameplay mechanics like ghost modes, team-based collision, or phasing through specific obstacles. Note This example requires the additional NuGet packages Stride.CommunityToolkit.Skyboxes and Stride.CommunityToolkit.Bepu. Make sure to install both before running the code. View on GitHub. using Stride.BepuPhysics; using Stride.BepuPhysics.Definitions; using Stride.CommunityToolkit.Bepu; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Rendering.ProceduralModels; using Stride.CommunityToolkit.Skyboxes; using Stride.Core.Mathematics; using Stride.Engine; // This example demonstrates CollisionLayer feature, two players colliding with each other and not colliding with the enemy entity (red cube) // Define collision layers to control which objects can collide with each other // Objects within the same layer can collide with each other var playerLayer = CollisionLayer.Layer1; var enemyLayer = CollisionLayer.Layer2; var groundLayer = CollisionLayer.Layer3; // CollisionMatrix is used to define which objects can collide with each other var collisionMatrix = new CollisionMatrix(); collisionMatrix.Set(playerLayer, playerLayer, shouldCollide: true); collisionMatrix.Set(playerLayer, enemyLayer, shouldCollide: false); collisionMatrix.Set(playerLayer, groundLayer, shouldCollide: true); collisionMatrix.Set(enemyLayer, groundLayer, shouldCollide: true); using var game = new Game(); game.Run(start: Start); // Sets up the initial scene with players and enemies void Start(Scene scene) { game.SetupBase3DScene(); game.AddSkybox(); SetupCollisionMatrix(scene); SetupGroundCollisionLayer(scene); // Create player entities CreateEntityWithLayer(\"Player1\", Color.MediumSeaGreen, new Vector3(0, 0.5f, 0), scene, playerLayer); CreateEntityWithLayer(\"Player2\", Color.MediumPurple, new Vector3(0.5f, 4, 0.7f), scene, playerLayer); // Create enemy entity CreateEntityWithLayer(\"Enemy\", Color.Red, new Vector3(-0.1f, 12, 0.5f), scene, enemyLayer); } void SetupCollisionMatrix(Scene scene) { var camera = scene.GetCamera(); var simulation = camera?.Entity.GetSimulation(); if (simulation == null) return; simulation.CollisionMatrix = collisionMatrix; } void SetupGroundCollisionLayer(Scene scene) { var groundEntity = scene.Entities.FirstOrDefault(e => e.Name == \"Ground\"); if (groundEntity == null) return; var groundBody = groundEntity.GetComponent<StaticComponent>(); groundBody!.CollisionLayer = groundLayer; } void CreateEntityWithLayer(string name, Color color, Vector3 position, Scene scene, CollisionLayer layer) { var enemy = CreateEntity(name, color, position); var body = enemy.GetComponent<BodyComponent>(); body!.CollisionLayer = layer; enemy.Scene = scene; } Entity CreateEntity(string name, Color color, Vector3 position) { var entity = game.Create3DPrimitive(PrimitiveModelType.Cube, new() { EntityName = name, Material = game.CreateMaterial(color), }); entity.Transform.Position = position; return entity; }"
  },
  "manual/code-only/examples/constraints.html": {
    "href": "manual/code-only/examples/constraints.html",
    "title": "Various constraints | Stride Community Toolkit Manual",
    "summary": "Various constraints This example demonstrates how to implement and use physics constraints in Stride using the BepuPhysics engine. The sample showcases four different constraint types: DistanceLimit: Connects two spheres with minimum and maximum distance limits, allowing them to move freely within that range but preventing them from getting too close or too far from each other DistanceServo: Links two spheres with a target distance and spring settings, actively pulling or pushing to maintain the specified separation BallSocket: Creates a pivoting joint between a static foundation and a platform, allowing rotation around a connection point similar to a ball-and-socket joint PointOnLineServo: Restricts cubes to slide along vertical lines while maintaining their orientation, creating two stacks of cubes that can only move up and down The example features interactive elements where you can: Drag a golden sphere horizontally with the mouse while adjusting its vertical position using the Z and X keys Click on cubes in the vertical stacks to remove them, causing cubes above to fall Reset the entire scene by pressing R This demonstrates how constraints can be used to create complex physical behaviors with controlled degrees of freedom. The example illustrates important physics concepts like servo constraints with spring settings, rigid body connections, and collision filtering between different object types. Note This example requires the additional NuGet packages Stride.CommunityToolkit.Skyboxes and Stride.CommunityToolkit.Bepu. Make sure to install both before running the code. View on GitHub. using Stride.BepuPhysics; using Stride.BepuPhysics.Constraints; using Stride.BepuPhysics.Definitions; using Stride.CommunityToolkit.Bepu; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Rendering.ProceduralModels; using Stride.CommunityToolkit.Scripts.Utilities; using Stride.CommunityToolkit.Skyboxes; using Stride.Core.Mathematics; using Stride.Engine; using Stride.Games; using Stride.Input; // This example demonstrates these constraints: DistanceLimit, DistanceServo, BallSocket, PointOnLineServo // The user can drag a golden sphere horizontally and adjust its vertical position with Z and X keys // The scene can be reset by pressing R // DistanceLimit: Connects two spheres with a minimum and maximum distance // DistanceServo: Connects two spheres with a target distance and spring settings // BallSocket: Connects two entities with a ball-and-socket joint // PointOnLineServo: Connects a cube to a line with a servo constraint // Constant vertical speed (units per second) for smooth vertical adjustments. const float VerticalSpeed = 4.0f; const string DraggableEntityName = \"Draggable Sphere\"; const string ConnectedEntityName = \"Connected Sphere\"; // Enhanced settings for better sliding const float CubeSpringDampingRation = 50; // Reduced from 100 const float SpringFrequency = 20; // Reduced from 40 const float FrictionCoefficient = 0.1f; // Reduced from 0.5f for smoother sliding const float ServoMaxForce = 500; // Reduced from 1000 for softer constraints DebugTextPrinter? instructions = null; // Game entities and components CameraComponent? mainCamera = null; BodyComponent? draggableBody = null; List<Entity?> entities = []; List<BodyComponent?> bodies = []; var lineLayer = CollisionLayer.Layer1; var cubeLayer = CollisionLayer.Layer2; var groundLayer = CollisionLayer.Layer3; var otherLayer = CollisionLayer.Layer5; var collisionMatrix = new CollisionMatrix(); collisionMatrix.Set(lineLayer, cubeLayer, shouldCollide: false); collisionMatrix.Set(lineLayer, groundLayer, shouldCollide: true); collisionMatrix.Set(lineLayer, otherLayer, shouldCollide: true); collisionMatrix.Set(groundLayer, otherLayer, shouldCollide: true); collisionMatrix.Set(otherLayer, otherLayer, shouldCollide: true); collisionMatrix.Set(cubeLayer, groundLayer, shouldCollide: true); collisionMatrix.Set(cubeLayer, otherLayer, shouldCollide: true); collisionMatrix.Set(cubeLayer, cubeLayer, shouldCollide: true); // The fixed Y level for horizontal dragging (captured at drag start) float initialDragY = 0; // The additional vertical offset applied via key presses (starts at 0) float verticalOffset = 0; // The offset between the sphere's center and the initial click point to avoid recentering Vector3 dragOffset = Vector3.Zero; // Last known valid sphere position (used as a fallback) Vector3 lastSpherePosition = Vector3.Zero; // Flag to indicate that the sphere is currently being dragged bool isDraggingSphere = false; // Initialize the game instance using var game = new Game(); // Run the game loop with the Start and Update methods game.Run(start: Start, update: Update); void Start(Scene scene) { // Set up a basic 3D scene with skybox, profiler, and a ground gizmo game.SetupBase3DScene(); game.AddSkybox(); game.AddProfiler(); game.AddGroundGizmo(new(-5, 0, -5), showAxisName: true); SetupCollisionMatrix(scene); SetupGroundCollisionLayer(scene); InitializeDebugTextPrinter(); InitializeEntities(scene); // Retrieve the active camera from the scene mainCamera = scene.GetCamera(); } void Update(Scene scene, GameTime time) { if (mainCamera == null) return; if (game.Input.IsKeyPressed(Keys.R)) { ResetTheScene(scene); } // Display on-screen instructions for the user DisplayInstructions(); // On mouse button press, attempt to select the sphere if (game.Input.IsMouseButtonPressed(MouseButton.Left)) { ProcessMouseClick(); } // While the mouse button is held down, update the sphere's position if (isDraggingSphere && game.Input.IsMouseButtonDown(MouseButton.Left)) { if (draggableBody == null) return; // Get the horizontal (XZ) intersection point using the fixed initialDragY var horizontalPos = GetNewPosition(game.Input.MousePosition); // Add the stored drag offset to maintain the initial click offset. var newPosition = horizontalPos + dragOffset; // Adjust the vertical (Y-axis) position smoothly based on delta time and key presses. if (game.Input.IsKeyDown(Keys.Z)) { verticalOffset += VerticalSpeed * (float)time.Elapsed.TotalSeconds; } if (game.Input.IsKeyDown(Keys.X)) { verticalOffset -= VerticalSpeed * (float)time.Elapsed.TotalSeconds; } // The final Y position is the initial drag level plus the vertical offset. float finalY = initialDragY + verticalOffset; // Update the sphere's position while locking the Y coordinate draggableBody.Position = new Vector3(newPosition.X, finalY, newPosition.Z); lastSpherePosition = draggableBody.Position; } // When the mouse button is released, stop dragging if (isDraggingSphere && game.Input.IsMouseButtonReleased(MouseButton.Left)) { isDraggingSphere = false; if (draggableBody == null) return; // Set the sphere back to non-kinematic so physics can resume draggableBody.Kinematic = false; // Wake the body to ensure physics updates draggableBody.Awake = true; draggableBody = null; } } void SetupCollisionMatrix(Scene scene) { var camera = scene.GetCamera(); var simulation = camera?.Entity.GetSimulation(); if (simulation == null) return; simulation.CollisionMatrix = collisionMatrix; } void SetupGroundCollisionLayer(Scene scene) { var groundEntity = scene.Entities.FirstOrDefault(e => e.Name == \"Ground\"); if (groundEntity == null) return; var groundBody = groundEntity.GetComponent<StaticComponent>(); groundBody!.CollisionLayer = groundLayer; } void InitializeEntities(Scene scene) { // Create reference entities for visual reference CreateReferenceCube(scene); CreateReferenceCapsule(scene); CreateDistanceLimintConstraintExamples(scene); CreateDistanceServoConstraintExamples(scene); CreateBallSocketConstraintExample(scene); CreatePointOnLineServoConstraintExample2(scene); } void CreateReferenceCube(Scene scene) { var referenceCube = CreateCubeEntity(\"Reference Cube\", Color.Purple, new Vector3(3, 3, 3)); var referenceCubeBody = referenceCube.Get<BodyComponent>(); referenceCubeBody.FrictionCoefficient = 0.1f; referenceCubeBody.CollisionLayer = CollisionLayer.Layer5; var angularServoSetB = new OneBodyAngularServoConstraintComponent { TargetOrientation = Quaternion.Identity, A = referenceCubeBody, ServoMaximumForce = 1000, SpringDampingRatio = 10, SpringFrequency = 300, }; referenceCube.Add(angularServoSetB); referenceCube.Scene = scene; } void CreateReferenceCapsule(Scene scene) { var referenceCapsule = CreateEntity(PrimitiveModelType.Capsule, \"Reference Capsule\", Color.Orange, new Vector3(0, 3, 0)); var referenceCapsuleBody = referenceCapsule.Get<BodyComponent>(); referenceCapsuleBody.CollisionLayer = CollisionLayer.Layer5; referenceCapsule.Scene = scene; } void CreateDistanceLimintConstraintExamples(Scene scene) { // Create the draggable sphere with a golden material // Initially, the sphere is not kinematic. It will become kinematic while dragging var draggableSphere = CreateEntity(PrimitiveModelType.Sphere, DraggableEntityName, Color.Gold, new Vector3(-2, 3, -2)); var draggableBody = draggableSphere.Get<BodyComponent>(); draggableBody.CollisionLayer = CollisionLayer.Layer5; // Create a second sphere to demonstrate a connected constraint var connectedSphere = CreateEntity(PrimitiveModelType.Sphere, ConnectedEntityName, Color.Blue, new Vector3(-2.1f, 3, -2.9f)); var connectedBody = connectedSphere.Get<BodyComponent>(); connectedBody.CollisionLayer = CollisionLayer.Layer5; // Set up a distance limit constraint between the draggable and connected spheres var distanceLimit = new DistanceLimitConstraintComponent { A = draggableBody, B = connectedBody, MinimumDistance = 1, MaximumDistance = 3.0f }; draggableSphere.Add(distanceLimit); // Add both entities to the scene draggableSphere.Scene = scene; connectedSphere.Scene = scene; entities.AddRange([draggableSphere, connectedSphere]); bodies.AddRange([draggableBody, connectedBody]); } void CreateDistanceServoConstraintExamples(Scene scene) { // Create the draggable sphere with a golden material // Initially, the sphere is not kinematic. It will become kinematic while dragging var draggableSphere = CreateEntity(PrimitiveModelType.Sphere, DraggableEntityName, Color.Gold, new Vector3(-2, 6, -2)); var draggableBody = draggableSphere.Get<BodyComponent>(); draggableBody.CollisionLayer = CollisionLayer.Layer5; var connectedSphere = CreateEntity(PrimitiveModelType.Sphere, ConnectedEntityName, Color.LightBlue, new Vector3(-2.1f, 6, -2.9f)); var connectedBody = connectedSphere.Get<BodyComponent>(); connectedBody.CollisionLayer = CollisionLayer.Layer5; // Set up a distance servo constraint between the draggable and connected spheres var distanceServo = new DistanceServoConstraintComponent { A = draggableBody, B = connectedBody, TargetDistance = 3.0f, SpringDampingRatio = 2, //SpringFrequency = 1, }; draggableSphere.Add(distanceServo); // Add both entities to the scene draggableSphere.Scene = scene; connectedSphere.Scene = scene; entities.AddRange([draggableSphere, connectedSphere]); bodies.AddRange([draggableBody, connectedBody]); } void CreateBallSocketConstraintExample(Scene scene) { const float FoundationHeight = 3; const float FoundationWidth = 0.2f; const float PlatformHeight = 0.2f; const float PlatformWidth = 3; var exampleOffset = new Vector3(4, 0, -4); var foundationSize = new Vector3(FoundationWidth, FoundationHeight, FoundationWidth); var foundationPosition = new Vector3(0, FoundationHeight / 2, 0) + exampleOffset; var platformSize = new Vector3(PlatformWidth, PlatformHeight, PlatformWidth); var platformPosition = new Vector3(0, FoundationHeight + PlatformHeight / 2, 0) + exampleOffset; var foundationBlock = CreateCubeEntity(\"Foundation Block\", Color.Beige, foundationPosition, foundationSize); var foundationBody = foundationBlock.Get<BodyComponent>(); foundationBody.Kinematic = true; foundationBody.CollisionLayer = CollisionLayer.Layer5; var platform = CreateCubeEntity(\"Platform\", Color.Bisque, platformPosition, platformSize); var platformBody = platform.Get<BodyComponent>(); platformBody.CollisionLayer = CollisionLayer.Layer5; var ballSocket = new BallSocketConstraintComponent { A = foundationBody, B = platformBody, // Adjusting socket to be at the top of the foundation LocalOffsetA = new Vector3(0, 1.5f, 0), // Adjusting socket to be at the bottom of the platform LocalOffsetB = new Vector3(0, -0.1f, 0), }; foundationBlock.Add(ballSocket); //foundationBlock.Add(ballSocket2); foundationBlock.Scene = scene; platform.Scene = scene; entities.AddRange([foundationBlock, platform]); bodies.AddRange([foundationBody, platformBody]); } void CreatePointOnLineServoConstraintExample2(Scene scene) { // Create two separate line entities for better control of each stack var lineSize = new Vector3(0.1f, 10, 0.1f); var lineOffset = new Vector3(-4, 5f, 0); var libeBOffset = new Vector3(0, 0, -1); var lineAPosition = lineOffset; var lineEntityA = CreateCubeEntity(\"LineA\", Color.Gold, lineAPosition, lineSize); var lineBodyA = lineEntityA.Get<BodyComponent>(); lineBodyA.Kinematic = true; lineBodyA.CollisionLayer = CollisionLayer.Layer1; lineEntityA.Scene = scene; var lineBPosition = lineOffset + libeBOffset; var lineEntityB = CreateCubeEntity(\"LineB\", Color.Gold, lineBPosition, lineSize); var lineBodyB = lineEntityB.Get<BodyComponent>(); lineBodyB.Kinematic = true; lineBodyB.CollisionLayer = CollisionLayer.Layer1; lineEntityB.Scene = scene; var cubeSize = new Vector3(0.99f); for (int i = 0; i < 10; i++) { // First stack (SetA) var cubePositionA = lineOffset + new Vector3(0, i * 2, 0); var cubeEntitySetA = CreateCubeEntity(\"CubeStackA\", Color.DarkRed, cubePositionA, cubeSize); var cubeBodySetA = SetupCubeBody(cubeEntitySetA); // Tighter constraint with the line to prevent X/Z drift var pointOnLineServoConstraintSetA = CreatePointOnLineServoConstraint(lineBodyA, cubeBodySetA); // Keep orientation aligned with world axes var angularServoSetA = CreateOneBodyAngularServoConstraint(cubeBodySetA); lineEntityA.Add(pointOnLineServoConstraintSetA); cubeEntitySetA.Add(angularServoSetA); cubeEntitySetA.Scene = scene; // Second stack (SetB) var cubePositionB = lineOffset + libeBOffset + new Vector3(0, i * 2, 0); var cubeEntitySetB = CreateCubeEntity(\"CubeStackB\", Color.DarkRed, cubePositionB, cubeSize); var cubeBodySetB = SetupCubeBody(cubeEntitySetB); var pointOnLineServoConstraintSetB = CreatePointOnLineServoConstraint(lineBodyB, cubeBodySetB); var angularServoSetB = CreateOneBodyAngularServoConstraint(cubeBodySetB); lineEntityB.Add(pointOnLineServoConstraintSetB); cubeEntitySetB.Add(angularServoSetB); cubeEntitySetB.Scene = scene; } } void ProcessMouseClick() { TryRemoveCubeStack(game.Input.MousePosition); TrySelectSphere(game.Input.MousePosition); } void TryRemoveCubeStack(Vector2 mousePosition) { var hit = mainCamera.Raycast(mousePosition, 100, out var hitInfo); if (hit && (hitInfo.Collidable.Entity.Name == \"CubeStackA\" || hitInfo.Collidable.Entity.Name == \"CubeStackB\")) { // Get the stack name to determine which column was clicked string stackName = hitInfo.Collidable.Entity.Name; // Apply small upward force to cubes above the clicked one to ensure movement var clickedY = hitInfo.Collidable.Entity.Transform.Position.Y; var clickedZ = hitInfo.Collidable.Entity.Transform.Position.Z; // Remove the clicked cube hitInfo.Collidable.Entity.Scene = null; // Find and nudge cubes above this position in the same stack foreach (var entity in game.SceneSystem.SceneInstance.RootScene.Entities) { if (entity.Name == stackName) { var pos = entity.Transform.Position; if (Math.Abs(pos.Z - clickedZ) < 0.1f && pos.Y > clickedY) { // Add a tiny impulse to get things moving var body = entity.Get<BodyComponent>(); if (body != null) { body.ApplyLinearImpulse(new Vector3(0, -0.01f, 0)); body.Awake = true; } } } } } //if (hit && hitInfo.Collidable.Entity.Name == \"CubeStack\") //{ // hitInfo.Collidable.Entity.Scene = null; //} } // Attempts to select the sphere by performing a raycast from the mouse position // If successful, calculates the offset between the sphere's center and the click point bool TrySelectSphere(Vector2 mousePosition) { // Perform a raycast from the camera into the scene var hit = mainCamera.Raycast(mousePosition, 100, out var hitInfo); if (hit && hitInfo.Collidable.Entity.Name == DraggableEntityName) { Console.WriteLine($\"Sphere selected for dragging: {hitInfo.Collidable.Entity.Transform.Position}\"); draggableBody = hitInfo.Collidable.Entity.Get<BodyComponent>(); //if (draggableBody == null) return false; // Calculate the offset between the sphere's center and the hit point dragOffset = draggableBody!.Position - hitInfo.Point; // Set the sphere to be kinematic while dragging draggableBody.Kinematic = true; isDraggingSphere = true; // Capture the current Y level to use for horizontal dragging initialDragY = draggableBody.Position.Y; // Reset the vertical offset verticalOffset = 0; return true; } return false; } // Computes the intersection point between the camera's pick ray and a horizontal plane at dragYPosition // This is used to update the sphere's new position based on mouse movement Vector3 GetNewPosition(Vector2 mousePosition) { // Create a pick ray from the camera through the given mouse position var ray = mainCamera!.GetPickRay(mousePosition); // Define a horizontal plane at Y = dragYPosition. // For a plane defined by Normal and D, D must be -dragYPosition var horizontalPlane = new Plane(Vector3.UnitY, -initialDragY); if (ray.Intersects(in horizontalPlane, out float distance)) { return ray.Position + ray.Direction * distance; } // If no intersection is found, return the last known sphere position return lastSpherePosition; } // Resets the scene by removing all entities and reinitializing them void ResetTheScene(Scene scene) { for (int i = 0; i < entities.Count; i++) { if (entities[i] is null) continue; entities[i]!.Scene = null; entities[i] = null; } for (int i = 0; i < bodies.Count; i++) { bodies[i] = null; } InitializeEntities(scene); } void DisplayInstructions() => instructions?.Print(); void InitializeDebugTextPrinter() { var screenSize = new Int2(game.GraphicsDevice.Presenter.BackBuffer.Width, game.GraphicsDevice.Presenter.BackBuffer.Height); instructions = new DebugTextPrinter() { DebugTextSystem = game.DebugTextSystem, TextSize = new(205, 17 * 4), ScreenSize = screenSize, Instructions = [ new(\"GAME INSTRUCTIONS\"), new(\"Click the golden sphere and drag to move it (Y-axis locked)\"), new(\"Hold Z to move up, X to move down the golded sphere\", Color.Yellow), new(\"Press R to reset the scene\", Color.Yellow), ] }; instructions.Initialize(DisplayPosition.BottomLeft); } Entity CreateCubeEntity(string name, Color color, Vector3 position, Vector3? size = null) => CreateEntity(PrimitiveModelType.Cube, name, color, position, size); Entity CreateEntity(PrimitiveModelType type, string name, Color color, Vector3 position, Vector3? size = null) { var entity = game.Create3DPrimitive(type, new() { EntityName = name, Material = game.CreateMaterial(color), Size = size }); entity.Transform.Position = position; return entity; } static BodyComponent SetupCubeBody(Entity cubeEntitySetA) { var cubeBodySetA = cubeEntitySetA.Get<BodyComponent>(); cubeBodySetA.SpringDampingRatio = CubeSpringDampingRation; cubeBodySetA.SpringFrequency = SpringFrequency; cubeBodySetA.FrictionCoefficient = FrictionCoefficient; cubeBodySetA.CollisionLayer = CollisionLayer.Layer2; return cubeBodySetA; } static PointOnLineServoConstraintComponent CreatePointOnLineServoConstraint(BodyComponent lineBodyA, BodyComponent cubeBodySetA) { return new PointOnLineServoConstraintComponent { A = lineBodyA, B = cubeBodySetA, LocalOffsetA = Vector3.Zero, // Anchor directly on line LocalOffsetB = Vector3.Zero, // Anchor at center of cube LocalDirection = new Vector3(0, 1, 0), ServoMaximumForce = ServoMaxForce, SpringFrequency = 15, // Add explicit spring frequency for smoother motion SpringDampingRatio = 1, // Critical damping }; } static OneBodyAngularServoConstraintComponent CreateOneBodyAngularServoConstraint(BodyComponent cubeBodySetA) { var angularServoSetA = new OneBodyAngularServoConstraintComponent { TargetOrientation = Quaternion.Identity, A = cubeBodySetA, ServoMaximumForce = ServoMaxForce, SpringDampingRatio = 5, SpringFrequency = 15, // Enable frequency for more responsive rotation control }; return angularServoSetA; }"
  },
  "manual/code-only/examples/cylinder-mesh.html": {
    "href": "manual/code-only/examples/cylinder-mesh.html",
    "title": "Cylinder mesh | Stride Community Toolkit Manual",
    "summary": "Cylinder mesh This example demonstrates creating a 3D cylinder mesh programmatically by breaking down the process into clear, distinct steps: Setting up a basic 3D scene with a skybox Creating precisely defined geometry using low-level mesh construction techniques Demonstrating a structured approach to 3D mesh generation by dividing it into logical components: Creating ring vertices Building side walls Adding end caps We will be utilizing the MeshBuilder class from the toolkit, the process of crafting and rendering these geometries is streamlined. For more details of MeshBuilder, refer to our MeshBuilder manual. Note This example requires the additional NuGet packages Stride.CommunityToolkit.Skyboxes and Stride.CommunityToolkit.Bepu. Make sure to install both before running the code. View on GitHub. using Stride.CommunityToolkit.Bepu; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Rendering.Utilities; using Stride.CommunityToolkit.Skyboxes; using Stride.Core.Mathematics; using Stride.Engine; using Stride.Graphics; using Stride.Rendering; using Stride.Rendering.Materials; using Stride.Rendering.Materials.ComputeColors; /* Procedural Cylinder Mesh Generation This example demonstrates creating a 3D cylinder mesh programmatically by breaking down the process into clear, distinct steps: 1. Setting up a basic 3D scene with a skybox 2. Creating precisely defined geometry using low-level mesh construction techniques 3. Demonstrating a structured approach to 3D mesh generation by dividing it into logical components: - Creating ring vertices - Building side walls - Adding end caps The example showcases proper 3D graphics fundamentals like vertex positioning, normal definitions, triangle winding order, and efficient vertex reuse through indexing. It also demonstrates good software engineering practices by separating concerns into well-named methods with clear responsibilities. */ const int Segments = 1000; const float Radius = 0.5f; const float Length = 8; using var game = new Game(); game.Run(start: (Scene rootScene) => { game.SetupBase3DScene(); game.AddSkybox(); CreateMeshEntity(game.GraphicsDevice, rootScene, new(0, 1, -Length / 2), b => BuildCylinderMesh(b, Segments, Radius, Length)); }); Entity CreateMeshEntity(GraphicsDevice graphicsDevice, Scene scene, Vector3 position, Action<MeshBuilder> build) { using var meshBuilder = new MeshBuilder(); build(meshBuilder); var model = new Model { new MaterialInstance { Material = CreateMaterial(game) }, new Mesh { Draw = meshBuilder.ToMeshDraw(graphicsDevice), MaterialIndex = 0 } }; var entity = new Entity { Scene = scene, Transform = { Position = position } }; entity.Add(new ModelComponent { Model = model }); return entity; } void BuildCylinderMesh(MeshBuilder meshBuilder, int segments, float radius, float length) { meshBuilder.WithIndexType(IndexingType.Int16); meshBuilder.WithPrimitiveType(PrimitiveType.TriangleList); var position = meshBuilder.WithPosition<Vector3>(); var normal = meshBuilder.WithNormal<Vector3>(); // Create the vertices for both circular ends // First end (z = 0) CreateRingVertices(meshBuilder, segments, radius, position, normal, 0); // Second end (z = length) CreateRingVertices(meshBuilder, segments, radius, position, normal, length); CreateCylinderSideWalls(meshBuilder, segments); // Create the first end cap (closing the cylinder) CreateCircularEndCap(meshBuilder, segments, position, normal, 0, false); // Create the second end cap (closing the cylinder) CreateCircularEndCap(meshBuilder, segments, position, normal, length, true); } static Material CreateMaterial(Game game) => Material.New(game.GraphicsDevice, new() { Attributes = new() { MicroSurface = new MaterialGlossinessMapFeature { GlossinessMap = new ComputeFloat(0.9f) }, Diffuse = new MaterialDiffuseMapFeature { DiffuseMap = new ComputeColor(new Color4(1, 0.3f, 0.5f, 1)) }, DiffuseModel = new MaterialDiffuseLambertModelFeature(), Specular = new MaterialMetalnessMapFeature { MetalnessMap = new ComputeFloat(0.0f) }, SpecularModel = new MaterialSpecularMicrofacetModelFeature { Environment = new MaterialSpecularMicrofacetEnvironmentGGXPolynomial() }, } }); static void CreateRingVertices(MeshBuilder meshBuilder, int segments, float radius, int position, int normal, float zPosition) { for (var i = 0; i < segments; i++) { var x = radius * (float)Math.Sin(Math.Tau / segments * i); var y = radius * (float)Math.Cos(Math.Tau / segments * i); meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(x, y, zPosition)); meshBuilder.SetElement(normal, new Vector3(x, y, 0)); } } // Creates the triangles that form the curved side wall of the cylinder static void CreateCylinderSideWalls(MeshBuilder meshBuilder, int segments) { for (var i = 0; i < segments; i++) { var i_next = (i + 1) % segments; // First triangle of the quad meshBuilder.AddIndex(i); meshBuilder.AddIndex(i_next + segments); meshBuilder.AddIndex(i + segments); // Second triangle of the quad meshBuilder.AddIndex(i); meshBuilder.AddIndex(i_next); meshBuilder.AddIndex(i_next + segments); } } // Creates a circular cap to close one end of the cylinder static void CreateCircularEndCap(MeshBuilder meshBuilder, int segments, int position, int normal, float zPosition, bool isEndFacingPositiveZ) { // Create center vertex int centerVertexIndex = meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(0f, 0f, zPosition)); // Set normal direction based on which end we're creating var normalDirection = isEndFacingPositiveZ ? new Vector3(0, 0, 1) : new Vector3(0, 0, -1); meshBuilder.SetElement(normal, normalDirection); // First end cap has vertices from 0 to segments-1 // Second end cap has vertices from segments to 2*segments-1 int vertexOffset = isEndFacingPositiveZ ? segments : 0; // Create triangles to form the cap for (var i = 0; i < segments; i++) { if (isEndFacingPositiveZ) { // For end cap with Z+ normal meshBuilder.AddIndex(((i + 1) % segments) + vertexOffset); meshBuilder.AddIndex(centerVertexIndex); meshBuilder.AddIndex(i + vertexOffset); } else { // For end cap with Z- normal meshBuilder.AddIndex(((i + 1) % segments) + vertexOffset); meshBuilder.AddIndex(i + vertexOffset); meshBuilder.AddIndex(centerVertexIndex); } } }"
  },
  "manual/code-only/examples/debug-shapes.html": {
    "href": "manual/code-only/examples/debug-shapes.html",
    "title": "Debug Shapes | Stride Community Toolkit Manual",
    "summary": "Debug Shapes This example sets up a basic 3D scene and adds debugging visuals. A special entity with a ShapeUpdater component is added to update and render debug shapes in the scene, making it easier to visualize spatial information during development. Note This example requires the additional NuGet packages Stride.CommunityToolkit.Skyboxes and Stride.CommunityToolkit.Bepu. Make sure to install both before running the code. View on GitHub. using Example08_DebugShapes.Scripts; using Stride.CommunityToolkit.Bullet; using Stride.CommunityToolkit.DebugShapes.Code; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Skyboxes; using Stride.Engine; using var game = new Game(); game.Run(start: Start); void Start(Scene rootScene) { AddDebugComponent(rootScene); SetupBaseScene(); } void SetupBaseScene() { game.AddGraphicsCompositor(); game.Add3DCamera().Add3DCameraController(); game.AddDirectionalLight(); game.AddSkybox(); game.Add3DGround(); game.AddDebugShapes(); } void AddDebugComponent(Scene scene) { var entity = new Entity(\"Debug Shapes\") { new ShapeUpdater() }; scene.Entities.Add(entity); }"
  },
  "manual/code-only/examples/give-me-cube-body.html": {
    "href": "manual/code-only/examples/give-me-cube-body.html",
    "title": "Give me a cube | Stride Community Toolkit Manual",
    "summary": "Give me a cube This example demonstrates the essential steps to create a 3D cube in Stride. Just like the previous example, the cube entity comes automatically equipped with a rigid body and a collider, thanks to the CreatePrimitive() method. The cube is positioned at (1f, 0.5f, 3f) in the 3D world space. This example is perfect for those who are new to 3D game development with Stride. Note This example requires the additional NuGet packages Stride.CommunityToolkit.Skyboxes and Stride.CommunityToolkit.Bepu. Make sure to install both before running the code. View on GitHub. using Stride.CommunityToolkit.Bepu; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Rendering.ProceduralModels; using Stride.CommunityToolkit.Skyboxes; using Stride.Core.Mathematics; using Stride.Engine; using var game = new Game(); game.Run(start: Start); void Start(Scene rootScene) { game.SetupBase3DScene(); game.AddSkybox(); var entity = game.Create3DPrimitive(PrimitiveModelType.Cube); entity.Transform.Position = new Vector3(1f, 0.5f, 3f); entity.Scene = rootScene; }"
  },
  "manual/code-only/examples/image-processing.html": {
    "href": "manual/code-only/examples/image-processing.html",
    "title": "Image processing | Stride Community Toolkit Manual",
    "summary": "Image processing View on GitHub. using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Extensions; using Stride.CommunityToolkit.Rendering.Utilities; using Stride.Core.Mathematics; using Stride.Engine; using Stride.Graphics; using Stride.Rendering.Images; using Stride.Rendering.Sprites; using Stride.UI; using Stride.UI.Controls; using Stride.UI.Panels; using System.Reflection; using var game = new Game(); game.Run(start: Start); static void Start(Game game) { game.Window.SetSize(new Int2(1000, 1080)); game.SetupBase(); var directory = Path.GetDirectoryName(Assembly.GetEntryAssembly()!.Location)!; var filePath = Path.Combine(directory, \"input.png\"); using var input = File.Open(filePath, FileMode.Open); var texture = Texture.Load(game.GraphicsDevice, input); var grid = new UniformGrid { Width = 1000, Height = 1000, Columns = 9, Rows = 9, Margin = new Thickness(8, 8, 8, 8) }; grid.Children.Add(CreateCard(texture)); for (var a = 0; a < 9; a++) { var anchor = (TextureCanvas.Anchor)a; for (var s = 0; s < 4; s++) { var stretch = (TextureCanvas.Stretch)s; using (var canvas = game.CreateTextureCanvas(new Size2(1024, 1024))) { canvas.DrawTexture(texture, new Rectangle(0, 128, 256, 256), new Rectangle(128, 256, 768, 512), null, stretch, anchor, SamplingPattern.Expanded); var card = CreateCard(canvas.ToTexture()); card.SetGridColumn(a); card.SetGridRow(s * 2 + 1); grid.Children.Add(card); } using (var canvas = game.CreateTextureCanvas(new Size2(1024, 1024))) { canvas.DrawTexture(texture, new Rectangle(0, 128, 256, 256), new Rectangle(256, 128, 512, 768), null, stretch, anchor); var card = CreateCard(canvas.ToTexture()); card.SetGridColumn(a); card.SetGridRow(s * 2 + 2); grid.Children.Add(card); } } } var entity = new Entity { Scene = game.SceneSystem.SceneInstance.RootScene }; entity.Add(new UIComponent { Page = new UIPage { RootElement = grid } }); } static Border CreateCard(Texture texture) { var card = new Border { BorderColor = new Color(25, 25, 25), BackgroundColor = new Color(120, 120, 120), BorderThickness = new Thickness(2, 2, 2, 2), Padding = new Thickness(8, 8, 8, 8), Margin = new Thickness(4, 4, 4, 4), Content = new StackPanel { Orientation = Orientation.Vertical, Children = { new ImageElement { Source = new SpriteFromTexture { Texture = texture } } } } }; return card; }"
  },
  "manual/code-only/examples/material.html": {
    "href": "manual/code-only/examples/material.html",
    "title": "Material | Stride Community Toolkit Manual",
    "summary": "Material This example demonstrates how to create and configure various materials. The sample creates multiple cube primitives with different material properties: Basic colored materials with varying glossiness and metalness Custom materials defined through code with different surface properties Three advanced materials showing different combinations of diffuse color, micro-surface properties, and specular reflection The example also includes an interactive environment where users can adjust the skybox light intensity using keyboard controls (Z to decrease, X to increase), allowing real-time observation of how lighting affects the appearance of different materials. Note This example requires the additional NuGet packages Stride.CommunityToolkit.Skyboxes and Stride.CommunityToolkit.Bepu. Make sure to install both before running the code. View on GitHub. using Stride.CommunityToolkit.Bepu; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Rendering.ProceduralModels; using Stride.CommunityToolkit.Scripts.Utilities; using Stride.CommunityToolkit.Skyboxes; using Stride.Core.Mathematics; using Stride.Engine; using Stride.Games; using Stride.Input; using Stride.Rendering; using Stride.Rendering.Materials; using Stride.Rendering.Materials.ComputeColors; const float IntensityChangeStep = 0.5f; DebugTextPrinter? instructions = null; LightComponent? skyBoxLightComponent = null; float skyBoxLightIntensity = 0; using var game = new Game(); game.Run(start: Start, update: Update); void Start(Scene scene) { game.SetupBase3DScene(); var skyboxEntity = game.AddSkybox(); skyBoxLightComponent = skyboxEntity.GetComponent<LightComponent>(); skyBoxLightIntensity = skyBoxLightComponent?.Intensity ?? 1; Create3DPrimitive(scene, new Vector3(-5f, 0.5f, -1f), game.CreateMaterial(Color.Green)); Create3DPrimitive(scene, new Vector3(-5f, 0.5f, -3f), game.CreateMaterial(Color.Green, 0.1f, 0.1f)); Create3DPrimitive(scene, new Vector3(-5f, 0.5f, -5f), game.CreateMaterial(Color.Green, 4f, 0.75f)); Create3DPrimitive(scene, new Vector3(-1f, 0.5f, -1f), GetMaterial1()); Create3DPrimitive(scene, new Vector3(1f, 0.5f, -1f), GetMaterial2()); Create3DPrimitive(scene, new Vector3(0f, 0.5f, 1f), GetMaterial3()); InitializeDebugTextPrinter(); } void Create3DPrimitive(Scene scene, Vector3 position, Material material) { var entity = game.Create3DPrimitive(PrimitiveModelType.Cube, new() { Material = material }); entity.Transform.Position = position; entity.Scene = scene; } void Update(Scene scene, GameTime time) { if (skyBoxLightComponent == null) return; if (game.Input.IsKeyPressed(Keys.Z)) { skyBoxLightIntensity -= IntensityChangeStep; skyBoxLightComponent.Intensity = skyBoxLightIntensity; } if (game.Input.IsKeyPressed(Keys.X)) { skyBoxLightIntensity += IntensityChangeStep; skyBoxLightComponent.Intensity = skyBoxLightIntensity; } // Display on-screen instructions for the user DisplayInstructions(); } Material GetMaterial1() { return Material.New(game.GraphicsDevice, new() { Attributes = new() { MicroSurface = new MaterialGlossinessMapFeature { GlossinessMap = new ComputeFloat(0.9f) }, Diffuse = new MaterialDiffuseMapFeature { DiffuseMap = new ComputeColor(new Color4(1, 0.3f, 0.5f, 1)) }, DiffuseModel = new MaterialDiffuseLambertModelFeature(), Specular = new MaterialMetalnessMapFeature { MetalnessMap = new ComputeFloat(0.0f) }, SpecularModel = new MaterialSpecularMicrofacetModelFeature { Environment = new MaterialSpecularMicrofacetEnvironmentGGXPolynomial() }, } }); } Material GetMaterial2() { return Material.New(game.GraphicsDevice, new() { Attributes = new() { MicroSurface = new MaterialGlossinessMapFeature { GlossinessMap = new ComputeFloat(0.9f) }, Diffuse = new MaterialDiffuseMapFeature { DiffuseMap = new ComputeColor(Color.Blue) }, DiffuseModel = new MaterialDiffuseLambertModelFeature(), Specular = new MaterialMetalnessMapFeature { MetalnessMap = new ComputeFloat(0.0f) }, SpecularModel = new MaterialSpecularMicrofacetModelFeature { Environment = new MaterialSpecularMicrofacetEnvironmentGGXPolynomial() }, } }); } Material GetMaterial3() { return Material.New(game.GraphicsDevice, new() { Attributes = new() { MicroSurface = new MaterialGlossinessMapFeature { GlossinessMap = new ComputeFloat(0.1f) }, Diffuse = new MaterialDiffuseMapFeature { DiffuseMap = new ComputeColor(Color.Gold) }, DiffuseModel = new MaterialDiffuseLambertModelFeature(), Specular = new MaterialMetalnessMapFeature { MetalnessMap = new ComputeFloat(0.8f) }, SpecularModel = new MaterialSpecularMicrofacetModelFeature { Environment = new MaterialSpecularMicrofacetEnvironmentGGXPolynomial() }, } }); } void DisplayInstructions() { instructions?.Print(GenerateInstructions(skyBoxLightIntensity)); } void InitializeDebugTextPrinter() { var screenSize = new Int2(game.GraphicsDevice.Presenter.BackBuffer.Width, game.GraphicsDevice.Presenter.BackBuffer.Height); instructions = new DebugTextPrinter() { DebugTextSystem = game.DebugTextSystem, TextSize = new(205, 17 * 4), ScreenSize = screenSize, Instructions = GenerateInstructions(skyBoxLightIntensity) }; instructions.Initialize(DisplayPosition.BottomLeft); } static List<TextElement> GenerateInstructions(float skyBoxLightIntensity) => [ new(\"GAME INSTRUCTIONS\"), //new(\"Click the golden sphere and drag to move it (Y-axis locked)\"), new(\"Hold Z to decrease, X to increase Skybox light intensity\", Color.Yellow), new($\"Intensity: {skyBoxLightIntensity}\", Color.Yellow), ];"
  },
  "manual/code-only/examples/mesh-line.html": {
    "href": "manual/code-only/examples/mesh-line.html",
    "title": "Mesh line | Stride Community Toolkit Manual",
    "summary": "Mesh line This example demonstrates how to create a simple 3D scene with a custom mesh line connecting two objects. The code shows: Setting up a basic 3D scene Creating two sphere entities positioned in 3D space Building a custom mesh line by: Defining vertices for start and end points Creating vertex and index buffers Configuring a mesh draw with line list primitive type Applying an emissive color material for visibility The line is attached as a child to one of the spheres, creating a visual connection between the two objects. This approach illustrates how to create basic geometric primitives and custom line visualizations in a Stride 3D environment using low-level graphics APIs. Note This example requires the additional NuGet packages Stride.CommunityToolkit.Skyboxes and Stride.CommunityToolkit.Bepu. Make sure to install both before running the code. View on GitHub. using Stride.CommunityToolkit.Bepu; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Rendering.Gizmos; using Stride.CommunityToolkit.Rendering.ProceduralModels; using Stride.CommunityToolkit.Skyboxes; using Stride.Core.Mathematics; using Stride.Engine; using Stride.Graphics; using Stride.Rendering; using Buffer = Stride.Graphics.Buffer; using var game = new Game(); game.Run(start: Start); void Start(Scene rootScene) { game.SetupBase3DScene(); game.AddSkybox(); var lineEntity = CreateLineEntity(game); var entity1 = CreateSphereEntity(game); entity1.Transform.Position = new Vector3(0, 8, 0); entity1.AddChild(lineEntity); var entity2 = CreateSphereEntity(game); entity2.Transform.Position = new Vector3(-0.01f, 9, -0.01f); entity1.Scene = rootScene; entity2.Scene = rootScene; }; static Entity CreateSphereEntity(Game game) => game.Create3DPrimitive(PrimitiveModelType.Sphere); static Entity CreateLineEntity(Game game) { // Create vertex buffer with start and end points var vertices = new Vector3[] { new(0, 0, 0), new(1, 1, -1) }; var vertexBuffer = Buffer.New(game.GraphicsDevice, vertices, BufferFlags.VertexBuffer); // Create index buffer var indices = new short[] { 0, 1 }; var indexBuffer = Buffer.New(game.GraphicsDevice, indices, BufferFlags.IndexBuffer); var material = GizmoEmissiveColorMaterial.Create(game.GraphicsDevice, Color.DarkMagenta); // Or use this for a specific color //var material = game.CreateMaterial(Color.DarkMagenta); var meshDraw = new MeshDraw { PrimitiveType = PrimitiveType.LineList, VertexBuffers = [new VertexBufferBinding(vertexBuffer, new VertexDeclaration(VertexElement.Position<Vector3>()), vertices.Length)], IndexBuffer = new IndexBufferBinding(indexBuffer, is32Bit: false, indices.Length), DrawCount = indices.Length }; var mesh = new Mesh { Draw = meshDraw }; var model = new Model { mesh, material }; return new Entity { new ModelComponent(model) }; }"
  },
  "manual/code-only/examples/myra-ui-draggable-window-and-services.html": {
    "href": "manual/code-only/examples/myra-ui-draggable-window-and-services.html",
    "title": "Myra UI - Draggable Window, GetService() | Stride Community Toolkit Manual",
    "summary": "Myra UI - Draggable Window, GetService() This example showcases how to integrate Myra, an external UI library, into your game developed with Stride. Myra provides a rich set of widgets and functionalities to enhance the graphical user interface of your game. Key features in this example: Draggable Window: The example demonstrates how to implement a draggable window within the game using Myra's UI components. This draggable window serves as a movable and interactive element that can host other widgets, thus offering a dynamic interface experience for the player. Health Bar: This example features two distinct health bars. The first one is statically defined within the MainView class, while the second is dynamically added during runtime. Both bars can be customized to represent a variety of in-game attributes, such as player health, experience, or other performance metrics. Dynamic Initialization: The UI components, including the health bar, are initialized dynamically during the game's runtime. This allows for greater flexibility and responsiveness in the game's UI. Service Retrieval: The example illustrates the use of GetService() to retrieve services dynamically, thus fostering loose coupling between various components of the game. This practice promotes code reusability and easier maintenance. By following this example, you will gain insights into how to extend your game's capabilities by leveraging external libraries for UI and best practices for service retrieval and dynamic UI component initialization. View on GitHub. using Example04_MyraUI; using Stride.CommunityToolkit.Bepu; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Rendering.Compositing; using Stride.CommunityToolkit.Skyboxes; using Stride.Engine; using Stride.Games; using var game = new Game(); // State flag to track health bar visibility bool isHealthBarVisible = false; game.Run(start: Start, update: Update); void Start(Scene rootScene) { SetupBase3DScene(); } void Update(Scene rootScene, GameTime time) { InitializeHealthBar(); } void SetupBase3DScene() { game.AddGraphicsCompositor() .AddCleanUIStage() //optional .AddSceneRenderer(new MyraSceneRenderer()); game.Add3DCamera().Add3DCameraController(); game.AddDirectionalLight(); game.AddSkybox(); game.Add3DGround(); } // Initializes the health bar if it is not already visible. void InitializeHealthBar() { if (isHealthBarVisible) return; var mainView = game.Services.GetService<MainView>(); if (mainView == null) return; // Create and add a new health bar to the main view mainView.Widgets.Add(UIUtils.CreateHealthBar(-50, \"#FFD961FF\")); isHealthBarVisible = true; } MyraSceneRenderer.cs This class provides functionality for rendering Myra-based user interfaces in a Stride game. using Myra; using Myra.Graphics2D.UI; using Stride.Engine; using Stride.Games; using Stride.Graphics; using Stride.Rendering; using Stride.Rendering.Compositing; namespace Example04_MyraUI; /// <summary> /// Provides functionality for rendering Myra-based user interfaces in a Stride game. /// </summary> /// <remarks> /// This renderer uses the Myra UI library to render the user interface and integrates it into the Stride rendering pipeline. /// </remarks> public class MyraSceneRenderer : SceneRendererBase { /// <summary> /// Gets or sets the root of all UI elements to be rendered. /// </summary> /// <remarks> /// The desktop serves as the root container for all UI elements rendered by Myra. /// </remarks> private Desktop? _desktop; /// <summary> /// Gets or sets the main view of the application UI. /// </summary> /// <remarks> /// The main view contains the primary UI elements that the user will interact with. /// </remarks> private MainView? _mainView; /// <summary> /// Initializes the core rendering properties. /// </summary> /// <remarks> /// This method sets up the Myra environment, configures the main view, and associates it with the desktop. /// </remarks> protected override void InitializeCore() { base.InitializeCore(); MyraEnvironment.Game = (Game)Services.GetService<IGame>(); InitializeMainView(); InitializeDesktop(); } /// <summary> /// Initializes the main view and adds it to the Stride services. /// </summary> private void InitializeMainView() { _mainView = new MainView(); Services.AddService(_mainView); } /// <summary> /// Initializes the desktop and sets the root view. /// </summary> private void InitializeDesktop() { _desktop = new Desktop { Root = _mainView }; } protected override void DrawCore(RenderContext context, RenderDrawContext drawContext) { // Clear depth buffer drawContext.CommandList.Clear(GraphicsDevice.Presenter.DepthStencilBuffer, DepthStencilClearOptions.DepthBuffer); // Render UI _desktop?.Render(); } } MainView.cs This class creates the main UI window MainView and the health bar using HorizontalProgressBar. using Myra.Graphics2D.UI; namespace Example04_MyraUI; /// <summary> /// Represents the main user interface view for the application. /// </summary> /// <remarks> /// The MainView class is responsible for creating and managing key UI elements such as a health bar and a test window. /// </remarks> public class MainView : Panel { /// <summary> /// Gets the health bar UI element. /// </summary> /// <remarks> /// The health bar shows the current health status. /// </remarks> public HorizontalProgressBar HealthBar { get; private set; } = null!; /// <summary> /// Gets the test window UI element. /// </summary> /// <remarks> /// The example window is used for demo purposes and contains a sample label. /// </remarks> public Window ExampleWindow { get; private set; } = null!; /// <summary> /// Initializes a new instance of the <see cref=\"MainView\"/> class. /// </summary> public MainView() { InitializeHealthBar(); InitializeTestWindow(); } /// <summary> /// Initializes the health bar UI element. /// </summary> private void InitializeHealthBar() => Widgets.Add(UIUtils.CreateHealthBar(-20, \"#4BD961FF\")); /// <summary> /// Initializes the test window UI element. /// </summary> private void InitializeTestWindow() { var label = new Label { VerticalSpacing = 10, Text = \"This is a Test! Hello from Myra! This is a draggable window and below two progress bars.\" }; ExampleWindow = new Window { Title = \"Hello From Myra\", Left = 590, Top = 200, Content = label }; Widgets.Add(ExampleWindow); } } UIUtils.cs This class contains helper methods to create UI elements, which are used in multiple places in the example. using Myra.Graphics2D.Brushes; using Myra.Graphics2D.UI; namespace Example04_MyraUI; /// <summary> /// Utility class to create custom UI widgets. /// </summary> public static class UIUtils { /// <summary> /// Creates a new <see cref=\"HorizontalProgressBar\"/> with the given top position and filler color. /// </summary> /// <param name=\"top\">The top position of the progress bar.</param> /// <param name=\"filler\">The filler color of the progress bar.</param> /// <returns>A new <see cref=\"HorizontalProgressBar\"/> instance.</returns> public static HorizontalProgressBar CreateHealthBar(int top, string filler) { return new HorizontalProgressBar { HorizontalAlignment = HorizontalAlignment.Left, VerticalAlignment = VerticalAlignment.Bottom, Value = 100, Filler = new SolidBrush(filler), Left = 20, Top = top, Width = 300, Height = 20, Background = new SolidBrush(\"#202020FF\") }; } } Other Examples Using Myra in Stride Engine Tutorial"
  },
  "manual/code-only/examples/partial-torus-mesh-fs.html": {
    "href": "manual/code-only/examples/partial-torus-mesh-fs.html",
    "title": "Partial torus mesh | Stride Community Toolkit Manual",
    "summary": "Partial torus mesh This example demonstrates creating a 3D partial torus mesh programmatically by breaking down the process into clear, distinct steps: Setting up a basic 3D scene with a skybox Creating a parametrically defined torus geometry using mathematical formulas Demonstrating how to generate a partial (incomplete) torus by constraining the bend angle Building structured 3D mesh generation with proper vertex positioning and normal definitions The example showcases important 3D graphics concepts including: Parametric surface generation using two angle parameters (circumference and bend) Correct normal calculation for accurate lighting and shading Triangle winding order for proper face orientation Vertex indexing to efficiently reuse vertices between adjacent triangles For more details of MeshBuilder, refer to our MeshBuilder manual. Tip Notice the effect of back-face culling when moving the camera around the objects. With the default culling mode enabled, back faces are not rendered, optimizing performance by avoiding the drawing of surfaces that are not visible to the camera. For open or partially open 3D models, viewing from inside or even from outside through an open area may cause the model to appear incomplete. This is normal behavior since back-face culling intentionally omits surfaces facing away from the camera. Note This example requires the additional NuGet packages Stride.CommunityToolkit.Skyboxes and Stride.CommunityToolkit.Bepu. Make sure to install both before running the code. View on GitHub. open Stride.CommunityToolkit.Bepu; open Stride.CommunityToolkit.Engine; open Stride.CommunityToolkit.Skyboxes; open Stride.Core.Mathematics; open Stride.Engine; open Stride.CommunityToolkit.Rendering.Utilities open Stride.Graphics open System open Stride.Rendering open Stride.Rendering.Materials open Stride.Rendering.Materials.ComputeColors let game = new Game() let CreateMaterial (game: Game) : Material = Material.New( game.GraphicsDevice, MaterialDescriptor( Attributes = MaterialAttributes( MicroSurface = MaterialGlossinessMapFeature(GlossinessMap = ComputeFloat(0.9f)), Diffuse = MaterialDiffuseMapFeature(DiffuseMap = ComputeColor(Color4(1.0f, 0.3f, 0.5f, 1.0f))), DiffuseModel = MaterialDiffuseLambertModelFeature(), Specular = MaterialMetalnessMapFeature(MetalnessMap = ComputeFloat(0.0f)), SpecularModel = MaterialSpecularMicrofacetModelFeature( Environment = MaterialSpecularMicrofacetEnvironmentGGXPolynomial() ) ) ) ) let CreateMeshEntity (graphicsDevice:GraphicsDevice) (scene:Scene) (position:Vector3) (build:MeshBuilder -> unit) = use meshBuilder = new MeshBuilder() build(meshBuilder) let model = new Model() model.Add(MaterialInstance(Material = CreateMaterial(game))) model.Add(Mesh( Draw = meshBuilder.ToMeshDraw(graphicsDevice), MaterialIndex = 0 )) let entity = new Entity() entity.Scene <- scene entity.Transform.Position <- position entity.Add(ModelComponent(Model = model)) entity let BuildPartialTorusMesh (meshBuilder:MeshBuilder) cylinderRadius torusAngle bendRadius circumferenceStepsCount bendSegmentSteps = //for partial torus up to 360 degrees (tAngle in degrees) meshBuilder.WithIndexType(IndexingType.Int16) |> ignore meshBuilder.WithPrimitiveType(PrimitiveType.TriangleList) |> ignore let position = meshBuilder.WithPosition<Vector3>() let normal = meshBuilder.WithNormal<Vector3>() //vertices for j in 0..bendSegmentSteps do //Torus angle position Phi starts at 0 in line with Z-axis and increases to Pi/2 at X-axis let tPhi = (float j) * torusAngle / (float bendSegmentSteps) * Math.PI / 180.0 let xc = bendRadius * Math.Sin(tPhi) let zc = bendRadius * Math.Cos(tPhi) for i in 0..(circumferenceStepsCount - 1) do //circumference angle tTheta let tTheta = float i * Math.Tau / float circumferenceStepsCount let yr = cylinderRadius * Math.Sin(tTheta) let xr = cylinderRadius * Math.Cos(tTheta) * Math.Sin(tPhi) let zr = cylinderRadius * Math.Cos(tTheta) * Math.Cos(tPhi) let tNorm = Vector3(float32 xr, float32 yr, float32 zr) let tPos = Vector3(float32 (xc + xr), float32 yr, float32 (zc + zr)) meshBuilder.AddVertex() |> ignore meshBuilder.SetElement(position, tPos) meshBuilder.SetElement(normal, tNorm) //triangle eles for j in 0..(bendSegmentSteps - 1) do for i in 0..(circumferenceStepsCount - 1) do let i_tot = i + j * circumferenceStepsCount //build triangles let i_next = (i + 1) % circumferenceStepsCount + j * circumferenceStepsCount //triangle 1 meshBuilder.AddIndex(i_tot) meshBuilder.AddIndex(i_next + circumferenceStepsCount) meshBuilder.AddIndex(i_tot + circumferenceStepsCount) //triangle 2 meshBuilder.AddIndex(i_tot) meshBuilder.AddIndex(i_next) meshBuilder.AddIndex(i_next + circumferenceStepsCount) let Start rootScene = game.SetupBase3DScene() game.AddSkybox() |> ignore game.AddProfiler() |> ignore // Torus parameters let cylinderRadius = 0.3f let torusAngle = 270.0f let bendRadius = 1.0f let circumferenceStepsCount = 20 let bendSegmentSteps = 40 // Create torus mesh entity CreateMeshEntity game.GraphicsDevice rootScene (Vector3(0.0f, 1.0f, 0.0f)) (fun b -> BuildPartialTorusMesh b (float cylinderRadius) (float torusAngle) (float bendRadius) circumferenceStepsCount bendSegmentSteps) |> ignore [<EntryPoint>] let main argv = game.Run(start = Start) 0"
  },
  "manual/code-only/examples/partial-torus-mesh.html": {
    "href": "manual/code-only/examples/partial-torus-mesh.html",
    "title": "Partial torus mesh | Stride Community Toolkit Manual",
    "summary": "Partial torus mesh This example demonstrates creating a 3D partial torus mesh programmatically by breaking down the process into clear, distinct steps: Setting up a basic 3D scene with a skybox Creating a parametrically defined torus geometry using mathematical formulas Demonstrating how to generate a partial (incomplete) torus by constraining the bend angle Building structured 3D mesh generation with proper vertex positioning and normal definitions The example showcases important 3D graphics concepts including: Parametric surface generation using two angle parameters (circumference and bend) Correct normal calculation for accurate lighting and shading Triangle winding order for proper face orientation Vertex indexing to efficiently reuse vertices between adjacent triangles For more details of MeshBuilder, refer to our MeshBuilder manual. Tip Notice the effect of back-face culling when moving the camera around the objects. With the default culling mode enabled, back faces are not rendered, optimizing performance by avoiding the drawing of surfaces that are not visible to the camera. For open or partially open 3D models, viewing from inside or even from outside through an open area may cause the model to appear incomplete. This is normal behavior since back-face culling intentionally omits surfaces facing away from the camera. Note This example requires the additional NuGet packages Stride.CommunityToolkit.Skyboxes and Stride.CommunityToolkit.Bepu. Make sure to install both before running the code. View on GitHub. using Stride.CommunityToolkit.Bepu; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Rendering.Utilities; using Stride.CommunityToolkit.Skyboxes; using Stride.Core.Mathematics; using Stride.Engine; using Stride.Graphics; using Stride.Rendering; using Stride.Rendering.Materials; using Stride.Rendering.Materials.ComputeColors; /* Procedural Partial Torus Mesh Generation This example demonstrates creating a 3D partial torus mesh programmatically by breaking down the process into clear, distinct steps: 1. Setting up a basic 3D scene with a skybox 2. Creating a parametrically defined torus geometry using mathematical formulas 3. Demonstrating how to generate a partial (incomplete) torus by constraining the bend angle 4. Building structured 3D mesh generation with proper vertex positioning and normal definitions The example showcases important 3D graphics concepts including: - Parametric surface generation using two angle parameters (circumference and bend) - Correct normal calculation for accurate lighting and shading - Triangle winding order for proper face orientation - Vertex indexing to efficiently reuse vertices between adjacent triangles The partial nature of the torus also highlights the effect of back-face culling. When viewing the open ends of the torus from certain angles, you can see through to the inside or outside, as surfaces facing away from the camera are not rendered. This is normal behavior and improves performance by avoiding the drawing of surfaces that wouldn't be visible in a complete object. */ // Torus parameters const float CylinderRadius = 0.3f; const float TorusAngle = 270.0f; const float BendRadius = 1.0f; const int CircumferenceStepsCount = 20; const int BendSegmentSteps = 40; using var game = new Game(); game.Run(start: (Scene rootScene) => { game.SetupBase3DScene(); game.AddSkybox(); CreateMeshEntity( game.GraphicsDevice, rootScene, new Vector3(0.0f, 1.0f, 0.0f), b => BuildPartialTorusMesh(b, CylinderRadius, TorusAngle, BendRadius, CircumferenceStepsCount, BendSegmentSteps) ); }); Entity CreateMeshEntity(GraphicsDevice graphicsDevice, Scene scene, Vector3 position, Action<MeshBuilder> build) { using var meshBuilder = new MeshBuilder(); build(meshBuilder); var model = new Model { new MaterialInstance { Material = CreateMaterial(game) }, new Mesh { Draw = meshBuilder.ToMeshDraw(graphicsDevice), MaterialIndex = 0 } }; var entity = new Entity { Scene = scene, Transform = { Position = position } }; entity.Add(new ModelComponent { Model = model }); return entity; } void BuildPartialTorusMesh(MeshBuilder meshBuilder, float cylinderRadius, float torusAngle, float bendRadius, int circumferenceStepsCount, int bendSegmentSteps) { // for partial torus up to 360 degrees (torusAngle in degrees) meshBuilder.WithIndexType(IndexingType.Int16); meshBuilder.WithPrimitiveType(PrimitiveType.TriangleList); var position = meshBuilder.WithPosition<Vector3>(); var normal = meshBuilder.WithNormal<Vector3>(); // vertices for (int j = 0; j <= bendSegmentSteps; j++) { // Torus angle position Phi starts at 0 in line with Z-axis and increases to Pi/2 at X-axis double tPhi = j * torusAngle / bendSegmentSteps * Math.PI / 180.0; double xc = bendRadius * Math.Sin(tPhi); double zc = bendRadius * Math.Cos(tPhi); for (int i = 0; i < circumferenceStepsCount; i++) { // Circumference angle tTheta double tTheta = i * Math.Tau / circumferenceStepsCount; double yr = cylinderRadius * Math.Sin(tTheta); double xr = cylinderRadius * Math.Cos(tTheta) * Math.Sin(tPhi); double zr = cylinderRadius * Math.Cos(tTheta) * Math.Cos(tPhi); var tNorm = new Vector3((float)xr, (float)yr, (float)zr); var tPos = new Vector3((float)(xc + xr), (float)yr, (float)(zc + zr)); meshBuilder.AddVertex(); meshBuilder.SetElement(position, tPos); meshBuilder.SetElement(normal, tNorm); } } // Triangle indices for (int j = 0; j < bendSegmentSteps; j++) { for (int i = 0; i < circumferenceStepsCount; i++) { int i_tot = i + j * circumferenceStepsCount; int i_next = (i + 1) % circumferenceStepsCount + j * circumferenceStepsCount; // Triangle 1 meshBuilder.AddIndex(i_tot); meshBuilder.AddIndex(i_next + circumferenceStepsCount); meshBuilder.AddIndex(i_tot + circumferenceStepsCount); // Triangle 2 meshBuilder.AddIndex(i_tot); meshBuilder.AddIndex(i_next); meshBuilder.AddIndex(i_next + circumferenceStepsCount); } } } static Material CreateMaterial(Game game) { return Material.New(game.GraphicsDevice, new MaterialDescriptor { Attributes = new MaterialAttributes { MicroSurface = new MaterialGlossinessMapFeature { GlossinessMap = new ComputeFloat(0.9f) }, Diffuse = new MaterialDiffuseMapFeature { DiffuseMap = new ComputeColor(new Color4(1.0f, 0.3f, 0.5f, 1.0f)) }, DiffuseModel = new MaterialDiffuseLambertModelFeature(), Specular = new MaterialMetalnessMapFeature { MetalnessMap = new ComputeFloat(0.0f) }, SpecularModel = new MaterialSpecularMicrofacetModelFeature { Environment = new MaterialSpecularMicrofacetEnvironmentGGXPolynomial() } } }); }"
  },
  "manual/code-only/examples/particles.html": {
    "href": "manual/code-only/examples/particles.html",
    "title": "Particles | Stride Community Toolkit Manual",
    "summary": "Particles This example demonstrates how to create and configure a particle system. The sample shows: Setting up a basic 3D scene with camera, lighting, and ground Creating a particle emitter with blue colored particles Configuring particle properties including lifetime, size, and spawn rate Setting up particle initializers for random starting positions and velocities Adding gravity to affect particle movement over time Using billboard shapes for rendering particles The particles are spawned at a rate of 50 per second from a small area and shoot upward before gravity pulls them back down, creating a fountain-like effect. The particles have varying sizes between 0.1 and 0.5 units, with a blue color. This example demonstrates fundamental concepts of particle systems in Stride, showing how to create dynamic visual effects through code. Note This example requires the additional NuGet packages Stride.CommunityToolkit.Skyboxes and Stride.CommunityToolkit.Bepu. Make sure to install both before running the code. View on GitHub. using Stride.CommunityToolkit.Bepu; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Games; using Stride.CommunityToolkit.Skyboxes; using Stride.Core.Mathematics; using Stride.Engine; using Stride.Particles; using Stride.Particles.Components; using Stride.Particles.Initializers; using Stride.Particles.Materials; using Stride.Particles.Modules; using Stride.Particles.ShapeBuilders; using Stride.Particles.Spawners; using Stride.Rendering.Materials.ComputeColors; using var game = new Game(); game.Run(start: Start); void Start(Scene scene) { SetupBaseScene(); game.AddSkybox(); game.AddProfiler(); game.SetMaxFPS(60); CreateParticleEffect(); } void SetupBaseScene() { game.AddGraphicsCompositor(); game.Add3DCamera().Add3DCameraController(); game.AddDirectionalLight(); game.AddSkybox(); game.Add3DGround(); game.AddParticleRenderer(); } void CreateParticleEffect() { var emitter = new ParticleEmitter { ParticleLifetime = new Vector2(0.5f, 0.5f), SimulationSpace = EmitterSimulationSpace.World, RandomSeedMethod = EmitterRandomSeedMethod.Time, ShapeBuilder = new ShapeBuilderBillboard(), Material = new ParticleMaterialComputeColor() { ComputeColor = new ComputeColor() { Value = new Color4(0, 0, 1, 1) } }, }; emitter.Spawners.Add(new SpawnerPerSecond() { LoopCondition = SpawnerLoopCondition.Looping, Delay = new Vector2(), Duration = new Vector2(1, 1), SpawnCount = 50, }); var sizeInitializer = new InitialSizeSeed() { ScaleUniform = 0.3f, RandomSize = new Vector2(0.1f, 0.5f), }; var positionInitializer = new InitialPositionSeed() { PositionMin = new Vector3(-0.03f, -0.03f, -0.03f), PositionMax = new Vector3(0.03f, 0.03f, 0.03f), }; var velocityInitialzer = new InitialVelocitySeed() { VelocityMin = new Vector3(0, 3, 0), VelocityMax = new Vector3(3, 4, 3), }; emitter.Initializers.Add(sizeInitializer); emitter.Initializers.Add(positionInitializer); emitter.Initializers.Add(velocityInitialzer); emitter.Updaters.Add(new UpdaterGravity() { GravitationalAcceleration = new Vector3(0, -9.8f, 0) }); var particleSettings = new ParticleSystemSettings { WarmupTime = 0, }; ParticleSystemComponent particles = new() { Color = Color.White, RenderGroup = Stride.Rendering.RenderGroup.Group0, Speed = 1, }; particles.ParticleSystem.Emitters.Add(emitter); particles.ParticleSystem.Settings = particleSettings; var entity = new Entity { particles }; entity.Name = \"Particles\"; entity.Scene = game.SceneSystem.SceneInstance.RootScene; }"
  },
  "manual/code-only/examples/procedural-geometry.html": {
    "href": "manual/code-only/examples/procedural-geometry.html",
    "title": "Procedural geometry | Stride Community Toolkit Manual",
    "summary": "Procedural geometry In this example, we delve into creating procedural geometry meshes including a triangle, a plane, and a circle, and integrate them into a Stride scene. Utilizing the MeshBuilder class from the toolkit, the process of crafting and rendering these geometries is streamlined. The MeshBuilder class is employed to define the layout and data for each mesh. For instance, the GiveMeATriangle, GiveMeAPlane, and GiveMeACircle methods demonstrate how to configure vertices, indices, and other properties to form a triangle, a plane, and a circle, respectively. The Update method demonstrates a dynamic adjustment to the circle's segments count over time, showcasing a simple animation effect. For more details of MeshBuilder, refer to our MeshBuilder manual. Tip Notice the effect of back-face culling when moving the camera around the objects. With the default culling mode enabled, back faces are not rendered, optimizing performance by avoiding the drawing of surfaces that are not visible to the camera. For open or partially open 3D models, viewing from inside or even from outside through an open area may cause the model to appear incomplete. This is normal behavior since back-face culling intentionally omits surfaces facing away from the camera. Note This example requires the additional NuGet packages Stride.CommunityToolkit.Skyboxes and Stride.CommunityToolkit.Bepu. Make sure to install both before running the code. View on GitHub. using Stride.CommunityToolkit.Bepu; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Rendering.Utilities; using Stride.CommunityToolkit.Skyboxes; using Stride.Core.Mathematics; using Stride.Engine; using Stride.Games; using Stride.Graphics; using Stride.Rendering; using Stride.Rendering.Materials; using Stride.Rendering.Materials.ComputeColors; using var game = new Game(); Entity? circleEntity = null; game.Run(start: Start, update: Update); void Start(Scene rootScene) { game.SetupBase3DScene(); game.AddSkybox(); CreateMeshEntity(game.GraphicsDevice, rootScene, Vector3.Zero, CreateTriangleMesh); CreateMeshEntity(game.GraphicsDevice, rootScene, Vector3.UnitX * 2, CreatePlaneMesh); } void Update(Scene rootScene, GameTime gameTime) { var segments = (int)((Math.Cos(gameTime.Total.TotalMilliseconds / 500) + 1) / 2 * 47) + 3; circleEntity?.Remove(); circleEntity = CreateMeshEntity(game.GraphicsDevice, rootScene, Vector3.UnitX * -2, b => CreateCircleMesh(b, segments)); } void CreateTriangleMesh(MeshBuilder meshBuilder) { meshBuilder.WithIndexType(IndexingType.Int16); meshBuilder.WithPrimitiveType(PrimitiveType.TriangleList); var position = meshBuilder.WithPosition<Vector3>(); var color = meshBuilder.WithColor<Color>(); meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(0, 0, 0)); meshBuilder.SetElement(color, Color.Red); meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(1, 0, 0)); meshBuilder.SetElement(color, Color.Green); meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(.5f, 1, 0)); meshBuilder.SetElement(color, Color.Blue); meshBuilder.AddIndex(0); meshBuilder.AddIndex(2); meshBuilder.AddIndex(1); } void CreatePlaneMesh(MeshBuilder meshBuilder) { meshBuilder.WithIndexType(IndexingType.Int16); meshBuilder.WithPrimitiveType(PrimitiveType.TriangleList); var position = meshBuilder.WithPosition<Vector3>(); var color = meshBuilder.WithColor<Color>(); meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(0, 0, 0)); meshBuilder.SetElement(color, Color.Red); meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(0, 1, 0)); meshBuilder.SetElement(color, Color.Green); meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(1, 1, 0)); meshBuilder.SetElement(color, Color.Blue); meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(1, 0, 0)); meshBuilder.SetElement(color, Color.Yellow); meshBuilder.AddIndex(0); meshBuilder.AddIndex(1); meshBuilder.AddIndex(2); meshBuilder.AddIndex(0); meshBuilder.AddIndex(2); meshBuilder.AddIndex(3); } void CreateCircleMesh(MeshBuilder meshBuilder, int segments) { meshBuilder.WithIndexType(IndexingType.Int16); meshBuilder.WithPrimitiveType(PrimitiveType.TriangleList); var position = meshBuilder.WithPosition<Vector3>(); var color = meshBuilder.WithColor<Color4>(); for (var i = 0; i < segments; i++) { var x = (float)Math.Sin(Math.Tau / segments * i) / 2; var y = (float)Math.Cos(Math.Tau / segments * i) / 2; var hsl = new ColorHSV(360f / segments * i, 1, 1, 1).ToColor(); meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(x + .5f, y + .5f, 0)); meshBuilder.SetElement(color, hsl); } meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(.5f, .5f, 0)); meshBuilder.SetElement(color, Color.Black.ToColor4()); for (var i = 0; i < segments; i++) { meshBuilder.AddIndex(segments); meshBuilder.AddIndex(i); meshBuilder.AddIndex((i + 1) % segments); } } Entity CreateMeshEntity(GraphicsDevice graphicsDevice, Scene rootScene, Vector3 position, Action<MeshBuilder> build) { using var meshBuilder = new MeshBuilder(); build(meshBuilder); var entity = new Entity { Scene = rootScene, Transform = { Position = position } }; var model = new Model { new MaterialInstance { Material = CreateMaterial(graphicsDevice) }, new Mesh { Draw = meshBuilder.ToMeshDraw(graphicsDevice), MaterialIndex = 0 } }; entity.Add(new ModelComponent { Model = model }); return entity; } static Material CreateMaterial(GraphicsDevice graphicsDevice) => Material.New(graphicsDevice, new MaterialDescriptor { Attributes = new MaterialAttributes { DiffuseModel = new MaterialDiffuseLambertModelFeature(), Diffuse = new MaterialDiffuseMapFeature { DiffuseMap = new ComputeVertexStreamColor() }, } });"
  },
  "manual/code-only/examples/raycast.html": {
    "href": "manual/code-only/examples/raycast.html",
    "title": "Raycast | Stride Community Toolkit Manual",
    "summary": "Raycast This example demonstrates how to implement raycasting and physics interactions in Stride. The sample shows: Setting up a 3D scene with a sphere controlled by physics Implementing mouse-based raycasting from the camera Applying physics impulses to objects based on click location Creating interaction between user input and physics objects The example features a sphere that responds to physics. When you click on the ground, a ray is cast from the camera to determine the hit point, and the sphere is propelled in that direction with an appropriate impulse. Clicking directly on the sphere stops its movement entirely. A visual line indicator shows the direction of the applied force. This example demonstrates key concepts for interactive physics-based games, including raycasting for object selection, applying physics forces at specific points, and creating visual feedback for user interactions. Note This example requires the additional NuGet packages Stride.CommunityToolkit.Skyboxes and Stride.CommunityToolkit.Bepu. Make sure to install both before running the code. View on GitHub. using Stride.BepuPhysics; using Stride.CommunityToolkit.Bepu; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Rendering.Gizmos; using Stride.CommunityToolkit.Rendering.ProceduralModels; using Stride.CommunityToolkit.Skyboxes; using Stride.Core.Mathematics; using Stride.Engine; using Stride.Games; using Stride.Graphics; using Stride.Input; using Stride.Rendering; using Buffer = Stride.Graphics.Buffer; // Constants for the impulse strength and sphere properties const float ImpulseStrength = 0.5f; const float SphereRadius = 0.5f; // Game entities and components CameraComponent? mainCamera = null; Entity? sphereEntity = null; BodyComponent? sphereBody = null; Buffer? vertexBuffer = null; // Line vertices to visualize the impulse direction (start and end points) Vector3[] lineVertices = new Vector3[2]; // Initialize the game instance using var game = new Game(); // Run the game loop with the Start and Update methods game.Run(start: Start, update: Update); // Sets up the initial scene with a skybox, profiler, ground reference, and a sphere with physics void Start(Scene scene) { // Set up a basic 3D scene with skybox, profiler, and a ground gizmo game.SetupBase3DScene(); game.AddSkybox(); game.AddProfiler(); game.AddGroundGizmo(new(-5, 0, -5), showAxisName: true); // Create a sphere entity and position it above the ground sphereEntity = game.Create3DPrimitive(PrimitiveModelType.Sphere); sphereEntity.Transform.Position = new Vector3(0, 8, 0); // Retrieve the physics body component attached to the sphere sphereBody = sphereEntity.Get<BodyComponent>(); // Add the sphere entity to the scene, this will make it visible in the game window sphereEntity.Scene = scene; // Retrieve the active camera from the scene mainCamera = scene.GetCamera(); // Create a line entity used for visualizing the impulse direction var lineEntity = CreateLineEntity(game); // Attach the line as a child of the sphere so it moves along with it sphereEntity.AddChild(lineEntity); } // Called every frame to update game logic and process user input void Update(Scene scene, GameTime time) { if (mainCamera == null) return; // Display on-screen instructions for the user DisplayInstructions(game); // On left mouse button click, process the interaction if (game.Input.IsMouseButtonPressed(MouseButton.Left)) { ProcessMouseClick(); } } // Processes mouse click events by casting a ray and determining the appropriate action. // If the sphere is clicked, its movement is halted; otherwise, an impulse is applied. void ProcessMouseClick() { // Cast a ray from the camera into the scene based on the mouse position var hit = mainCamera.Raycast(game.Input.MousePosition, 100, out var hitInfo); if (hit) { // Ensure the sphere's physics body and entity are valid if (sphereBody is null || sphereEntity is null) return; Console.WriteLine($\"Hit entity: {hitInfo.Collidable.Entity.Name}\"); // If the sphere itself is clicked, stop its movement by zeroing its velocity if (hitInfo.Collidable.Entity == sphereEntity) { sphereBody.LinearVelocity = Vector3.Zero; sphereBody.AngularVelocity = Vector3.Zero; return; } // Update the line visualization to point from the sphere to the hit point UpdateLineVisualization(hitInfo.Point); // Calculate and apply an impulse to the sphere based on the hit point ApplyImpulseToSphere(hitInfo.Point); } else { Console.WriteLine(\"No hit\"); } } // Updates the endpoint of the line to visualize the hit position in the sphere's local space void UpdateLineVisualization(Vector3 hitPointWorld) { if (sphereEntity == null || vertexBuffer == null) return; // Convert the hit point from world space to the sphere's entity local coordinate space var localHitPoint = Vector3.Transform(hitPointWorld, Matrix.Invert(sphereEntity.Transform.WorldMatrix)); // Update the end vertex of the line's endpoint lineVertices[1] = localHitPoint.XYZ(); // Re-upload the updated vertex data to the GPU vertexBuffer.SetData(game.GraphicsContext.CommandList, lineVertices); } // Calculates and applies an impulse to the sphere to simulate a physics interaction void ApplyImpulseToSphere(Vector3 hitPointWorld) { if (sphereEntity == null || sphereBody == null) return; // Calculate the direction vector from the sphere's center to the hit point var sphereCenter = sphereEntity.Transform.WorldMatrix.TranslationVector; var direction = hitPointWorld - sphereCenter; // Normalize the direction to ensure a consistent impulse strength regardless of distance direction.Normalize(); // Determine the impulse vector var impulse = direction * ImpulseStrength; // Calculate an offset from the center so the impulse is applied at the sphere's surface, // which helps in inducing a rotational effect var offset = direction * SphereRadius; // Apply the calculated impulse to the physics body sphereBody.ApplyImpulse(impulse, offset); // Mark the body as awake to ensure the physics engine processes the change sphereBody.Awake = true; } // Creates a line entity to visualize the direction of the applied impulse Entity CreateLineEntity(Game game) { // Initialize the line vertices. // The start point is at the origin; the endpoint is set arbitrarily lineVertices[0] = Vector3.Zero; lineVertices[1] = new(-1, 1, 1); // Create a vertex buffer for the line, with start and end points vertexBuffer = Buffer.New(game.GraphicsDevice, lineVertices, BufferFlags.VertexBuffer); // Create an index buffer defining the line's two endpoints var indices = new ushort[] { 0, 1 }; var indexBuffer = Buffer.New(game.GraphicsDevice, indices, BufferFlags.IndexBuffer); // Set up the mesh draw parameters for a line list var meshDraw = new MeshDraw { PrimitiveType = PrimitiveType.LineList, VertexBuffers = [new VertexBufferBinding(vertexBuffer, new VertexDeclaration(VertexElement.Position<Vector3>()), lineVertices.Length)], IndexBuffer = new IndexBufferBinding(indexBuffer, is32Bit: false, indices.Length), DrawCount = indices.Length }; // Create the mesh var mesh = new Mesh { Draw = meshDraw }; // The model is built from the mesh and a gizmo material, an emissive material for clear visualization var lineModelComponent = new ModelComponent { Model = new Model { mesh, GizmoEmissiveColorMaterial.Create(game.GraphicsDevice, Color.DarkMagenta) } }; // Return a new entity that contains the line model component return new Entity { lineModelComponent }; } // Displays on-screen instructions to guide the user static void DisplayInstructions(Game game) { game.DebugTextSystem.Print(\"Click the ground to apply a direction impulse\", new(5, 30)); game.DebugTextSystem.Print(\"Click the sphere to stop moving\", new(5, 50)); }"
  },
  "manual/code-only/examples/renderer.html": {
    "href": "manual/code-only/examples/renderer.html",
    "title": "Renderer | Stride Community Toolkit Manual",
    "summary": "Renderer This example demonstrates two distinct approaches for implementing custom rendering in Stride, allowing developers to extend the default rendering pipeline with their own 2D visualization code: Global Scene Renderer Implementation - MyCustomSceneRenderer: Creates a custom renderer that operates on all entities in the scene Implements SceneRendererBase to hook into Stride's rendering pipeline Renders both static text (\"Hello Stride\") and dynamic per-entity information Displays entity names and positions with semi-transparent backgrounds Converts 3D world positions to 2D screen coordinates for text placement Entity-Specific Renderer Implementation - SpriteBatchRendererScript: Attaches a custom renderer to a specific entity via a StartupScript Creates a DelegateSceneRenderer to handle rendering without subclassing Displays \"Hello Stride 2\" text specifically for its parent entity Demonstrates renderer initialization and integration through the component system The example also includes physics interactions, applying an impulse to make the capsule roll after falling, showcasing how rendering can visualize dynamic object behavior. The combination of these approaches illustrates different architectural patterns for extending Stride's rendering capabilities: The scene-wide approach for global visualization needs (debug overlays, HUD elements) The entity-specific approach for object-focused rendering (labels, status indicators) Both techniques utilize SpriteBatch for efficient 2D rendering within a 3D scene context, showing how to properly initialize resources, convert between coordinate systems, and integrate with Stride's render stages. Note This example requires the additional NuGet packages Stride.CommunityToolkit.Skyboxes and Stride.CommunityToolkit.Bepu. Make sure to install both before running the code. View on GitHub. using Example09_Renderer; using Stride.BepuPhysics; using Stride.CommunityToolkit.Bepu; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Rendering.Compositing; using Stride.CommunityToolkit.Rendering.ProceduralModels; using Stride.CommunityToolkit.Skyboxes; using Stride.Core.Mathematics; using Stride.Engine; using Stride.Games; // This example demonstrates two different ways of adding custom rendering logic to a Stride game. // 1. Using a custom SceneRenderer via MyCustomSceneRenderer, which renders text for all entities. // 2. Using a StartupScript via SpriteBatchRendererScript, which draws specific text for a single entity. // Both approaches integrate into the Stride rendering pipeline, demonstrating how to extend the default rendering behaviour. BodyComponent? body = null; bool impluseApplied = false; using var game = new Game(); /// <summary> /// Entry point for the game setup. The game runs with two main customizations: /// 1. A custom scene renderer is added to display entity debug information using SpriteBatch. /// 2. A custom script is added to an entity for specific entity-related rendering (e.g., \"Hello Stride\"). /// </summary> game.Run(start: Start, update: Update); void Start(Scene scene) { // Sets up the base 3D scene, including lighting, camera, and default settings. game.SetupBase3DScene(); // Adds the built-in profiler, which provides real-time performance metrics. game.AddProfiler(); // Example 1: Adds a custom scene renderer to render text for all entities in the scene. game.AddSceneRenderer(new MyCustomSceneRenderer()); // Adds a skybox (a background environment) to the scene. game.AddSkybox(); // Creates a 3D capsule primitive and sets its position in the scene. var entity = game.Create3DPrimitive(PrimitiveModelType.Capsule); entity.Transform.Position = new Vector3(0, 8, 0); // Let's rotate the capsule a tiny bit entity.Transform.Rotation = Quaternion.RotationZ(MathUtil.DegreesToRadians(2)); // Get the body component body = entity.Get<BodyComponent>(); // Example 2: Adds a custom startup script to the entity, which draws specific text // (e.g., \"Hello Stride 2\") using SpriteBatch when the game is running. entity.Add(new SpriteBatchRendererScript()); // Assigns the entity to the root scene to ensure it is rendered and updated. entity.Scene = scene; } void Update(Scene scene, GameTime time) { if (body is null) return; if (impluseApplied) return; // Let's add some momentum so it rolls after it falls, the rigid body is already added by Create3DPrimitive body.ApplyImpulse(new(0, 0, 1f), new()); body.ApplyAngularImpulse(new(2, 0, 0)); impluseApplied = true; }"
  },
  "manual/code-only/examples/root-renderer-shader.html": {
    "href": "manual/code-only/examples/root-renderer-shader.html",
    "title": "Root Renderer Shader | Stride Community Toolkit Manual",
    "summary": "Root Renderer Shader This example demonstrates how to implement a custom render feature in Stride using a root renderer shader. The project showcases: Creating a custom component that integrates with Stride's rendering system Implementing a root render feature that adds custom visual effects to the scene Setting up shader parameters through component properties Integrating custom rendering into Stride's graphics pipeline The example creates a visual ribbon background effect that's fully configurable through properties like intensity, frequency, amplitude, speed, and width factor. It illustrates a complete workflow for adding custom shader-based visual effects to a Stride application. Key components in this implementation include: RibbonBackgroundComponent - An entity component that stores and manages the visual properties of the ribbon effect RibbonRenderBackground - A render object that holds the parameters needed by the shader RibbonBackgroundRenderFeature - A render feature that integrates with Stride's rendering pipeline The project demonstrates important render pipeline concepts including: Registering a custom render feature with the graphics compositor Specifying render stages and groups for proper rendering order Connecting component properties to shader parameters Creating entity-bound visual effects through the component system This approach to custom rendering is particularly useful for creating background effects, post-processing, and other visual enhancements that require direct access to the rendering pipeline. Note This example requires the additional NuGet packages Stride.CommunityToolkit.Skyboxes and Stride.CommunityToolkit.Bepu. Make sure to install both before running the code. View on GitHub. using Example13_RootRendererShader.Renderers; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Rendering.Compositing; using Stride.Engine; using Stride.Rendering; using var game = new Game(); game.Run(start: Start); void Start(Scene scene) { game.SetupBase(); AddRenderFeature(); game.AddProfiler(); // We must use a component here as it makes sure to add the render processor to the scene. // The render prcoessor is responsible for managing render objects for the visibility group. // The visibility group is added when a valid render processor \"component\" is added to the scene. var background = new RibbonBackgroundComponent { Intensity = 0.5f, Frequency = 0.5f, Amplitude = 0.5f, Speed = 0.5f, WidthFactor = 0.5f }; // Once this gets added to the scene, the render processor will be added to the scene. var entity = new Entity { new RibbonBackgroundComponent() }; scene.Entities.Add(entity); game.Window.Position = new Stride.Core.Mathematics.Int2(50, 50); game.Window.AllowUserResizing = true; } // This method adds the render feature to the game. //This ensures that the game knows how to render the RibbonBackgroundComponent. void AddRenderFeature() { game.SceneSystem.GraphicsCompositor.TryGetRenderStage(\"Opaque\", out var opaqueRenderStage); var renderFeature = new RibbonBackgroundRenderFeature() { RenderStageSelectors = { new SimpleGroupToRenderStageSelector { EffectName = \"RibbonBackground\", RenderGroup = RenderGroupMask.All, RenderStage = opaqueRenderStage, } } }; game.AddRootRenderFeature(renderFeature); }"
  },
  "manual/code-only/examples/simple-constraint.html": {
    "href": "manual/code-only/examples/simple-constraint.html",
    "title": "Simple constraint | Stride Community Toolkit Manual",
    "summary": "Simple constraint This example demonstrates how to create a physics-based constraint between two objects using the BepuPhysics integration in Stride. The code illustrates: Setting up a basic 3D scene with skybox, profiler, and ground reference grid Creating a capsule and two spheres as visual objects in the scene Implementing a distance servo constraint that maintains a fixed distance between two spheres Using the DistanceServoConstraintComponent to define the relationship between physics bodies The distance servo constraint connects the two spheres and enforces a target distance of 3.0 units between them, causing them to pull toward or push away from each other to maintain this distance. This example showcases how constraints can be used to create physically-driven connections between objects, which is useful for creating joints, hinges, ropes, and other interconnected mechanical systems. Note This example requires the additional NuGet packages Stride.CommunityToolkit.Skyboxes and Stride.CommunityToolkit.Bepu. Make sure to install both before running the code. View on GitHub. using Stride.BepuPhysics; using Stride.BepuPhysics.Constraints; using Stride.CommunityToolkit.Bepu; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Rendering.ProceduralModels; using Stride.CommunityToolkit.Skyboxes; using Stride.Core.Mathematics; using Stride.Engine; // Initialize the game instance using var game = new Game(); // Run the game loop with the Start method game.Run(start: Start); void Start(Scene scene) { // Set up a basic 3D scene with skybox, profiler, and a ground gizmo game.SetupBase3DScene(); game.AddSkybox(); game.AddProfiler(); game.AddGroundGizmo(new(-5, 0, -5), showAxisName: true); // Create an additional capsule for visual reference var entity = game.Create3DPrimitive(PrimitiveModelType.Capsule); entity.Transform.Position = new Vector3(0, 3, 0); entity.Scene = scene; // Create a sphere with a golden material var sphere = game.Create3DPrimitive(PrimitiveModelType.Sphere, new() { Material = game.CreateMaterial(Color.Gold) }); sphere.Transform.Position = new Vector3(0.1f, 5, -0.3f); // Create a second sphere to demonstrate a connected constraint var connectedSphere = game.Create3DPrimitive(PrimitiveModelType.Sphere); connectedSphere.Transform.Position = new Vector3(-2f, 1, -2f); // Set up a distance servo constraint between the sphere and connected sphere // The distance servo constraint will try to keep the distance between the two spheres the same // Observe the speheres pulling towards each other and the distance between them being maintained // Zoom out to see the effect better var distanceServo = new DistanceServoConstraintComponent { A = sphere.Get<BodyComponent>(), B = connectedSphere.Get<BodyComponent>(), TargetDistance = 3.0f, }; sphere.Add(distanceServo); // Add both entities to the scene sphere.Scene = scene; connectedSphere.Scene = scene; }"
  },
  "manual/code-only/examples/stride-ui-capsule-with-rigid-body.html": {
    "href": "manual/code-only/examples/stride-ui-capsule-with-rigid-body.html",
    "title": "Capsule with rigid body and window | Stride Community Toolkit Manual",
    "summary": "Capsule with rigid body and window In this example, we demonstrate how to set up a 3D scene that includes a capsule with a rigid body as well as a simple window displaying a text message. This example is organized into multiple methods for better readability and maintainability. It is structured as follows: Start(Scene scene) This is the entry point for setting up the scene. It calls other methods to set up the 3D scene, add the capsule, load the font, and add the window. AddCapsule(Scene scene) This method creates a 3D capsule and adds it to the scene at a specific position. LoadFont() This method loads the font that will be used for the UI window. AddWindow(Scene scene) This method calls CreateUIEntity() to create an entity with a UI component, and then adds this entity to the root scene. CreateUIEntity() This method creates an entity that has a UI component. The UI component includes a canvas as its root element. CreateCanvas() This method creates a canvas element that will be the root of the UI component. CreateTextBlock(SpriteFont? _font) This method creates a TextBlock element that displays the message \"Hello, World\". It uses the loaded font and sets other properties like color and size. This modular approach makes the code easier to understand and maintain. Each method has a clear responsibility. Note This example requires the additional NuGet packages Stride.CommunityToolkit.Skyboxes and Stride.CommunityToolkit.Bepu. Make sure to install both before running the code. View on GitHub. using Stride.CommunityToolkit.Bepu; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Rendering.ProceduralModels; using Stride.CommunityToolkit.Skyboxes; using Stride.Core.Mathematics; using Stride.Engine; using Stride.Graphics; using Stride.Rendering; using Stride.UI; using Stride.UI.Controls; using Stride.UI.Panels; SpriteFont? _font; using var game = new Game(); game.Run(start: Start); void Start(Scene scene) { game.SetupBase3DScene(); game.AddSkybox(); AddCapsule(scene); LoadFont(); AddWindow(scene); } void AddCapsule(Scene scene) { var entity = game.Create3DPrimitive(PrimitiveModelType.Capsule); entity.Transform.Position = new Vector3(0, 8, 0); entity.Scene = scene; } void LoadFont() { _font = game.Content.Load<SpriteFont>(\"StrideDefaultFont\"); } void AddWindow(Scene scene) { var uiEntity = CreateUIEntity(); uiEntity.Scene = scene; } Entity CreateUIEntity() { return new Entity { new UIComponent { Page = new UIPage { RootElement = CreateCanvas() }, RenderGroup = RenderGroup.Group31 } }; } Canvas CreateCanvas() { var canvas = new Canvas { Width = 300, Height = 100, BackgroundColor = new Color(248, 177, 149, 100) }; canvas.Children.Add(CreateTextBlock(_font)); return canvas; } TextBlock CreateTextBlock(SpriteFont? _font) { if (_font is null) { Console.WriteLine(\"Font is null\"); } return new TextBlock { Text = \"Hello, World\", TextColor = Color.White, TextSize = 20, Margin = new Thickness(3, 3, 3, 0), Font = _font }; }"
  },
  "manual/code-only/examples/stride-ui-cube-clicker.html": {
    "href": "manual/code-only/examples/stride-ui-cube-clicker.html",
    "title": "Cube clicker | Stride Community Toolkit Manual",
    "summary": "Cube clicker Cube Clicker is an instructive example using the Stride game engine, showcasing several key features: Game Data Management: Utilizes the NexVYaml serializer for saving and loading game data, demonstrating effective data persistence techniques. Stride UI Demonstration: Illustrates the use of Stride's UI elements, specifically Grid, TextBlock, and Button, to create interactive and user-friendly interfaces. Scripting in Stride: Employs both SyncScript and AsyncScript, providing examples of how to implement synchronous and asynchronous logic in a Stride game. Separation of Concerns: The game's architecture demonstrates good practice in separating different areas of logic, making the code more maintainable and scalable. When the game starts, it automatically loads the click data and cube positions from the previous session. The player interacts with dynamically generated cubes, with the game tracking left and right mouse clicks. View on GitHub. To explore the entire project, follow the link above. Below is the Program.cs file from the project for a quick overview. using Example07_CubeClicker.Managers; using Example07_CubeClicker.Scripts; using NexVYaml; using Stride.CommunityToolkit.Bullet; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Skyboxes; using Stride.Engine; using Stride.Graphics; // This example demonstrates how to load and save game data. When the game starts, // it automatically loads the click data and cube positions from the previous session. // The player interacts with dynamically generated cubes, with the game tracking left // and right mouse clicks. // In case of a corrupted Yaml file, navigate to the \\bin\\Debug\\net8.0\\data\\ // directory and delete the file manually. using var game = new Game(); // Register all DataContracted Types NexYamlSerializerRegistry.Init(); game.Run(start: Start); void Start(Scene rootScene) { game.SetupBase3DScene(); game.AddSkybox(); game.AddGroundGizmo(showAxisName: true); CreateAndRegisterGameManagerUI(rootScene); } void CreateAndRegisterGameManagerUI(Scene rootScene) { var font = game.Content.Load<SpriteFont>(\"StrideDefaultFont\"); var gameManager = new GameManager(font); game.Services.AddService(gameManager); var uiEntity = gameManager.CreateUI(); uiEntity.Add(new ClickHandlerComponent()); uiEntity.Scene = rootScene; }"
  },
  "manual/code-only/examples/stride-ui-draggable-window.html": {
    "href": "manual/code-only/examples/stride-ui-draggable-window.html",
    "title": "Stride UI - Draggable Window | Stride Community Toolkit Manual",
    "summary": "Stride UI - Draggable Window This example demonstrates how to create interactive, draggable UI windows in Stride using custom UI components. The project showcases: Creating a draggable window system using Stride's built-in UI framework Implementing window management with proper z-index handling (windows coming to front when clicked) Building a UI manager that handles window creation and management Dynamically spawning 3D objects from UI interactions Tracking object counts and updating UI elements accordingly The code sets up a basic 3D scene with a draggable UI window containing buttons to: Create additional draggable windows Generate random 3D sphere objects that fall with physics Each window includes a title bar, divider line, close button, and maintains proper stacking order when interacted with. The main window also displays a counter showing the total number of 3D shapes in the scene. This example implements the functionality through several key classes: UIManager - Creates and manages UI windows, handles text updates DragAndDropContainer - Root canvas that tracks and manages draggable elements DragAndDropCanvas - Individual window implementation with title and interactive features PrimitiveGenerator - Creates and tracks 3D objects generated through UI actions The project also includes cleanup functionality to remove objects that fall below a threshold, updating the counter accordingly. This demonstrates a complete UI workflow from user interaction to scene manipulation. Note This example requires the additional NuGet packages Stride.CommunityToolkit.Skyboxes and Stride.CommunityToolkit.Bepu. Make sure to install both before running the code. View on GitHub. using Example10_StrideUI_DragAndDrop; using Stride.CommunityToolkit.Bepu; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Rendering.ProceduralModels; using Stride.CommunityToolkit.Skyboxes; using Stride.Core.Mathematics; using Stride.Engine; using Stride.Games; using Stride.Graphics; using Stride.Rendering; UIManager? _uiManager = null; PrimitiveGenerator? _shapeGenerator = null; const int ShapeCount = 100; const int RemovalThresholdY = -30; const string TotalCubes = \"Total Shapes: \"; using var game = new Game(); game.Run(start: Start, update: Update); void Start(Scene scene) { // Setup the base 3D scene with default lighting, camera, etc. game.SetupBase3DScene(); // Add debugging aids: entity names, positions game.AddEntityDebugSceneRenderer(new() { ShowFontBackground = false }); game.AddSkybox(); game.AddProfiler(); _shapeGenerator = new PrimitiveGenerator(game, scene); var font = game.Content.Load<SpriteFont>(\"StrideDefaultFont\"); // Create and display the UI components on screen CreateAndAddUI(scene, font); // Add an example 3D capsule entity to the scene for visual reference AddExampleShape(scene); MoveToAnotherProjectOrSnippetExample(scene, game); } void Update(Scene scene, GameTime time) { foreach (var entity in scene.Entities) { if (entity.Transform.Position.Y < RemovalThresholdY) { entity.Scene = null; _shapeGenerator?.SubtractTotalCubes(1); _uiManager?.UpdateTextBlock($\"{TotalCubes} {_shapeGenerator?.TotalShapes ?? 0}\"); } } } void CreateAndAddUI(Scene scene, SpriteFont font) { _uiManager = new UIManager(font, GenerateRandomSpheres); _uiManager.Entity.Scene = scene; } void AddExampleShape(Scene scene) { var entity = game.Create3DPrimitive(PrimitiveModelType.Capsule); entity.Transform.Position = new Vector3(0, 8, 0); entity.Scene = scene; } void GenerateRandomSpheres() { var totalShapes = _shapeGenerator?.Generate(ShapeCount, PrimitiveModelType.Sphere); _uiManager?.UpdateTextBlock($\"{TotalCubes} {totalShapes ?? 0}\"); } static void MoveToAnotherProjectOrSnippetExample(Scene scene, Game game) { var vertices = new VertexPositionTexture[4]; vertices[0].Position = new Vector3(0f, 0f, 1f); vertices[1].Position = new Vector3(0f, 1f, 0f); vertices[2].Position = new Vector3(0f, 1f, 1f); //vertices[3].Position = new Vector3(1f, 0f, 1f); var vertexBuffer = Stride.Graphics.Buffer.Vertex.New(game.GraphicsDevice, vertices, GraphicsResourceUsage.Dynamic); int[] indices = { 0, 2, 1 }; var indexBuffer = Stride.Graphics.Buffer.Index.New(game.GraphicsDevice, indices); var customMesh = new Mesh { Draw = new MeshDraw { /* Vertex buffer and index buffer setup */ PrimitiveType = PrimitiveType.TriangleList, DrawCount = indices.Length, IndexBuffer = new IndexBufferBinding(indexBuffer, true, indices.Length), VertexBuffers = new[] { new VertexBufferBinding(vertexBuffer, VertexPositionTexture.Layout, vertexBuffer.ElementCount) }, } }; var entity = new Entity(); var model = new Model(); model.Meshes.Add(customMesh); model.Materials.Add(game.CreateMaterial()); entity.Components.Add(new ModelComponent(model)); entity.Scene = scene; }"
  },
  "manual/code-only/extensions.html": {
    "href": "manual/code-only/extensions.html",
    "title": "Extensions | Stride Community Toolkit Manual",
    "summary": "Extensions Each extension has been crafted to address common game development scenarios. They encapsulate and abstract away some of the complexities involved in setting up these scenarios, thus allowing you to focus more on the game logic and less on the setup and configuration. To modify an extension, you can examine its code to understand how it works. Once you grasp the underlying logic, you can modify it or even create a new extension that better suits your needs. Remember, these extensions are just tools to help you get started; don't be afraid to modify them or build your own to align with your unique requirements. In conclusion, whether you are a beginner just starting out with Stride or an experienced developer looking for a quicker way to get your game up and running, these extensions are a valuable resource. They are designed to be a starting point that can be used as is, or can be customised and built upon to create the perfect solution for your game development needs. Remember, the key to mastering Stride, and game development in general, is practice and exploration. So, go ahead, play around with these extensions, and start creating! GameExtensions.cs Some extensions return Entity so it can be further modified. Run() - Initialising the game, use start and update params SetupBase() - Adds graphics compositor, camera and directional light SetupBase2DScene() - Same as SetupBase() plus skybox, ground, mouse look camera SetupBase3DScene() - Same as SetupBase() plus skybox, ground, mouse look camera AddGraphicsCompositor() - Adds a default GraphicsCompositor Add2DCamera() - Adds 2D camera Add3DCamera() - Adds 3D camera AddDirectionalLight() - Adds directional light AddSkybox() - Adds skybox Add2DGround() - Adds 2D ground Add3DGround() - Adds 3D ground AddInfinite3DGround() - Adds infinite 3D ground GraphicsCompositorExtensions.cs AddCleanUIStage() - Adds a UI render stage and white/clean text effect to the given GraphicsCompositor AddGizmo() - Adds Gizmo to the ground ScriptComponentExtensions.cs | DeltaTime() || Easier way of getting DeltaTime as a float in seconds | | GetCamera() || Gets the first camera with the name \"Main\", currently doesnt work at the start of a game due to being null in the GraphicsCompositor | | GetCamera(string name) || Gets the first camera with the name provided, currently doesnt work at the start of a game due to being null in the GraphicsCompositor | | GetFirstCamera() || Gets the first camera in the GraphicsCompositor. currently doesnt work at the start of a game due to being null in the GraphicsCompositor | AnimationComponentExtensions.cs | PlayAnimation() || Plays an animation if not already playing | ModelComponentExtensions.cs | GetMeshHeight() || Gets the Mesh height as a float | | GetMeshHWL() || Gets the Mesh height, width and length as a Vector3 |"
  },
  "manual/code-only/index.html": {
    "href": "manual/code-only/index.html",
    "title": "Code-Only | Stride Community Toolkit Manual",
    "summary": "Code-Only Why Opt for Code-Only Over Stride's Game Studio? There are numerous reasons to consider using the code-only approach, especially if: You prefer not to install additional software on your computer (Stride installation not required). You want to learn C# or game development in a straightforward, code-first manner. You're aiming for a quick start in game development or C# programming. You find joy and educational value in hands-on C# coding experiences, whether you're new or experienced. You wish to see tangible, visual 2D/3D outputs instead of just console-based results. You want to gradually ease into game programming, mastering the basics before diving into the complexities of a game editor. You find typical coding environments and tools too overwhelming to navigate. You'd like to prototype game elements quickly and easily. You want an efficient way to grasp fundamental game development concepts and practices. You're interested in evaluating the performance and features of the Stride Game Engine without the overhead of a full-fledged editor. Have more reasons to add? Feel free to suggest them through our GitHub Issues. Extensions and Helpers Our code-only specific extensions and helpers provide a simplified pathway for game creation, specifically designed for code-only projects within the Stride Game Engine. While they are not essential for running a game, they serve as time-saving tools to help users, particularly those new to Stride, get started quickly. These extensions rely heavily on default settings to ease your entry into the engine. However, they are flexible; if the default settings don't fully meet your needs, you can explore the extension's implementation and create a custom version tailored to your preferences. Please note that while these extensions have been created with a beginner-friendly, opinionated approach to help users get up and running quickly, experienced users can also benefit from them. They can serve as a foundation upon which you can build, modify, and extend to create more complex and customized solutions. Functionality Some functionality you might expect and which works in the Stride Game Studio may not yet be available. Please add your vote or submit a request in the GitHub Issues. References Stride Issue - Code-Only Approach Stride Discussions - Code-Only / Minimal Stride API Project"
  },
  "manual/entity-extensions/index.html": {
    "href": "manual/entity-extensions/index.html",
    "title": "EntityExtensions.cs | Stride Community Toolkit Manual",
    "summary": "EntityExtensions.cs EntityExtensions.cs is a collection of extension methods enhancing the functionality of entities within the Stride game engine. These methods provide additional capabilities to entities, making it easier to work with them in various scenarios. From adding gizmos and interactive scripts to retrieving components and managing entity positions. Here is an overview of the available extension methods: Add2DCameraController() - Adds an interactive 2D camera script to the specified entity, enabling camera movement and rotation Add3DCameraController() - Adds an interactive 3D camera script to the specified entity, enabling camera movement and rotation AddGizmo() - Adds a TranslationGizmo to the specified entity with optional custom colors GetComponent<T>() - Retrieves the first component of the specified type from the entity GetComponents<T>() - Retrieves all components of the specified type from the entity Remove() - Removes the entity from its current scene by setting its Scene property to null TryGetComponent<T>() - Tries to retrieve a component of type T from the given entity WorldPosition() - An easier way to get world position These extensions are designed to streamline common tasks associated with entities in Stride, enhancing the overall efficiency and flexibility of game development workflows."
  },
  "manual/game-extensions/index.html": {
    "href": "manual/game-extensions/index.html",
    "title": "GameExtensions.cs | Stride Community Toolkit Manual",
    "summary": "GameExtensions.cs GameExtensions.cs provides a suite of extension methods for the Game class, enhancing its capabilities and offering convenient functionalities to game developers. These methods streamline common tasks in game development, ranging from performance monitoring to material creation and entity manipulation. Here's a brief overview of the functionalities provided by these extension methods: AddAllDirectionLighting() - Adds directional lighting from multiple angles to the current scene AddProfiler() - Adds a profiler to the game, which can be toggled on/off with Left Shift + Left Ctrl + P CreateMaterial() - Creates a basic material with optional color, specular reflection, and micro-surface smoothness values DeltaTime() - Gets the time elapsed since the last game update in seconds as a single-precision floating-point number DeltaTimeAccurate() - Gets the time elapsed since the last game update in seconds as a double-precision floating-point FPS() - Retrieves the current frames per second (FPS) rate of the running game SetFocusLostFPS() - Sets the maximum frames per second (FPS) rate for the game when not in focus SetMaxFPS() - Sets the maximum frames per second (FPS) rate for the game AddEntityNames() - Debug. To see entity properties in the game AddPhysicsDebugger() - Debug. To see colliders. Tracked here Issue #9"
  },
  "manual/getting-started.html": {
    "href": "manual/getting-started.html",
    "title": "\uD83D\uDE80 Get Started | Stride Community Toolkit Manual",
    "summary": "\uD83D\uDE80 Get Started This article guides you through the initial steps to utilize the packages within the Stride Community Toolkit project. \uD83D\uDEE0️ Prerequisites Ensure the following are installed to build/run the project. If you're on Stride 4.2+ already, these should be pre-installed. Microsoft Visual C++ 2015-2022 Redistributable vcredist_x64.exe (25MB) Note: You might be asked to restart your PC after the installation. .NET 8 SDK x64: Download (200MB) Verify installation with: dotnet --info IDE of your choice Visual Studio 2022 Visual Studio 2022 Community (Free) Visual Studio Code (Free, 95MB) Install the C# Dev Kit extension Restart Visual Studio Code to ensure dotnet command functions properly Rider (Free for non-commercial use) \uD83D\uDCE6 Adding the NuGet package The toolkit is available through several packages named Stride.CommunityToolkit and Stride.CommunityToolkit.*. The main package includes all functionalities of the toolkit. You can add this package to your project using your preferred IDE or via the command line. It is designed to be compatible with both regular Stride game projects and code-only game projects. To add the NuGet package using the command line, execute the following command: dotnet add package Stride.CommunityToolkit --prerelease Note When using Stride.CommunityToolkit in a code-only project, you will need to manually add certain dependencies to your project file. However, if you are using the Stride.CommunityToolkit.Windows package, it automatically handles these dependencies for you. Additional toolkit packages Stride.CommunityToolkit The core library, providing general-purpose extensions for both regular Stride projects and code-only approaches. Stride.CommunityToolkit.Bepu Adds support for BEPU Physics, a pure C# 3D real time physics simulation library. Stride.CommunityToolkit.Bullet Adds support for Bullet Physics. Note that we no longer plan to support or expand its features as our focus shifts to Bepu Physics. Stride.CommunityToolkit.DebugShapes Provides easy-to-use Debug shapes to be able to visualize and debug your Stride scenes Stride.CommunityToolkit.ImGui Includes extensions for Dear ImGui, a fast, simple-to-use graphical user interface (GUI) library, accessed via the C# wrapper Hexa.NET.ImGui. Ideal for creating debugging tools, editor windows, and in-game UI elements. Stride.CommunityToolkit.Skyboxes Enhances code-only projects by adding skybox functionality. Stride.CommunityToolkit.Windows This library contains Windows-specific dependencies required for code-only approach (RuntimeIdentifier and package reference Stride.Core.Assets.CompilerApp). Explore the extensions available in the left navigation or dive into the code-only section for simple examples."
  },
  "manual/index.html": {
    "href": "manual/index.html",
    "title": "Stride Community Toolkit Manual | Stride Community Toolkit Manual",
    "summary": "Stride Community Toolkit Manual Warning The toolkit is currently in development. Documentation is incomplete and may contain errors. We published it early for your convenience, ahead of the toolkit's completion. Welcome to the Stride Community Toolkit Manual. This comprehensive guide is designed to help you make the most of the toolkit for Stride, an open-source C# game engine. Whether you are new to Stride or an experienced developer, these pages offer valuable insights, tips, and detailed instructions to enhance your game development experience. Table of Contents Getting Started: A guide for newcomers on how to set up and start using the toolkit. Code-Only Approach: Learn how to create and manage Stride projects using only C# code. Create Project: A step-by-step guide on creating a new Stride project using C# console application. C# Basic Examples Capsule with rigid body: Shows how to create a 3D capsule entity and position it in a scene. Give me a cube: Presents a variation of the above example by positioning a 3D cube in a scene. Mesh line: Shows how to create a mesh line. Stride UI - Capsule with rigid body and Window: Shows how to create a 3D capsule entity, position it in a scene, and create a simple window displaying a text message. Stride UI - Grid - Save and load game state: Shows how to create a simple game where clicking a cube increases the score and manages game state. Material: Shows how to create a material and apply it to a 3D entity. Procedural geometry: Shows how to create procedural geometry meshes—such as a triangle, plane, and circle—and add them to a scene. Cylinder mesh: Shows how to create a cylinder mesh. Partial torus mesh: Shows how to create a partial torus mesh. Particles: Shows how to create a particle system. Raycast: Shows how to implement raycasting and physics interactions. Collision Group: Shows how to create a scene with two players and an enemy entity and set up collision groups. Collision Layer: Shows how to create a scene with two players and an enemy entity and set up collision layers. C# Advanced Examples Simple Constraint: Shows how to create a simple constraint between two entities. Various Constraints: Shows how to create various constraints between entities, including distance limit, distance servo, ball socket, and point-on-line servo. Myra UI - Draggable Window, GetService(): Illustrates using Myra UI to create a draggable window, display a health bar, and access registered services. Stride UI - Draggable Window: Illustrates using Stride UI to create a draggable window. Image Processing: Shows how to apply image processing effects to a texture. Root Renderer Shader: Shows how to create a custom shader for the root renderer. Other Examples Debug Shapes: This example sets up a basic 3D scene and adds debugging visuals. Renderer: Demonstrates two distinct approaches for implementing custom rendering in Stride. F# Basic Examples Capsule with rigid body: Demonstrates how to create a 3D capsule entity and position it in a scene. Partial torus mesh: Shows how to create a partial torus mesh. VB Basic Examples Capsule with Rigid Body (VB) Extensions Extensions Animation Extensions Camera Extensions: Powerful and convenient ways to interact with the camera. Entity Extensions: Enhancements and utilities for working with entities. Game Extensions: Extensions ranging from performance monitoring to material creation and entity manipulation. Model Extensions Script Extensions: Additional features and tools for game development. Script System Extensions: Utilities for writing async methods. Rendering: A guide on rendering techniques. MeshBuilder: A utility class allowing dynamic creation of meshes at runtime. TextureCanvas: A utility class allowing dynamic creation of textures at runtime. Troubleshooting: Solutions and tips for common issues encountered while using the toolkit. Explore these sections to discover the full potential of the Stride Community Toolkit and enhance your game development skills."
  },
  "manual/model-extensions/index.html": {
    "href": "manual/model-extensions/index.html",
    "title": "ModelComponentExtensions.cs | Stride Community Toolkit Manual",
    "summary": "ModelComponentExtensions.cs Below is a list of available extension methods: GetMeshHWL() - Calculates the height, width, and length of the model represented by the ModelComponent GetMeshHeight() - Calculates the height of the model represented by the ModelComponent. GetMeshVerticesAndIndices() - Retrieves the vertices and indices from the ModelComponent's mesh data"
  },
  "manual/physics-extensions/index.html": {
    "href": "manual/physics-extensions/index.html",
    "title": "| Stride Community Toolkit Manual",
    "summary": "Physics extensions provide.. Bepu Extensions Add3DGround() Create2DPrimitive() - Creates a primitive 2D model entity of the specified type with optional customizations Create3DPrimitive() - Creates a primitive 3D model entity of the specified type with optional customizations"
  },
  "manual/rendering/debug-shapes.html": {
    "href": "manual/rendering/debug-shapes.html",
    "title": "Debug Shapes | Stride Community Toolkit Manual",
    "summary": "Debug Shapes Available Shapes Sphere DrawSphere position - where the Sphere is located radius - the radius of the Sphere color - the color of the Sphere *optional duration - how long the Sphere will be visible *optional depthTest - if the Sphere should be visible through other objects *optional solid - if the Sphere should be solid or wireframe *optional Cube DrawCube position - where the Box is located size - the size of the Box rotation - the rotation of the Box *optional color - the color of the Sphere *optional duration - how long the Sphere will be visible *optional depthTest - if the Sphere should be visible through other objects *optional solid - if the Sphere should be solid or wireframe *optional Line DrawLine start - the start position of the Line end - the end position of the Line color - the color of the line *optional duration - how long the line will be visible *optional depthTest - if the line should be visible through other objects *optional Arrow DrawArrow start - the start position of the Arrow end - the end position of the Arrow coneHeight - the height of the Arrow cone *optional coneRadius - the radius of the Arrow cone *optional color - the color of the arrow *optional duration - how long the arrow will be visible *optional depthTest - if the arrow should be visible through other objects *optional solid - if the arrow cone should be solid or wireframe *optional Half Sphere DrawHalfSphere position - where the Half Sphere is located radius - the radius of the Half Sphere rotation - the rotation of the Half Sphere *optional color - the color of the Half Sphere *optional duration - how long the Half Sphere will be visible *optional depthTest - if the Half Sphere should be visible through other objects *optional solid - if the Half Sphere should be solid or wireframe *optional Cylinder DrawCylinder position - where the Cylinder is located radius - the radius of the Cylinder height - the height of the Cylinder rotation - the rotation of the Cylinder *optional color - the color of the Cylinder *optional duration - how long the Cylinder will be visible *optional depthTest - if the Cylinder should be visible through other objects *optional solid - if the Cylinder should be solid or wireframe *optional Cone DrawCone position - where the Cone is located radius - the radius of the Cone height - the height of the Cone rotation - the rotation of the Cone *optional color - the color of the Cone *optional duration - how long the Cone will be visible *optional depthTest - if the Cone should be visible through other objects *optional solid - if the Cone should be solid or wireframe *optional Capsule DrawCapsule position - where the Capsule is located radius - the radius of the Capsule height - the height of the Capsule rotation - the rotation of the Capsule *optional color - the color of the Capsule *optional duration - how long the Capsule will be visible *optional depthTest - if the Capsule should be visible through other objects *optional solid - if the Capsule should be solid or wireframe *optional Quad DrawQuad position - where the Quad is located size - the size of the Quad rotation - the rotation of the Quad *optional color - the color of the Quad *optional duration - how long the Quad will be visible *optional depthTest - if the Quad should be visible through other objects *optional solid - if the Quad should be solid or wireframe *optional Circle DrawCircle position - where the Circle is located radius - the radius of the Circle rotation - the rotation of the Circle *optional color - the color of the Circle *optional duration - how long the Circle will be visible *optional depthTest - if the Circle should be visible through other objects *optional solid - if the Circle should be solid or wireframe *optional Boundsing Box DrawBounds start - the start position of the Bounds end - the end position of the Bounds rotation - the rotation of the Bounds *optional color - the color of the bounds *optional duration - how long the bounds will be visible *optional depthTest - if the bounds should be visible through other objects *optional solid - if the bounds should be solid or wireframe *optional"
  },
  "manual/rendering/mesh-builder.html": {
    "href": "manual/rendering/mesh-builder.html",
    "title": "MeshBuilder | Stride Community Toolkit Manual",
    "summary": "MeshBuilder Introduction The MeshBuilder is a utility class allowing dynamic creation of meshes at runtime. Acting as a wrapper around the Mesh class, it provides a simpler API for defining the mesh layout and data. Once there was a triangle Like in all rendering examples let's start with a simple triangle. VertexElement A vertex element is a value assigned to a specific vertex. In Stride we can use a lot of different types to define our data some of them are Vector3, Vector4, Color, Int, Float, Half and more. We need to tell Stride how we want layout this data so our shader can read our various values. This is where vertex elements come in. They define a semanticName, semanticIndex, offset and a size. By default Stride allows you to define structs for your data or to use custom buffers for your data. For most use-cases this is probably fine and the easier approach compared to a mesh builder. However if you need to define your data dynamically or want a generalized method here we go. MeshBuilder The MeshBuilder abstracts away a lot of complexity behind custom buffers, type erasure, memory allocation and instead provides you with a simpler builder API to define your mesh dynamically. It uses the same concepts as Stride so you still have to define your layout manually but the process is easier and you don't need to worry about the memory layout yourself. To use a MeshBuilder just create a new instance. using var meshBuilder = new MeshBuilder() Note Notice the using at the front. This part is crucial as you should always dispose of your mesh builder when it's no longer needed. The builder utilizes pooling behind the scenes, and failing to dispose of it prevents the return of internal buffers, which can lead to significant performance degradation. Layout As we discussed earlier we need to tell the MeshBuilder which data types and fields we want to use. For this we use the various With... methods. Primitive Type First we need to select a primitive type in our example we create a bunch of triangles so we use this code: meshBuilder.WithPrimitiveType(PrimitiveType.TriangleList); Indexing The mesh builder supports three types of indexing, None, Int16 or Int32. In our case we definitely don't need more than 32k indices so we can safely use the Int16 version. meshBuilder.WithIndexType(IndexingType.Int16); Elements For our example we will use a vertex with a position and a color element. var position = meshBuilder.WithPosition<Vector3>(); var color = meshBuilder.WithColor<Color>(); These methods return the element index we need when we set our actual values. We use a Vector3 as our vertex position and a Color for our vertex color. Other types would work as well but these are very common so we will use them as well. Vertices Next we define our vertices. For that we use a new method AddVertex(). This will add a new vertex to our builder and allows us to use the Get/SetElement methods. You can also declare multiple vertices before setting the actual values but this is the simplest way for now. meshBuilder.AddVertex(); After this we can set our element data. For this we use the SetElement() method. It expects an element index (which we received from WithPosition and WithColor earlier) as well as your desired value. meshBuilder.SetElement(position, new Vector3(0, 0, 0)); meshBuilder.SetElement(color, Color.Red); We repeat this for the other two triangle points as well. meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(1, 0, 0)); meshBuilder.SetElement(color, Color.Green); meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(.5f, 1, 0)); meshBuilder.SetElement(color, Color.Blue); Indices Next we need to tell the MeshBuilder how we want to connect the vertices. We configured indexing for our builder so we need to do this explicitly. For a simple example like this you could also completely skip the indexing part and use IndexingType.None instead. The winding order in Stride is counter-clockwise so we use these indices. meshBuilder.AddIndex(0); meshBuilder.AddIndex(2); meshBuilder.AddIndex(1); Mesh The only thing left is building the actual mesh. For this we use this method. It expects a graphics device as an argument. If you call this from a script this is usually available for you using the GraphicsDevice property of your script. meshBuilder.ToMeshDraw(GraphicsDevice); Display To show this MeshDraw on screen we create a ModelComponent and add our MeshDraw as new model. We also need to define a material to use our vertex colors on screen. Else the Triangle would just be white. var model = new Model { new MaterialInstance { Material = Material.New(graphicsDevice, new MaterialDescriptor { Attributes = new MaterialAttributes { DiffuseModel = new MaterialDiffuseLambertModelFeature(), Diffuse = new MaterialDiffuseMapFeature { DiffuseMap = new ComputeVertexStreamColor() }, } }) }, new Mesh { Draw = meshBuilder.ToMeshDraw(graphicsDevice), MaterialIndex = 0 } } Congrats \uD83E\uDD73 you got a triangle. Example For a more comprehensive usage of MeshBuilder, explore our Procedural Geometry example where you'll find detailed code on creating complex geometries dynamically."
  },
  "manual/rendering/texture-canvas.html": {
    "href": "manual/rendering/texture-canvas.html",
    "title": "TextureCanvas | Stride Community Toolkit Manual",
    "summary": "TextureCanvas Introduction The TextureCanvas is a utility class allowing dynamic creation of textures at runtime. Acting as a wrapper around the Texture class, it provides a simpler API for simple texture manipulation. Motivation Stride is a very versatile and powerful engine which uses textures for a lot of data processing. Sometimes it is necessary to create these textures on the fly for example for simple tasks like scaling, applying image effects or to build new textures based on existing ones (texture atlas). TextureCanvas The TextureCanvas abstracts away a lot of complexity behind custom buffers, textures, memory allocation and instead provides you with a simpler builder API to define your texture dynamically. var renderContext = RenderContext.GetShared(game.Services); using var canvas = new TextureCanvas(renderContext); Note Notice the using at the front. This part is crucial as you should always dispose of your texture canvas when it's no longer needed. The canvas utilizes multiple image buffers behind the scenes, and failing to dispose of it prevents the release of these resources, which can lead to memory leaks. Initialization Most operations start with a single texture as a source so we need to load the texture first using the traditional texture api. var directory = Path.GetDirectoryName(Assembly.GetEntryAssembly()!.Location)!; var filePath = Path.Combine(directory, \"input.png\"); using var input = File.Open(filePath, FileMode.Open); var texture = Texture.Load(game.GraphicsDevice, input); This code loads an input image from the local file system and stores it as a temporary texture Loading In case you just want to manipulate a texture directly you can also use the similar api from the TextureCanvas directly. var directory = Path.GetDirectoryName(Assembly.GetEntryAssembly()!.Location)!; var filePath = Path.Combine(directory, \"input.png\"); canvas.Load(filePath) This would load the same texture directly as a buffer for further processing. Similar methods also exist for file streams or data buffers accordingly. Storing To get the resulting image you have the option to save the image to a file, stream or array depending on your requirements. var directory = Path.GetDirectoryName(Assembly.GetEntryAssembly()!.Location)!; var filePath = Path.Combine(directory, \"input.png\"); using var output = File.Open(filePath, FileMode.Open); canvas.Store(output, ImageFileType.Png); The most common approach however would be to get the result as a texture you can use for your UI or Materials. var output = canvas.ToTexture(); Note Notice that you shouldn't use these methods every frame as it involves GPU < - > CPU transfers which can block your game. Manipulation The TextureCanvas supports various image manipulations as well as image effects. Resample The Resample method changes the current size of the texture or pixel format while preserving the current content. The content will be resized to match the new size if neccesary. canvas.Resample(size: new Size2(512, 512), pixelFormat: PixelFormat.R8G8B8A8_UNorm) BrightFilter The BrightFilter method a BrightFilter filter to the image canvas.BrightFilter(threshold: 0.2f, steepness: 1.0f) GaussianBlur The GaussianBlur method applies a GaussianBlur effect to the image canvas.GaussianBlur(radius: 4, sigmaRatio: 2.0f) CoCMapBlur The CoCMapBlur method applies a CoCMapBlur effect to the image canvas.CoCMapBlur(radius: 4) Transform The Transform method applies a ColorTransformGroup effect to the image canvas.Transform(transforms: new[] { new LuminanceToChannelTransform{ ColorChannel = ColorChannel.R } }) Combine The Combine method applies a ColorCombiner effect to the image canvas.Combine( textures: new [] { sourceTexture1, sourceTexture2, null /* = Canvas Content */ }, factors: new [] { .2f, .2f, .6f } ); Colorize The Colorize method multiplies the current canvas content by a color to create a modulated image. canvas.Colorize(colorMultiplier: new Color4(1f, 0, 0)); Recolorize The Recolorize method works the same way as colorize but only uses the red-channel as an input. The color multiplier is optional, omitting it would change the image to a gray-scale image. canvas.Recolorize(colorMultiplier: new Color4(1f, 0, 0)); Apply The Apply method applies a custom ImageEffect to the image using var effect = new GaussianBlur(); canvas.Apply(effect); Drawing Sometimes you also want to customize which parts of a source texture is applied to which part of the canvas. You can also compose multiple texture into a single one using these methods. Stretch This enum controls the stretch mode when resampling the source rect to the target rect None: The texture preserves its original size. Overflowing content is cropped. Stretch: The texture is resized to fill the destination dimensions. The aspect ratio is not preserved. Contain: The texture is resized to fit in the destination dimensions while it preserves its native aspect ratio. Cover: The texture is resized to fill the destination dimensions while it preserves its native aspect ratio. If the aspect ratio of the destination rectangle differs from the source, the source texture is clipped to fit in the destination dimensions. Anchors This enum controls the alignment mode if clipping or padding is necessary. How the anchors behave is dependant on the selected stretch mode. TopLeft: Adjust the position so the top-left corner of the source and target rect are aligned. Top: Adjust the position so the top-edge center of the source and target rect are aligned. TopRight: Adjust the position so the top-right corner of the source and target rect are aligned. Left: Adjust the position so the left-edge center of the source and target rect are aligned. Center: Adjust the position so the center of the source and target rect are aligned. Right: Adjust the position so the right-edge center of the source and target rect are aligned. BottomLeft: Adjust the position so the bottom-left corner of the source and target rect are aligned. Bottom: Adjust the position so the bottom-edge center of the source and target rect are aligned. BottomRight: Adjust the position so the bottom-right corner of the source and target rect are aligned. Draw There are many overloads to the draw method but all of them follow this basic structure. canvas.DrawTexture( texture, [SourceRect], [TargetRect], [ColorMultiplier], [Stretch], [Anchor], [SamplingPattern] ); Note Notice the options for stretch and anchors these control how the texture is converted from the source rectangle to the target one. Examples Stretch Anchor Source Rect Target Rect Result None TopLeft None Top None TopRight None Left None Center None Right None BottomLeft None Bottom None BottomRight Stretch Any Stretch Any Contain AnyLeft Contain AnyRight Contain AnyTop Contain AnyBottom Contain AnyCenter Cover AnyLeft Cover AnyRight Cover AnyTop Cover AnyBottom Cover AnyCenter View on GitHub. using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Extensions; using Stride.CommunityToolkit.Rendering.Utilities; using Stride.Core.Mathematics; using Stride.Engine; using Stride.Graphics; using Stride.Rendering.Images; using Stride.Rendering.Sprites; using Stride.UI; using Stride.UI.Controls; using Stride.UI.Panels; using System.Reflection; using var game = new Game(); game.Run(start: Start); static void Start(Game game) { game.Window.SetSize(new Int2(1000, 1080)); game.SetupBase(); var directory = Path.GetDirectoryName(Assembly.GetEntryAssembly()!.Location)!; var filePath = Path.Combine(directory, \"input.png\"); using var input = File.Open(filePath, FileMode.Open); var texture = Texture.Load(game.GraphicsDevice, input); var grid = new UniformGrid { Width = 1000, Height = 1000, Columns = 9, Rows = 9, Margin = new Thickness(8, 8, 8, 8) }; grid.Children.Add(CreateCard(texture)); for (var a = 0; a < 9; a++) { var anchor = (TextureCanvas.Anchor)a; for (var s = 0; s < 4; s++) { var stretch = (TextureCanvas.Stretch)s; using (var canvas = game.CreateTextureCanvas(new Size2(1024, 1024))) { canvas.DrawTexture(texture, new Rectangle(0, 128, 256, 256), new Rectangle(128, 256, 768, 512), null, stretch, anchor, SamplingPattern.Expanded); var card = CreateCard(canvas.ToTexture()); card.SetGridColumn(a); card.SetGridRow(s * 2 + 1); grid.Children.Add(card); } using (var canvas = game.CreateTextureCanvas(new Size2(1024, 1024))) { canvas.DrawTexture(texture, new Rectangle(0, 128, 256, 256), new Rectangle(256, 128, 512, 768), null, stretch, anchor); var card = CreateCard(canvas.ToTexture()); card.SetGridColumn(a); card.SetGridRow(s * 2 + 2); grid.Children.Add(card); } } } var entity = new Entity { Scene = game.SceneSystem.SceneInstance.RootScene }; entity.Add(new UIComponent { Page = new UIPage { RootElement = grid } }); } static Border CreateCard(Texture texture) { var card = new Border { BorderColor = new Color(25, 25, 25), BackgroundColor = new Color(120, 120, 120), BorderThickness = new Thickness(2, 2, 2, 2), Padding = new Thickness(8, 8, 8, 8), Margin = new Thickness(4, 4, 4, 4), Content = new StackPanel { Orientation = Orientation.Vertical, Children = { new ImageElement { Source = new SpriteFromTexture { Texture = texture } } } } }; return card; }"
  },
  "manual/script-extensions/index.html": {
    "href": "manual/script-extensions/index.html",
    "title": "ScriptComponentExtensions.cs | Stride Community Toolkit Manual",
    "summary": "ScriptComponentExtensions.cs DeltaTime() - Returns delta time from ScriptComponent in a shorter format GetCamera() - Gets the camera from the GraphicsCompositor with the name \"Main\" GetCamera() - Gets the camera from the GraphicsCompositor with the given name GetFirstCamera() - Gets the first camera from the GraphicsCompositor"
  },
  "manual/script-system-extensions/index.html": {
    "href": "manual/script-system-extensions/index.html",
    "title": "ScriptSystemExtensions.cs | Stride Community Toolkit Manual",
    "summary": "ScriptSystemExtensions.cs DelayWarped() - Waits for a specified amount of time while taking into account the Update Time factor Delay() - Waits for a specified amount of time without considering the Update Time factor ExecuteInWarpedTime() - Continuously executes an action every frame during a specified amount of time while taking into account the Update Time factor ExecuteInTime() - Continuously executes an action every frame during a specified amount of time without considering the Update Time factor"
  },
  "manual/troubleshooting.html": {
    "href": "manual/troubleshooting.html",
    "title": "Troubleshooting | Stride Community Toolkit Manual",
    "summary": "Troubleshooting Building Project Issues Error - Could not load native library libcore using CPU architecture x64 Missing Microsoft Visual C++ Redistributable, make sure you install prerequisites C:\\Users\\Vacla\\.nuget\\packages\\stride.core.assets.compilerapp\\4.1.0.1728\\buildTransitive\\Stride.Core.Assets.CompilerApp.targets(132,5): error MSB3073: The command \"\"C:\\Users\\Vacla\\.nuget\\packages\\stride.core.assets.compilerapp\\4.1.0.1728\\buildTransitive\\..\\tools\\net6.0-windows7.0\\Stride.Core.Assets.CompilerApp.exe\" --disable-auto- compile --project-configuration \"Debug\" --platform=Windows --project-configuration=Debug --compile-property:StrideGraphicsApi=Direct3D11 --output-path=\"C:\\Projects\\StrideDemo\\bin\\Debug\\net6.0\\data\" --build-path=\"C:\\Projects\\StrideDemo\\obj\\stride\\assetbuild\\data\" --package-file=\"C:\\Projects\\StrideDemo\\StrideDemo.csproj\" --msbuild-up todatecheck-filebase=\"C:\\Projects\\StrideDemo\\obj\\Debug\\net6.0\\stride\\assetcompiler-uptodatecheck\"\" exited with code -532462766. [C:\\Projects\\StrideDemo\\StrideDemo.csproj] Error - Unable to instantiate compiler Missing Microsoft Visual C++ Redistributable, make sure you install prerequisites EXEC : error 6.206s: [AssetsCompiler.AttributeBasedRegistry] Unable to instantiate compiler [Stride.A ssets.Physics.ColliderShapeAsset, Stride.Assets, Version=4.1.0.1898, Culture=neutral, PublicKeyToken= null]. Exception: TargetInvocationException: Exception has been thrown by the target of an invocation . [C:\\Examples\\Example01\\Example01.csproj] ---> TypeInitializationException: The type initializer for 'Stride.Assets.Physics.ColliderShapeAss etCompiler' threw an exception. ---> InvalidOperationException: Could not load native library VHACD using CPU architecture x64. at Stride.Core.NativeLibraryHelper.PreloadLibrary(String libraryName, Type owner) in C:\\BuildAge nt\\work\\b5f46e3c4829a09e\\sources\\core\\Stride.Core\\Native\\NativeLibraryHelper.cs:line 156 at Stride.Assets.Physics.ColliderShapeAssetCompiler..cctor() in C:\\BuildAgent\\work\\b5f46e3c4829a 09e\\sources\\engine\\Stride.Assets\\Physics\\ColliderShapeAssetCompiler.cs:line 30 at Stride.Assets.Physics.ColliderShapeAssetCompiler..ctor() at System.RuntimeType.CreateInstanceDefaultCtor(Boolean publicOnly, Boolean wrapExceptions) at System.RuntimeType.CreateInstanceDefaultCtor(Boolean publicOnly, Boolean wrapExceptions) at Stride.Core.Assets.Compiler.AssetCompilerRegistry.ProcessAttribute(AssetCompilerAttribute com pilerCompilerAttribute, Type type) in C:\\BuildAgent\\work\\b5f46e3c4829a09e\\sources\\assets\\Stride.Cor e.Assets\\Compiler\\AssetCompilerRegistry.cs:line 161 at Stride.Core.Assets.Compiler.AssetCompilerRegistry.RegisterCompilersFromAssembly(Assembly asse mbly) in C:\\BuildAgent\\work\\b5f46e3c4829a09e\\sources\\assets\\Stride.Core.Assets\\Compiler\\AssetCompil erRegistry.cs:line 198 System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocati on. Error - Exited with code 1. Missing Stride NuGet package dependencies. Use dotnet restore --runtime win-x64 or dotnet build --runtime win-x64 to restore the missing dependencies. This error can occur when the build is run for the first time on your computer. C:\\Users\\Vacla\\.nuget\\packages\\stride.core.assets.compilerapp\\4.2.0.2122\\buildTransitive\\Stride.Core.Assets.CompilerApp .targets(153,5): error MSB3073: The command \"C:\\Users\\Vacla\\.nuget\\packages\\stride.core.assets.compilerapp\\4.2.0.2122\\ buildTransitive\\..\\lib\\net8.0\\Stride.Core.Assets.CompilerApp.exe\" --disable-auto-compile --project-configuration \"Debu g\" --platform=Windows --project-configuration=Debug --compile-property:StrideGraphicsApi=Direct3D11 --output-path=\"D:\\P rojects\\GitHub\\Stride Projects\\Console01\\bin\\Debug\\net8.0\\data\" --build-path=\"D:\\Projects\\GitHub\\Stride Projects\\Consol e01\\obj\\stride\\assetbuild\\data\" --package-file=\"D:\\Projects\\GitHub\\Stride Projects\\Console01\\Console01.csproj\" --msbuil d-uptodatecheck-filebase=\"D:\\Projects\\GitHub\\Stride Projects\\Console01\\obj\\Debug\\net8.0\\stride\\assetcompiler-uptodatech eck\" exited with code 1. [D:\\Projects\\GitHub\\Stride Projects\\Console01\\Console01.csproj] Error - at Stride.Shaders.Compiler.TaskOrResult. If this is from code-only, make sure you added Stride.CommunityToolkit.Windows NuGet package instead of Stride.CommunityToolkit, further instructions can be found here at Stride.Shaders.Compiler.TaskOrResult`1.WaitForResult() in C:\\BuildAgent\\work\\b5f46e3c4829a09e\\sources\\engine\\Stride.Shaders\\Compiler\\TaskOrResult.cs:line 37 at Stride.Rendering.DynamicEffectInstance.ChooseEffect(GraphicsDevice graphicsDevice) in C:\\BuildAgent\\work\\b5f46e3c4829a09e\\sources\\engine\\Stride.Rendering\\Rendering\\DynamicEffectInstance.cs:line 60 at Stride.Rendering.EffectInstance.UpdateEffect(GraphicsDevice graphicsDevice) at Stride.Rendering.Images.ImageEffectShader.DrawCore(RenderDrawContext context) in C:\\BuildAgent\\work\\b5f46e3c4829a09e\\sources\\engine\\Stride.Rendering\\Rendering\\Images\\ImageEffectShader.cs:line 147 at Stride.Rendering.RendererBase.Draw(RenderDrawContext context) in C:\\BuildAgent\\work\\b5f46e3c4829a09e\\sources\\engine\\Stride.Rendering\\Rendering\\RendererBase.cs:line 51 at Stride.Rendering.ComputeEffect.LambertianPrefiltering.LambertianPrefilteringSHNoCompute.DrawCore(RenderDrawContext context) in C:\\BuildAgent\\work\\b5f46e3c4829a09e\\sources\\engine\\Stride.Rendering\\Rendering\\ComputeEffect\\LambertianPrefiltering\\LambertianPrefilteringSHNoCompute.cs:line 99 at Stride.Rendering.RendererBase.Draw(RenderDrawContext context) in C:\\BuildAgent\\work\\b5f46e3c4829a09e\\sources\\engine\\Stride.Rendering\\Rendering\\RendererBase.cs:line 51 at Stride.CommunityToolkit.Skyboxes.SkyboxGenerator.Generate(Skybox skybox, SkyboxGeneratorContext context, Texture skyboxTexture) in D:\\a\\stride-community-toolkit\\stride-community-toolkit\\src\\Stride.CommunityToolkit.Skyboxes\\SkyboxGenerator.cs:line 49 at Stride.CommunityToolkit.Skyboxes.GameExtensions.AddSkybox(Game game, String entityName) in D:\\a\\stride-community-toolkit\\stride-community-toolkit\\src\\Stride.CommunityToolkit.Skyboxes\\GameExtensions.cs:line 46 at Program.<>c__DisplayClass0_0.<<Main>$>b__0(Scene rootScene) in C:\\Users\\user-name\\RiderProjects\\Label3d\\Program.cs:line 13 at Stride.CommunityToolkit.Engine.GameExtensions.<>c__DisplayClass0_0.<<Run>g__RootScript|0>d.MoveNext() in D:\\a\\stride-community-toolkit\\stride-community-toolkit\\src\\Stride.CommunityToolkit\\Engine\\GameExtensions.cs:line 46 --- End of stack trace from previous location --- at Stride.Core.MicroThreading.MicroThread.<>c__DisplayClass52_0.<<Start>b__0>d.MoveNext() in C:\\BuildAgent\\work\\b5f46e3c4829a09e\\sources\\core\\Stride.Core.MicroThreading\\MicroThread.cs:line 176 --- End of stack trace from previous location --- at Stride.Core.MicroThreading.Scheduler.Run() in C:\\BuildAgent\\work\\b5f46e3c4829a09e\\sources\\core\\Stride.Core.MicroThreading\\Scheduler.cs:line 203 at Stride.Engine.Processors.ScriptSystem.Update(GameTime gameTime) in C:\\BuildAgent\\work\\b5f46e3c4829a09e\\sources\\engine\\Stride.Engine\\Engine\\Processors\\ScriptSystem.cs:line 106 at Stride.Games.GameSystemCollection.Update(GameTime gameTime) at Stride.Games.GameBase.Update(GameTime gameTime) at Stride.Games.GameBase.InitializeBeforeRun() at Stride.Games.GamePlatform.OnInitCallback() at Stride.Games.GameWindowSDL.Run() at Stride.Games.GamePlatform.Run(GameContext gameContext) at Stride.Games.GameBase.Run(GameContext gameContext) at Stride.CommunityToolkit.Engine.GameExtensions.Run(Game game, GameContext context, Action`1 start, Action`2 update) in D:\\a\\stride-community-toolkit\\stride-community-toolkit\\src\\Stride.CommunityToolkit\\Engine\\GameExtensions.cs:line 42 at Program.<Main>$(String[] args) in C:\\Users\\user-name\\RiderProjects\\Label3d\\Program.cs:line 101."
  },
  "manual/whats-new.html": {
    "href": "manual/whats-new.html",
    "title": "What's new in docs? | Stride Community Toolkit Manual",
    "summary": "What's new in docs? Welcome to what's new in Stride Community Toolkit docs. Use this page to quickly find the latest changes. New articles All content. Updated articles No articles were updated at the moment."
  },
  "release-notes/index.html": {
    "href": "release-notes/index.html",
    "title": "Release Notes | Stride Community Toolkit Release Notes",
    "summary": "Release Notes Welcome to the Release Notes for the Stride Community Toolkit. This section aims to provide you with an organized, high-level summary of changes, enhancements, and fixes made in each version release. If you're looking to understand what has changed from one version to the next, you're in the right place. What to Expect The Stride Community Toolkit is developed with rapid iteration in mind. It moves at a faster development pace compared to the Stride Game Engine. As a result, you should expect frequent updates that may introduce breaking changes. This fast-paced approach allows us to incorporate community feedback quickly and continue improving the toolkit."
  },
  "release-notes/release-1.0.0.0-preview.11.html": {
    "href": "release-notes/release-1.0.0.0-preview.11.html",
    "title": "What's new in Stride Community Toolkit 1.0.0.0-preview.11 | Stride Community Toolkit Release Notes",
    "summary": "What's new in Stride Community Toolkit 1.0.0.0-preview.11 This article lists the most significant changes in Stride Community Toolkit preview 1.0.0.0-preview.11. What's Changed \uD83D\uDCAA Other Changes Update 5 - Content improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/37 38 footer fix the name by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/40 chore: Stride NuGet bumped by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/41"
  },
  "release-notes/release-1.0.0.0-preview.12.html": {
    "href": "release-notes/release-1.0.0.0-preview.12.html",
    "title": "What's new in Stride Community Toolkit 1.0.0.0-preview.12 | Stride Community Toolkit Release Notes",
    "summary": "What's new in Stride Community Toolkit 1.0.0.0-preview.12 This article lists the most significant changes in Stride Community Toolkit preview 1.0.0.0-preview.12. What's Changed \uD83D\uDCAA Other Changes docs: Getting Started updated by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/42 Content improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/43 Update 6 - Docs content updates by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/44 added new Eflag value to Raycast extensions by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/45 Update 6 - Docs improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/46 Add mesh builder with examples by @dotlogix in https://github.com/stride3d/stride-community-toolkit/pull/48 Merging refactoring and docs updates by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/49 New Contributors @dotlogix made their first contribution in https://github.com/stride3d/stride-community-toolkit/pull/48 Full Changelog: https://github.com/stride3d/stride-community-toolkit/compare/v1.0.0.0-preview.11...1.0.0.0-preview.12"
  },
  "release-notes/release-1.0.0.0-preview.13.html": {
    "href": "release-notes/release-1.0.0.0-preview.13.html",
    "title": "What's new in Stride Community Toolkit 1.0.0.0-preview.13 | Stride Community Toolkit Release Notes",
    "summary": "What's new in Stride Community Toolkit 1.0.0.0-preview.13 This article lists the most significant changes in Stride Community Toolkit preview 1.0.0.0-preview.13. What's Changed \uD83D\uDCAA Other Changes Update 6 - Docs content updates by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/44 added new Eflag value to Raycast extensions by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/45 Update 6 - Docs improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/46 Add mesh builder with examples by @dotlogix in https://github.com/stride3d/stride-community-toolkit/pull/48 Merging refactoring and docs updates by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/49 New Contributors @dotlogix made their first contribution in https://github.com/stride3d/stride-community-toolkit/pull/48 Full Changelog: https://github.com/stride3d/stride-community-toolkit/compare/v1.0.0.0-preview.12...1.0.0.0-preview.13"
  },
  "release-notes/release-1.0.0.0-preview.14.html": {
    "href": "release-notes/release-1.0.0.0-preview.14.html",
    "title": "What's new in Stride Community Toolkit 1.0.0.0-preview.14 | Stride Community Toolkit Release Notes",
    "summary": "What's new in Stride Community Toolkit 1.0.0.0-preview.14 This article lists the most significant changes in Stride Community Toolkit preview 1.0.0.0-preview.14. What's Changed \uD83D\uDCAA Other Changes ProceduralGeometry: More complex example and docs by @dotlogix in https://github.com/stride3d/stride-community-toolkit/pull/50 Update 7 by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/51 Udpate 8 - Moving MeshBuilder to manual section by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/52 Update 9 - Refactoring and docs improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/53 updated based on recommendations by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/55 New example added by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/58 Example game renamed by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/59 Update to Stride 4.2 by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/63 Get mesh data by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/62 feat: GitHub Actions updated by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/64 Full Changelog: https://github.com/stride3d/stride-community-toolkit/compare/v1.0.0.0-preview.13...1.0.0.0-preview.14"
  },
  "release-notes/release-1.0.0.0-preview.15.html": {
    "href": "release-notes/release-1.0.0.0-preview.15.html",
    "title": "What's new in Stride Community Toolkit 1.0.0.0-preview.15 | Stride Community Toolkit Release Notes",
    "summary": "What's new in Stride Community Toolkit 1.0.0.0-preview.15 This article lists the most significant changes in Stride Community Toolkit preview 1.0.0.0-preview.15. What's Changed ✨ Enhancement Toolkit refactoring and improvements, Gizmo added by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/78 \uD83D\uDCC4 Documentation Update HeightmapExtensions.cs by @Idomeneas1970 in https://github.com/stride3d/stride-community-toolkit/pull/69 \uD83D\uDCAA Other Changes Create PickingExample by @Idomeneas1970 in https://github.com/stride3d/stride-community-toolkit/pull/66 [Examples] feat: Code improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/67 refactor: Code improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/68 Toolkit improvements and refactoring. by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/72 Minor refactoring by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/73 Update 10 - Docs and code improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/74"
  },
  "release-notes/release-1.0.0.0-preview.16.html": {
    "href": "release-notes/release-1.0.0.0-preview.16.html",
    "title": "What's new in Stride Community Toolkit 1.0.0.0-preview.16 | Stride Community Toolkit Release Notes",
    "summary": "What's new in Stride Community Toolkit 1.0.0.0-preview.16 This article lists the most significant changes in Stride Community Toolkit preview 1.0.0.0-preview.16. What's Changed \uD83C\uDF89 New Features Adding a helper class for simple image processing by @dotlogix in https://github.com/stride3d/stride-community-toolkit/pull/57 Toolkit 2D Improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/97 \uD83D\uDD27 Engineering increase nexvyaml by @IXLLEGACYIXL in https://github.com/stride3d/stride-community-toolkit/pull/95 increase nexvyaml version by @IXLLEGACYIXL in https://github.com/stride3d/stride-community-toolkit/pull/100 [Refactoring] add module by @IXLLEGACYIXL in https://github.com/stride3d/stride-community-toolkit/pull/101 [Docs] Update README.md by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/102 \uD83D\uDCC4 Documentation Update 14 - Example 7 docs added by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/92 Clean up and docs by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/94 \uD83C\uDF93 Examples Update 13 - 2D scene setup and example added by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/90 Update 15 - 2D scene updates and refactorings by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/96 \uD83D\uDCAA Other Changes Update 11 - Docs improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/79 Modify entity extension by @IXLLEGACYIXL in https://github.com/stride3d/stride-community-toolkit/pull/81 Update 12 - Library improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/82 Image Processing Consistency Updates by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/83 Add example cube clicker by @IXLLEGACYIXL in https://github.com/stride3d/stride-community-toolkit/pull/84 Texture Extensions and reading the Source of an asset by @Idomeneas1970 in https://github.com/stride3d/stride-community-toolkit/pull/85 Example 7 refactoring by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/86 Add cube loading to cube clicker by @IXLLEGACYIXL in https://github.com/stride3d/stride-community-toolkit/pull/87 Example 7 refactoring 2 by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/88 Refactor: UIManager added by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/89 Add SetMaxFPS() by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/91 Add Debug Shapes from Profan by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/93 add new world to screenpoint by @IXLLEGACYIXL in https://github.com/stride3d/stride-community-toolkit/pull/98 Script System Extensions for writing async methods by @DockFrankenstein in https://github.com/stride3d/stride-community-toolkit/pull/99 New Contributors @DockFrankenstein made their first contribution in https://github.com/stride3d/stride-community-toolkit/pull/99 Full Changelog: https://github.com/stride3d/stride-community-toolkit/compare/v1.0.0.0-preview.15...1.0.0.0-preview.16-toolkit/pull/32"
  },
  "release-notes/release-1.0.0.0-preview.17.html": {
    "href": "release-notes/release-1.0.0.0-preview.17.html",
    "title": "What's new in Stride Community Toolkit 1.0.0.0-preview.17 | Stride Community Toolkit Release Notes",
    "summary": "What's new in Stride Community Toolkit 1.0.0.0-preview.17 This article lists the most significant changes in Stride Community Toolkit preview 1.0.0.0-preview.17. This release adds Bepu Physics integration, a new upcoming physics engine for Stride. Some of the new Bepu extensions are specific for code-only approach, while other can be used in the editor generated projects as well. What's Changed \uD83D\uDD27 Engineering Update 14 - Bepu updates and Skybox separated by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/106 ✨ Enhancement feat: Release.yml title updated by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/103 feat: GitHub Actions updated by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/104 \uD83D\uDCC4 Docs fix: Docs improvements and link references fixes by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/105 Full Changelog: https://github.com/stride3d/stride-community-toolkit/compare/v1.0.0.0-preview.16...1.0.0.0-preview.17"
  },
  "release-notes/release-1.0.0.0-preview.20.html": {
    "href": "release-notes/release-1.0.0.0-preview.20.html",
    "title": "What's new in Stride Community Toolkit 1.0.0.0-preview.20 | Stride Community Toolkit Release Notes",
    "summary": "What's new in Stride Community Toolkit 1.0.0.0-preview.20 This article lists the most significant changes in Stride Community Toolkit preview 1.0.0.0-preview.20. This release adds Bepu Physics integration, a new upcoming physics engine for Stride. Some of the new Bepu extensions are specific for code-only approach, while other can be used in the editor generated projects as well. What's Changed \uD83D\uDCA5 Breaking Changes refactor: Bepu references corrected and other updates by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/116 \uD83D\uDD27 Engineering Update 14 - Bepu updates and Skybox separated by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/106 fix: GetCamera() related updates by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/112 refactor: Cleaned up examples by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/113 ✨ Enhancement feat: Release.yml title updated by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/103 feat: GitHub Actions updated by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/104 \uD83D\uDCC4 Docs fix: Docs improvements and link references fixes by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/105 chore: Releatese notes added by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/109 \uD83D\uDD01 Build & Deploy fix: TAG_COMMIT flag added by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/110 fix: Adding Bepu packages references by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/111 Full Changelog: https://github.com/stride3d/stride-community-toolkit/compare/v1.0.0.0-preview.16...1.0.0.0-preview.20"
  },
  "release-notes/release-1.0.0.0-preview.39.html": {
    "href": "release-notes/release-1.0.0.0-preview.39.html",
    "title": "What's new in Stride Community Toolkit 1.0.0.0-preview.20 | Stride Community Toolkit Release Notes",
    "summary": "What's new in Stride Community Toolkit 1.0.0.0-preview.20 This article lists the most significant changes in Stride Community Toolkit preview 1.0.0.0-preview.39. This release adds Bepu Physics integration, a new upcoming physics engine for Stride. Some of the new Bepu extensions are specific for code-only approach, while other can be used in the editor generated projects as well. This update mainly focused on this issue https://github.com/stride3d/stride-community-toolkit/issues/133. I was able to debug the error but I wasn't able to find the issue itself because it happens in the NuGet library itself. I moved on and these are the suggetions for the toolkit for now: Anywhere we reference Stride.Core.Assets.CompilerApp we have to add also <RuntimeIdentifier>win-x64</RuntimeIdentifier> which makes it Windows only. Stride.CommunityToolkit library will have no Stride.Core.Assets.CompilerApp references, so it can be built correctly and be platfom agnostic. Should work in code-only and regular Stride Projects. The new Stride.CommunityToolkit.Windows library will have Stride.Core.Assets.CompilerApp reference and also <RuntimeIdentifier>win-x64</RuntimeIdentifier>, at the moment it is an empty library refrencing Stride.CommunityToolkit project mainly for code-only purpose, just to remove the above boilerplate. That means, code only examples would reference Stride.CommunityToolkit.Windows instead of Stride.CommunityToolkit. This could be done also for Linux later. Stride.CommunityToolkit.Skyboxes library mainly for code-only purpose, will have Stride.Core.Assets.CompilerApp reference removed so the NuGet package can be created. Because it is used with Stride.CommunityToolkit.Windows, it should build correctly What's Changed \uD83D\uDD01 Build & Deploy Update 15 - Cross platform improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/134 Full Changelog: https://github.com/stride3d/stride-community-toolkit/compare/1.0.0.0-preview.38...1.0.0.0-preview.39"
  },
  "release-notes/release-1.0.0.0-preview.41-48.html": {
    "href": "release-notes/release-1.0.0.0-preview.41-48.html",
    "title": "What's new in Stride Community Toolkit 1.0.0.0-preview.41-48 | Stride Community Toolkit Release Notes",
    "summary": "What's new in Stride Community Toolkit 1.0.0.0-preview.41-48 This article lists the most significant changes in Stride Community Toolkit preview 1.0.0.0-preview.41-48. New Contributors @johang88 made their first contribution in https://github.com/stride3d/stride-community-toolkit/pull/179 What's Changed \uD83D\uDCA5 Breaking Changes feat: Moved all bepu libraries into their own package by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/170 \uD83C\uDF89 New Features feat: Particle extensions and Particle example added by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/175 Add vsync enabler by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/150 feat: added ImGui from https://github.com/Eideren/StrideCommunity.ImGuiDebug by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/169 feat: Simple screenshot extension by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/171 \uD83D\uDC1E Bug Fixes fix: Fixed Skybox environemnt light generation by @johang88 in https://github.com/stride3d/stride-community-toolkit/pull/179 Attempt to fix missing shaders for debugshapes by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/147 fix: Correcting example references to Stride.CommunityToolkit.Windows by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/136 \uD83D\uDD27 Engineering chore: NuGet packages bumped by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/185 chore: NuGet packages bumped by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/178 feat: Various updates by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/164 fix: Prevent crash due to NaN by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/168 refactor: Code consistency updates by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/172 chore: NuGet packages bumped by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/163 fix: use maybe null by @IXLLEGACYIXL in https://github.com/stride3d/stride-community-toolkit/pull/151 Refactoring 03 by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/154 Refactoring 04 by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/156 feat: New projects, tutorials, and extensive extension methods to enhance functionality and documentation by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/158 chore: NuGet packages bumped by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/159 Refactoring - Code readability improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/142 refactor: Code improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/143 Refactoring 01 - Further improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/144 [Engine] Refactoring 02 - Code improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/145 update nugets and add config for sdsl files by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/149 Update 17 - Refactoring - Code improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/138 Update 18 - Additional ndepend updates by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/139 \uD83D\uDCC4 Docs docs: Reference runtime win-x64 removed by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/160 feat: Docs updated, mentioning --runtime win-x64 by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/141 docs: Description and Title added by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/135 \uD83C\uDF93 Examples feat: Root renderer example13 by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/181 feat: New examples added, SceneRenderer and Stride UI Drag and Drop by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/165 feat: Render Example code improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/166 feat: Example09_Renderer added by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/161 fix: Project location corrected by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/162 \uD83D\uDD01 Build & Deploy chore: Clean up of unused GitHub actions by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/173 feat: GitHub action updates by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/174 fix: GitHub action improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/140 \uD83D\uDCAA Other Changes Refactoring 05 by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/157 refactor: Spacing updates by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/182 refactor: Code improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/183 feat: Enables sourcelink by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/184 Full Changelog: https://github.com/stride3d/stride-community-toolkit/compare/v1.0.0.0-preview.47...v1.0.0.0-preview.48 https://github.com/stride3d/stride-community-toolkit/compare/v1.0.0.0-preview.46...1.0.0.0-preview.47 https://github.com/stride3d/stride-community-toolkit/compare/v1.0.0.0-preview.45...1.0.0.0-preview.46 https://github.com/stride3d/stride-community-toolkit/compare/v1.0.0.0-preview.44...1.0.0.0-preview.45 https://github.com/stride3d/stride-community-toolkit/compare/v1.0.0.0-preview.42...1.0.0.0-preview.44 https://github.com/stride3d/stride-community-toolkit/compare/v1.0.0.0-preview.41...1.0.0.0-preview.42 https://github.com/stride3d/stride-community-toolkit/compare/v1.0.0.0-preview.39...1.0.0.0-preview.41"
  },
  "release-notes/release-1.0.0.0-preview.49.html": {
    "href": "release-notes/release-1.0.0.0-preview.49.html",
    "title": "What's new in Stride Community Toolkit 1.0.0.0-preview.49 | Stride Community Toolkit Release Notes",
    "summary": "What's new in Stride Community Toolkit 1.0.0.0-preview.49 This article lists the most significant changes in Stride Community Toolkit preview 1.0.0.0-preview.49. What's Changed \uD83D\uDC1E Bug Fixes fix: Update imgui 224 by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/186 \uD83D\uDD27 Engineering chore: Stride updates by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/190 \uD83C\uDF93 Examples feat: Other examples added to the example launcher by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/188 Full Changelog: https://github.com/stride3d/stride-community-toolkit/compare/v1.0.0.0-preview.48...1.0.0.0-preview.49"
  },
  "release-notes/release-1.0.0.0-preview.6.html": {
    "href": "release-notes/release-1.0.0.0-preview.6.html",
    "title": "What's new in Stride Community Toolkit 1.0.0.0-preview.6 | Stride Community Toolkit Release Notes",
    "summary": "What's new in Stride Community Toolkit 1.0.0.0-preview.6 This article lists the most significant changes in Stride Community Toolkit preview 1.0.0.0-preview.6. What's Changed \uD83D\uDCAA Other Changes Merge NexCoreExtensions into it by @IXLLEGACYIXL in https://github.com/stride3d/stride-community-toolkit/pull/18 Merged Doprez.Stride extensions by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/20 Add more extensions by @IXLLEGACYIXL in https://github.com/stride3d/stride-community-toolkit/pull/24 Fix RaySegment by @IXLLEGACYIXL in https://github.com/stride3d/stride-community-toolkit/pull/26 Added docs for Doprez.Stride extensions by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/29 completed basic MyraUI example by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/30 fix: Updating repo references to stride3d organisation by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/32 feat: GitHub Actions added by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/33 GitHub Actions updated by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/34 Update 3 - GitHub Action improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/35 New Contributors @IXLLEGACYIXL made their first contribution in https://github.com/stride3d/stride-community-toolkit/pull/18 @Doprez made their first contribution in https://github.com/stride3d/stride-community-toolkit/pull/20 @VaclavElias made their first contribution in https://github.com/stride3d/stride-community-toolkit/pull/32"
  },
  "release-notes/release-1.0.0.0-preview.7.html": {
    "href": "release-notes/release-1.0.0.0-preview.7.html",
    "title": "What's new in Stride Community Toolkit 1.0.0.0-preview.7 | Stride Community Toolkit Release Notes",
    "summary": "What's new in Stride Community Toolkit 1.0.0.0-preview.7 This article lists the most significant changes in Stride Community Toolkit preview 1.0.0.0-preview.7. What's Changed \uD83D\uDCAA Other Changes Update 4 - Toolkit Improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/36"
  },
  "release-notes/release-1.0.html": {
    "href": "release-notes/release-1.0.html",
    "title": "What's new in Stride Community Toolkit 1.0 | Stride Community Toolkit Release Notes",
    "summary": "What's new in Stride Community Toolkit 1.0 This article highlights the most significant changes in Stride Community Toolkit 1.0 with links to relevant documentation. This is just a placeholder for the release notes. The actual release notes will be generated when the release is published."
  },
  "tutorials.html": {
    "href": "tutorials.html",
    "title": "| Stride Community Toolkit",
    "summary": "C# Game Development with Stride for Beginners \uD83C\uDFAE\uD83D\uDCBB Basic Tutorials \uD83C\uDF31 Tutorial 1 - Give me a Capsule \uD83C\uDF10 This code sets up a basic Stride game with a 3D scene containing a single Capsule entity at a specific position. Tutorial 2 - Meet the Cube \uD83D\uDCE6 Dive deeper into 3D objects by adding a cube to your game. Tutorial 3 - Simple Movements ⬆️⬇️ Learn how to move your Capsule and Cube using keyboard inputs. Tutorial 4 - Let There Be Light \uD83D\uDCA1 Illuminate your scene with different types of light sources. Tutorial 5 - Camera Angles \uD83D\uDCF7 Understand how camera angles affect your game visuals. Intermediate Tutorials \uD83D\uDEE0️ Tutorial 6 - Jumping Mechanism \uD83E\uDD98 Implement a simple jumping mechanism for your Capsule. Tutorial 7 - Texturing the Cube \uD83D\uDDBC️ Learn how to apply textures to your 3D cube. Tutorial 8 - Rotation and Scaling \uD83D\uDD04\uD83D\uDCCF Rotate and scale your entities for more dynamic scenes. Tutorial 9 - Introduction to Physics \uD83C\uDFB3 Introduce simple physics into your game. Tutorial 10 - Audio in Stride \uD83D\uDD0A Add background music and sound effects. Advanced Tutorials \uD83D\uDD27 Tutorial 11 - Level Design \uD83D\uDDFA️ Create a basic level using predefined assets. Tutorial 12 - User Interface (UI) \uD83D\uDDA5️ Integrate a simple UI into your game. Tutorial 13 - Save and Load Game State \uD83D\uDCBE Implement saving and loading game states. Tutorial 14 - Multiplayer Basics \uD83E\uDD1D Start building a multiplayer feature. Tutorial 15 - Animations 101 \uD83C\uDFAD Introduce basic animations to your entities. Specialized Tutorials \uD83C\uDF1F Tutorial 16 - Weather Effects \uD83C\uDF26️ Implement simple weather effects like rain and snow. Tutorial 17 - Game AI: The Roaming NPC \uD83E\uDD16 Create a non-player character (NPC) that moves around. Tutorial 18 - Particle Effects \uD83C\uDF87 Add spectacular particle effects to your game. Tutorial 19 - Timers and Counters ⏲️ Add timers and counters to manage game events. Tutorial 20 - Dialogue System \uD83D\uDCAC Implement a basic dialogue system for storytelling. Expert Tutorials \uD83C\uDF0C Tutorial 21 - Advanced AI Patterns \uD83E\uDD16\uD83E\uDDE0 Learn more sophisticated AI behaviors. Tutorial 22 - Virtual Reality Basics \uD83E\uDD7D Get your game ready for VR experiences. Tutorial 23 - Custom Shaders \uD83C\uDFA8 Write custom shaders for more advanced visuals. Tutorial 24 - Networking Deep Dive \uD83C\uDF10 Take a closer look at multiplayer networking. Tutorial 25 - Game Optimization \uD83D\uDE80 Optimize your game for better performance. Beyond the Basics \uD83C\uDF20 Tutorial 26 - Mobile Game Development \uD83D\uDCF1 Adapt your game for mobile platforms. Tutorial 27 - Cross-Platform Development \uD83C\uDF0D Make your game run on multiple platforms. Tutorial 28 - In-App Purchases \uD83D\uDCB0 Implement in-app purchases. Tutorial 29 - Game Analytics \uD83D\uDCCA Integrate analytics to understand player behavior. Tutorial 30 - Cloud Save ☁️ Learn how to save game states in the cloud. Special Topics \uD83D\uDCD8 Tutorial 31 - Procedural Generation \uD83C\uDF08 Generate levels and content on the fly. Tutorial 32 - Game Localization \uD83C\uDF10 Make your game accessible to international audiences. Tutorial 33 - Streaming Integration \uD83C\uDFA5 Integrate with live-streaming platforms. Tutorial 34 - Game Mods and Community Contributions \uD83D\uDEE0️ Enable modding capabilities in your game. Tutorial 35 - Security and Cheating Prevention \uD83D\uDEE1️ Techniques to make your game secure. Final Projects \uD83C\uDF93 Tutorial 36 - Mini RPG Project \uD83C\uDFF9 Create a small-scale RPG game. Tutorial 37 - Racing Game Project \uD83C\uDFCE️ Build a simple racing game. Tutorial 38 - Puzzle Game Project \uD83E\uDDE9 Develop a basic puzzle game. Tutorial 39 - Platformer Game Project \uD83C\uDFC3‍♂️ Create a basic platformer game. Tutorial 40 - Final Game Showcase \uD83C\uDF89 Show off what you've learned by building your dream game. Bonus Tutorials \uD83C\uDF81 Tutorial 41 - Easter Eggs \uD83E\uDD5A Add hidden features and bonuses. Tutorial 42 - Augmented Reality Basics \uD83C\uDF06 Incorporate AR elements into your game. Tutorial 43 - Game Trailers and Marketing \uD83D\uDCE3 Learn the basics of game marketing. Tutorial 44 - Releasing Your Game \uD83D\uDE80 Steps to launch your game successfully. Tutorial 45 - Post-Launch Maintenance \uD83D\uDEE0️ Keep your game updated and engage your audience. Tutorial 46 - Monetization Strategies \uD83D\uDCB8 Understand different ways to make money from your game. Tutorial 47 - Advanced Game Analytics \uD83D\uDCC8 Deep dive into advanced analytics tools. Tutorial 48 - Game Testing and QA \uD83D\uDC1E Learn quality assurance for game development. Tutorial 49 - Industry Networking \uD83E\uDD1D Tips for building professional relationships. Tutorial 50 - Looking Ahead and Resources \uD83D\uDCD8\uD83D\uDD2D Additional resources for continuing your game development journey. C# Game Development with Stride for Absolute Beginners \uD83C\uDFAE\uD83D\uDCBB Basic Tutorials \uD83C\uDF31 Tutorial 1 - Give me a Capsule \uD83C\uDF10 This code sets up a basic Stride game with a 3D scene containing a single Capsule entity at a specific position. Tutorial 2 - The Stride Game Window \uD83E\uDE9F Learn about the game window, its dimensions, and how to resize it. Tutorial 3 - Understanding Coordinates \uD83D\uDCD0 A beginner's guide to the coordinate system in 3D space. Tutorial 4 - Adding a Cube \uD83D\uDCE6 Add a simple cube to your 3D scene. Tutorial 5 - Move the Cube ⬆️⬇️ Learn the basics of moving the cube along the x, y, and z-axes. Tutorial 6 - Capsule Movements \uD83D\uDEB6‍♂️ Get your Capsule entity moving with simple keyboard inputs. Tutorial 7 - Introducing Basic Lights \uD83D\uDCA1 Understand and add basic lighting to your scene. Tutorial 8 - Changing Background Colors \uD83C\uDF08 Learn how to change the background color of your game window. Tutorial 9 - Camera Basics \uD83D\uDCF7 Set up and manipulate a basic camera in your game. Tutorial 10 - Playing Sounds \uD83D\uDD0A Add basic sound effects and background music to your scene. Tutorial 11 - Understanding Scale \uD83D\uDCCF Learn how to change the size of your Capsule and Cube entities. Tutorial 12 - Simple Collision Detection \uD83C\uDFAF Detect when the Capsule collides with the Cube. Tutorial 13 - Basic Animations \uD83C\uDFAD Create a simple rotation animation for the Cube. Tutorial 14 - Simple UI: Adding Text \uD83C\uDD92 Display text in your game using simple UI elements. Tutorial 15 - Adding Basic Controls \uD83D\uDD79️ Implement basic keyboard and mouse controls for your game. Tutorial 16 - User Inputs: Mouse Controls \uD83D\uDDB1️ Understand how to move entities using mouse inputs. Tutorial 17 - User Inputs: Keyboard Controls ⌨️ Learn to use keyboard inputs for more complex movements. Tutorial 18 - Adding Multiple Cubes \uD83D\uDCE6\uD83D\uDCE6 Learn how to place multiple cubes in your 3D scene. Tutorial 19 - Basic Object Interaction \uD83E\uDD32 Implement basic interaction between the Capsule and Cubes. Tutorial 20 - Creating a Simple Menu \uD83C\uDF71 Build a basic start menu for your game. Tutorial 21 - Pausing the Game ⏸️ Learn how to implement a simple pause functionality. Tutorial 22 - Looping Background Music \uD83C\uDFB5 Make background music loop infinitely during gameplay. Tutorial 23 - Playing Sounds on Collision \uD83C\uDFB6\uD83C\uDFAF Play a sound effect when the Capsule collides with a Cube. Tutorial 24 - Texturing Your Cube \uD83D\uDDBC️ Apply a simple texture to the Cube entity. Tutorial 25 - Texturing the Capsule \uD83C\uDF10 Apply a simple texture to the Capsule entity. Tutorial 26 - Rotate the Camera \uD83D\uDD04 Learn how to rotate the camera around an object. Tutorial 27 - Jump! \uD83E\uDD98 Implement a basic jump mechanism for the Capsule. Tutorial 28 - Gravity 101 ⬇️ Learn how to simulate gravity in your scene. Tutorial 29 - Adding a Simple Skybox ☁️ Add a skybox to make your game more visually appealing. Tutorial 30 - Spawning Random Cubes \uD83C\uDFB2 Create cubes in random positions within the scene. Tutorial 31 - Basic Health System ❤️ Implement a simple health system for the Capsule. Tutorial 32 - Adding a Scoreboard \uD83D\uDCCA Keep track of collisions to maintain a score. Tutorial 33 - Changing Cube Colors \uD83C\uDF08 Learn how to dynamically change the color of cubes. Tutorial 34 - Simple Timers ⏲️ Create countdowns and scheduled events in your game. Tutorial 35 - Adding Levels \uD83D\uDCC8 Implement a simple system for progressing through levels. Tutorial 36 - Exit Game Option \uD83D\uDEAA Add a way for players to exit the game safely. Tutorial 37 - Adding Obstacles \uD83D\uDEA7 Introduce simple obstacles to make your game more challenging. Tutorial 38 - Simple Pick-Ups \uD83C\uDF4E Create items that the Capsule can pick up for points or health. Tutorial 39 - Spinning Cubes \uD83D\uDD04 Make some of your cubes rotate on their own. Tutorial 40 - Bouncing Cubes \uD83E\uDD3E‍♀️ Add a bounce effect to your cubes for dynamic movements. Tutorial 41 - Basic Debugging \uD83D\uDCBB Learn the basics of debugging in Stride. Tutorial 42 - Reading Documentation \uD83D\uDCD6 Understand how to navigate Stride's documentation for help. Tutorial 43 - Importing External Assets \uD83C\uDF0D Learn to import 3D models and other assets into your game. Tutorial 44 - Adding a Ground Plane \uD83C\uDF0D Add a ground plane for reference and interaction. Tutorial 45 - Moving the Ground \uD83C\uDF0D Learn how to create a moving ground for added difficulty. Tutorial 46 - Fading Objects In and Out \uD83D\uDC7B Make objects appear and disappear smoothly. Tutorial 47 - Resetting the Game \uD83D\uDD04 Learn how to reset your game state. Tutorial 48 - Basic Object Pooling \uD83C\uDFCA‍♂️ Reuse Cube entities efficiently using object pooling. Tutorial 49 - First Mini-Game \uD83C\uDF89 Combine all you've learned to create a simple mini-game. Tutorial 50 - Review and Next Steps \uD83D\uDCDD\uD83D\uDC63 Recap everything you've learned and discuss next steps in your game development journey."
  },
  "tutorials/code-only/getting-started.html": {
    "href": "tutorials/code-only/getting-started.html",
    "title": "Get Started | Stride Community Toolkit Tutorials",
    "summary": "Get Started These tutorials cover the code only principles of using C# when working with the Stride game engine."
  },
  "tutorials/code-only/index.html": {
    "href": "tutorials/code-only/index.html",
    "title": "C# Code Only | Stride Community Toolkit Tutorials",
    "summary": "C# Code Only These tutorials cover the code only principles of using C# when working with the Stride game engine."
  },
  "tutorials/index.html": {
    "href": "tutorials/index.html",
    "title": "Stride Game Engine Tutorials | Stride Community Toolkit Tutorials",
    "summary": "Stride Game Engine Tutorials These pages contain tutorials to learn more about the Stride game engine \uD83C\uDFAE. Stride Tutorials New to Stride? Start with these tutorials to get familiar with the basics of the engine and the Game Studio. \uD83D\uDEE0️ Game Studio - The Stride engine comes with an editor called Game Studio, which is the central tool for game and application production in Stride. \uD83C\uDF31 C# Beginner - Covering the beginner principles of using C# when working with the Stride game engine. \uD83D\uDCC8 C# Intermediate - Diving into intermediate principles of C# programming in Stride, including UI, collisions, and more. Stride Community Toolkit Tutorials Mathematics Easing Physics Pick and aim Textures Adding a Texture at Runtime"
  },
  "tutorials/mathematics/easing.html": {
    "href": "tutorials/mathematics/easing.html",
    "title": "Using Easing Functions: Animating Position and Material Color | Stride Community Toolkit Tutorials",
    "summary": "Using Easing Functions: Animating Position and Material Color Easing functions are used in animations to create smooth transitions between values over a specified time. In this tutorial, we'll explore how to use easing functions not only to move a 3D object but also to interpolate its material color. This will allow us to create animations that blend both movement and visual effects. What You'll Learn How to create a 3D primitive (cube). How to implement easing functions for smooth transitions in animations. How to animate the movement of a 3D object using easing functions. How to interpolate and change the material color of a 3D object dynamically. Code Walkthrough using Stride.BepuPhysics; using Stride.BepuPhysics.Definitions.Colliders; using Stride.CommunityToolkit.Bepu; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Mathematics; using Stride.CommunityToolkit.Rendering.ProceduralModels; using Stride.Core.Mathematics; using Stride.Engine; using Stride.Games; using Stride.Input; using Stride.Rendering.Materials; // Time elapsed since the start of the animation var elapsed = TimeSpan.Zero; // Duration of the animation (2 seconds) var duration = TimeSpan.FromSeconds(2); // Target position (where the object will ease to) var bottom = new Vector3(0, 2, 0); // Starting position of the object var startPosition = new Vector3(0, 8, 0); // 3D entity to be animated var entity = new Entity(); // Color to interpolate to, initilized to white Color color = Color.White; // Initialize a new game instance using var game = new Game(); // Run the game, specifying both the Start and Update methods game.Run(start: Start, update: Update); // Setup and initialize the scene void Start(Scene scene) { // Set up a base 3D scene with default lighting and camera game.SetupBase3DScene(); // Create a 3D sphere primitive and assign the material to it entity = game.Create3DPrimitive(PrimitiveModelType.Sphere, new() { Material = game.CreateMaterial(Color.White), Component = new BodyComponent() { Collider = new CompoundCollider(), Kinematic = true } }); // Add the sphere entity to the root scene entity.Scene = scene; var random = new Random(); // Generate a random color to interpolate to color = random.NextColor(); } // Update the scene every frame (for animations and input handling) void Update(Scene scene, GameTime time) { game.DebugTextSystem.Print(\"Press Space to reset\", new Int2(5, 10)); // Calculate the progress of the animation as a ratio between 0 and 1 var progress = (float)(elapsed.TotalSeconds / duration.TotalSeconds); if (progress > 1.0f) { progress = 1.0f; } // Interpolate the position of the object using a quintic easing function var position = MathUtilEx.Interpolate(startPosition, bottom, progress, EasingFunction.QuinticEaseOut); Console.WriteLine(position); // Apply the new position to the entity entity.Transform.Position = position; // Interpolate the color using a linear easing function var diffuse = MathUtilEx.Interpolate(Color.White, color, progress, EasingFunction.Linear); // Apply the interpolated color to the material entity.Get<ModelComponent>().SetMaterialParameter(MaterialKeys.DiffuseValue, diffuse); // Update the elapsed time with the time since the last frame elapsed += time.Elapsed; // Reset the animation when the spacebar is pressed if (game.Input.IsKeyPressed(Keys.Space)) { elapsed = TimeSpan.Zero; } } Code Breakdown Position Animation: The MathUtilEx.Interpolate method is used with a quintic easing function to smoothly transition the sphere's position from its start to its end position. Material Color Animation: The same interpolation approach is applied to change the color of the sphere’s material. A linear easing function is used to gradually change the color from white to a randomly generated color. Resetting the Animation: The animation is reset each time the spacebar is pressed, allowing the movement and color transition to start over. Running the Code When you run the code, you'll see a 3D sphere smoothly moving from the starting position (8 units above the ground) to the bottom (2 units above the ground) over a duration of 2 seconds. At the same time, the sphere’s material color will gradually change from white to a randomly generated color. You can press the spacebar to reset the animation and see the sphere rise back to the top while its color returns to white. Summary In this tutorial, you learned how to animate both the position and material color of a 3D object using easing functions. This technique allows you to create smooth and visually appealing transitions, which are essential for creating polished game experiences."
  },
  "tutorials/physics/pick-and-aim.html": {
    "href": "tutorials/physics/pick-and-aim.html",
    "title": "Raycasting and Camera Focus | Stride Community Toolkit Tutorials",
    "summary": "Raycasting and Camera Focus In this tutorial, we will learn how to use raycasting to detect entities in a 3D scene and adjust the camera to focus on them. This technique is useful for games or simulations where you need to interact with objects using the mouse and smoothly transition the camera's focus based on those interactions. What You'll Learn How to create 3D entities and assign materials to them. How to use raycasting to detect objects in a 3D scene. How to use the camera to smoothly look at the target entity. Code Walkthrough using Stride.CommunityToolkit.Bepu; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Games; using Stride.CommunityToolkit.Rendering.ProceduralModels; using Stride.Core.Mathematics; using Stride.Engine; using Stride.Games; Entity? target = null; CameraComponent? camera = null; using var game = new Game(); game.Run(start: Start, update: Update); void Start(Scene scene) { // Set up a base 3D scene with default lighting and camera game.SetupBase3DScene(); // Add a gizmo to help visualize the ground plane and axis directions game.AddGroundGizmo(showAxisName: true); // Create a cube entity with a violet material and position it in the scene var cube = game.Create3DPrimitive(PrimitiveModelType.Cube, new() { Material = game.CreateMaterial(Color.Violet), }); // Set the position of the cube cube.Transform.Position = new Vector3(0, 8, -3); // Add cube to the scene cube.Scene = scene; // Create a sphere entity with a wheat-colored material var entity = game.Create3DPrimitive(PrimitiveModelType.Sphere, new() { Material = game.CreateMaterial(Color.Wheat), }); // Set the position of the sphere entity.Transform.Position = new Vector3(-4, 8, 0); // Add sphere to the scene entity.Scene = scene; // Retrieve the camera from the scene camera = scene.GetCamera(); } // Update method called every frame to handle game logic void Update(Scene scene, GameTime gameTime) { game.DebugTextSystem.Print(\"Click on a sphere, cube or ground to move camera\", new Int2(5, 10)); // Ensure that the camera is initialized if (camera is null) return; // Check if the left mouse button is pressed if (game.Input.IsMouseButtonPressed(Stride.Input.MouseButton.Left)) { var hit = camera.Raycast(game.Input.MousePosition, 100, out var hitInfo); if (hit) { target = hitInfo.Collidable.Entity; } else { Console.WriteLine(\"No hit\"); } } // If a target entity is set, make the camera smoothly look at it if (target != null) { camera.Entity.Transform.LookAt(target.Transform, game.DeltaTime() * 3.0f); } } Code Walkthrough Game Setup: In the Start() method, we set up a basic 3D scene with lighting and a camera using the SetupBase3DScene() helper method. We then create two 3D entities, a cube and a sphere, and position them in the scene with different materials. Raycasting with Mouse Input: In the Update() method, we check if the left mouse button is pressed. If pressed, a ray is cast from the mouse position into the 3D world using ScreenToWorldRaySegment(). This ray is used to check for collisions with 3D entities in the scene via raycasting. Camera Focus: If the ray successfully hits an entity, that entity becomes the target. The camera then uses the LookAt() method to smoothly focus on the target entity, giving the player a clear view of the object they clicked on. Running the Code When you run this code, the game will display a 3D scene with a cube and a sphere. By clicking on either object with the mouse, the camera will smoothly rotate to focus on the clicked object. The left mouse button controls the focus. Summary This example demonstrates how to use raycasting to detect entities in a scene based on mouse input and how to adjust the camera to focus on those entities. This technique is useful for games that require interactive environments, object selection, or camera-based interactions. Feel free to extend this concept by adding more entities, adjusting the camera's behavior, or experimenting with different easing functions for camera movement."
  },
  "tutorials/textures/add-a-texture.html": {
    "href": "tutorials/textures/add-a-texture.html",
    "title": "Adding a Texture at Runtime | Stride Community Toolkit Tutorials",
    "summary": "Adding a Texture at Runtime In this tutorial, we will explore how to dynamically apply a texture to a 3D object in your Stride project. By using the Texture class, you can load an image file at runtime and assign it to a 3D entity. We will demonstrate how to do this by applying a texture to a cube. What You'll Learn How to load a texture from an image file at runtime. How to create and configure a MaterialDescriptor to apply the texture to a 3D object. How to create a 3D primitive (cube) and assign the texture as its material. Code Walkthrough using Stride.CommunityToolkit.Bepu; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Rendering.ProceduralModels; using Stride.Core.Mathematics; using Stride.Engine; using Stride.Graphics; using Stride.Rendering; using Stride.Rendering.Materials; using Stride.Rendering.Materials.ComputeColors; using var game = new Game(); game.Run(start: Start); void Start(Scene scene) { // Set up a base 3D scene with default lighting and camera game.SetupBase3DScene(); // Load the texture from a file var texturePath = \"Stride-logo.png\"; using var textureFile = File.Open(texturePath, FileMode.Open); var texture = Texture.Load(game.GraphicsDevice, textureFile); // Create a material descriptor and assign the loaded texture to it var materialDescriptor = new MaterialDescriptor { Attributes = new MaterialAttributes { Diffuse = new MaterialDiffuseMapFeature(new ComputeTextureColor(texture)), // Configures using the Lambert lighting model, // which simulates how light interacts with the surface DiffuseModel = new MaterialDiffuseLambertModelFeature(), // Specifies the back-face culling mode CullMode = CullMode.Back } }; // Create a material instance from the descriptor var material = Material.New(game.GraphicsDevice, materialDescriptor); // Create a 3D cube primitive and assign the material to it var entity = game.Create3DPrimitive(PrimitiveModelType.Cube, new() { Material = material, }); entity.Transform.Position = new Vector3(0, 8, 0); // Add the cube to the root scene entity.Scene = scene; } Running the Code When you run this code, the game will display a 3D cube with the specified texture applied to its surface. The texture will be visible, and the cube will be placed 8 units above the ground. Summary This example demonstrates how to dynamically load and apply a texture to a 3D object at runtime in Stride. The process involves: Loading a texture from an image file. Creating a material to define how the texture should be rendered. Applying the material to a 3D primitive and adding it to the scene. This approach can be extended to various other 3D models and textures, allowing you to dynamically change the appearance of objects in your game."
  }
}